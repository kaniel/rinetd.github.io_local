<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>libev on 时光小栈</title><link>/tags/libev/</link><description>Recent content in libev on 时光小栈</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><managingEditor>rinetd@163.com (rinetd)</managingEditor><webMaster>rinetd@163.com (rinetd)</webMaster><copyright>Copyright (c) 2017. All rights reserved. (版权所有) &lt;a href=&#39;http://www.miitbeian.gov.cn/&#39;&gt;鲁ICP备17074587号-1&lt;/a&gt;</copyright><lastBuildDate>Sat, 31 Oct 2020 21:52:25 +0800</lastBuildDate><atom:link href="/tags/libev/feed.xml" rel="self" type="application/rss+xml"/><item><title>libev_ev_async</title><link>/language/clang/libev/libev_ev_async/</link><pubDate>Sat, 31 Oct 2020 21:52:25 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/libev/libev_ev_async/</guid><description>// 在其它线程发通知事件给EV LOOP主线程 ev_async async_w; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;pthread.h&amp;gt; #include &amp;lt;ev.h&amp;gt; struct ev_loop *loop = NULL; static ev_async async_watcher; static void async_cb(EV_P_ ev_async *w, int revents) { static int cb_count = 0; printf(&amp;quot;async_cb() call, cb_count = %d %d\n&amp;quot;, cb_count++,revents); } void *ev_create(void *p) { printf(&amp;quot;ev_create() call, start!\n&amp;quot;); loop = ev_loop_new(EVFLAG_AUTO);</description></item><item><title>libev_io_socket</title><link>/language/clang/libev/libev_io_socket/</link><pubDate>Mon, 19 Oct 2020 17:50:02 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/libev/libev_io_socket/</guid><description>/* * @author : * @date : 2014-09-04 * @desc : tiny socket server implemented by libev * to use this, you should install libev at first. * * server: just run the program * client: telnet localhost 8080 * * @refer : 1). http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod * 2). http://blog.csdn.net/lengzijian/article/details/8315133 * */ #include &amp;lt;ev.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;netinet/in.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #define PORT 8080 #define BUFFER_SIZE 1024 #define MAX_CONNECTIONS 10 struct ev_io *libevlist[MAX_CONNECTIONS] = {NULL}; void on_accept(struct ev_loop *loop, struct ev_io *watcher, int revents); void on_read(struct ev_loop *loop, struct ev_io *watcher, int revents); /* Server Client socket socket | | v v bind connect | | v v listen write | | v v accept read | | v v read close | v write | v close */ int main() { struct ev_loop *loop = ev_default_loop(0); /* socket start */ int sd; struct sockaddr_in addr; int addr_len = sizeof(addr); struct ev_io *socket_watcher = (struct ev_io*)malloc(sizeof(struct ev_io)); struct ev_timer *timeout_watcher = (struct ev_timer*)malloc(sizeof(struct ev_timer)); // socket sd = socket(PF_INET, SOCK_STREAM, 0); if (sd &amp;lt; 0) { printf(&amp;quot;socket error\n&amp;quot;); return -1; } bzero(&amp;amp;addr, sizeof(addr)); addr.</description></item><item><title>libev</title><link>/language/clang/libev/libev/</link><pubDate>Mon, 19 Oct 2020 16:01:15 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/libev/libev/</guid><description>libev教程一：libev简单入门_把握自己。-CSDN博客 libev是个非常优秀的基于事件的循环库，很多开源软件，比如nodejs就是使</description></item></channel></rss>
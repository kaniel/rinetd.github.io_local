<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>socket on 时光小栈</title><link>/tags/socket/</link><description>Recent content in socket on 时光小栈</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><managingEditor>rinetd@163.com (rinetd)</managingEditor><webMaster>rinetd@163.com (rinetd)</webMaster><copyright>Copyright (c) 2017. All rights reserved. (版权所有) &lt;a href=&#39;http://www.miitbeian.gov.cn/&#39;&gt;鲁ICP备17074587号-1&lt;/a&gt;</copyright><lastBuildDate>Fri, 09 Oct 2020 15:03:47 +0800</lastBuildDate><atom:link href="/tags/socket/feed.xml" rel="self" type="application/rss+xml"/><item><title>linux socket keepalive</title><link>/language/clang/socket/linux-socket-keepalive/</link><pubDate>Fri, 09 Oct 2020 15:03:47 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/socket/linux-socket-keepalive/</guid><description>// int keepalive = 1; // 开启keepalive属性 // int keepidle = 60; // 如该连接在60秒内没有任何数据往来,则进行探测 // int keepinterval = 5; // 探测时发包的时间间隔为5 秒 // int keepcount</description></item><item><title>Linux网络编程--epoll模型ET触发模式之epolloneshot事件</title><link>/language/clang/socket/linux-socket-epolloneshot/</link><pubDate>Wed, 24 Jun 2020 10:16:16 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/socket/linux-socket-epolloneshot/</guid><description>Linux网络编程--epoll模型ET触发模式之epolloneshot事件 epoll模型的ET模式一般来说只触发一次，然而在并发程序中有</description></item><item><title>linux socket ifreq 设置IP地址</title><link>/language/clang/socket/linux-socket-ifreq/</link><pubDate>Thu, 04 Jun 2020 19:27:59 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/socket/linux-socket-ifreq/</guid><description>Linux网络接口操作之ioctl-1_接口参数 - 反刍动物 - SegmentFault 思否 strace ./ifconfig socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 5 ioctl(5, SIOCSIFADDR, {ifr_name=&amp;quot;eth0:8&amp;quot;, ifr_addr={AF_INET, inet_addr(&amp;quot;192.168.1.202&amp;quot;)}}) = 0 ioctl(5, SIOCGIFFLAGS, {ifr_name=&amp;quot;eth0:8&amp;quot;, ifr_flags=IFF_UP|IFF_BROADCAST|IFF_RUNNING|IFF_MULTICAST}) = 0 ioctl(5, SIOCSIFFLAGS, {ifr_name=&amp;quot;eth0:8&amp;quot;, ifr_flags=IFF_UP|IFF_BROADCAST|IFF_RUNNING|IFF_MULTICAST}) = 0 close(5) = 0 Complete source code: #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include</description></item><item><title>linux socket hton innet_pton</title><link>/language/clang/socket/linux-socket-hton-innet_pton/</link><pubDate>Thu, 04 Jun 2020 18:51:49 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/socket/linux-socket-hton-innet_pton/</guid><description>(1条消息)sockaddr_in与sockaddr的区别，以及对网络字节序和主机字节序的理解和转换函数_ZWE7616175的博客-CSD</description></item><item><title>linux socket udp</title><link>/language/clang/socket/linux-socket-udp/</link><pubDate>Thu, 04 Jun 2020 17:22:32 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/socket/linux-socket-udp/</guid><description>int udp_send_resp(int fd, char *ip, uint16_t port, char *in, int in_len, char *out, int *out_len) { // int sockfd; // if ((sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1) // { // perror(&amp;quot;Socket &amp;quot;); // exit(1); // } struct sockaddr_in local_addr, remote_addr; socklen_t slen = sizeof(remote_addr); remote_addr.sin_family = AF_INET; remote_addr.sin_port = htons(port); //htons(atoi(port)); remote_addr.sin_addr.s_addr = inet_addr(ip); memset(remote_addr.sin_zero, &#39;\0&#39;, sizeof(remote_addr.sin_zero)); // recvfrom 超时时间 struct timeval timeout; timeout.tv_sec = 3;</description></item></channel></rss>
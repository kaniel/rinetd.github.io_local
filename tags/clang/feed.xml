<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>clang on 时光小栈</title><link>/tags/clang/</link><description>Recent content in clang on 时光小栈</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><managingEditor>rinetd@163.com (rinetd)</managingEditor><webMaster>rinetd@163.com (rinetd)</webMaster><copyright>Copyright (c) 2017. All rights reserved. (版权所有) &lt;a href=&#39;http://www.miitbeian.gov.cn/&#39;&gt;鲁ICP备17074587号-1&lt;/a&gt;</copyright><lastBuildDate>Tue, 20 Oct 2020 17:02:49 +0800</lastBuildDate><atom:link href="/tags/clang/feed.xml" rel="self" type="application/rss+xml"/><item><title>linux_c__attribute__pragma_pack</title><link>/language/clang/linux_c__attribute__pragma_pack/</link><pubDate>Tue, 20 Oct 2020 17:02:49 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux_c__attribute__pragma_pack/</guid><description>【区别】 pragma作用于结构内的成员变量；attribute ((aligned(n)))作用于结构体分配地址的对齐方式 和 结构体的大小。 typedef struct</description></item><item><title>linux clib gear lib</title><link>/language/clang/linux-clib-gear-lib/</link><pubDate>Wed, 07 Oct 2020 15:57:45 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-clib-gear-lib/</guid><description>Macos 下的交叉编译 修改 build的目录下的 修改Makefile # ARCH ?= linux CROSS_PREFIX ?=arm-none-linux-gnueabi- ###</description></item><item><title>linux clock_settime</title><link>/language/clang/linux-clock_settime/</link><pubDate>Sun, 27 Sep 2020 17:40:07 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-clock_settime/</guid><description>#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;time.h&amp;gt; int main () { // 获取时间戳 time_t seconds = time(NULL); //The function time(NULL) returns the time since the Epoch (00:00:00 UTC, January 1, 1970), measured in seconds. sprintf(timestamp, &amp;quot;%-llu&amp;quot;, (unsigned long long int)seconds); time_t start_t, end_t; double diff_t; printf(&amp;quot;程序启动...\n&amp;q</description></item><item><title>linux hlist_head</title><link>/language/clang/linux-hlist_head/</link><pubDate>Fri, 25 Sep 2020 22:11:14 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-hlist_head/</guid><description>CC = gcc CFLAGXX := -Wall -g3 CFLAGXX += -fPIC INCDIR := . -I ../inc BINDIR := ../bin LIBDIR := ../lib LIB := libhlist.so TARGET = hlist_demo all: $(TARGET) SOURCE := $(wildcard *.c) $(wildcard *.cpp) OBJS := $(patsubst %.c, %.o, $(patsubst %.cpp, %.o, $(SOURCE))) LIBOBJS = $(filter-out rbtreedemo.o, $(OBJS)) %.o: %.c $(CC) $(CFLAGXX) -I $(INCDIR) -c $^ -o $@ %.o: %.cpp $(CC) $(CFLAGXX) -I $(INCDIR) -c $^ -o $@ $(TARGET): $(OBJS) @mkdir -p $(BINDIR) $(CC) $^ -o $(shell pwd)/$(BINDIR)/$(TARGET) # $(CC) -fPIC -shared $(LIBOBJS) -L $(LIBDIR) -lrbtree -o $(shell pwd)/$(LIBDIR)/$(LIB) .</description></item><item><title>linux list_head</title><link>/language/clang/linux-list_head/</link><pubDate>Fri, 25 Sep 2020 20:23:58 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-list_head/</guid><description>一起分析内核最重要的链表list_head 一、链表结构 struct list_head { struct list_head *next, *prev; }; 二、链表初始化函数 list_head 链表的初始化只是把 *next, *prev连个指针指向链表头，</description></item><item><title>linux cross libuv</title><link>/language/clang/linux-cross-libuv/</link><pubDate>Mon, 21 Sep 2020 18:01:09 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-cross-libuv/</guid><description>交叉编译 git clone https://github.com/libuv/libuv sh autogen.sh $ ./configure --prefix=/tmp/libuv_prefix --host=arm-none-linux-gnueabi CC=arm-none-linux-gnueabi-gcc $ make $ make check $ make install 2.交叉编译libuv ./autogen.sh CC=/opt/embedded/tools/bin/arm-linux-gnueabihf-gcc CFLAGS=-I/opt/embedded/platform/usr/include LDFLAGS=-L/opt/embedded/platform/usr/lib LIBS=-ludev ./configure --prefix=/opt/embedded/platform/usr/ --host=arm-linux make install</description></item><item><title>linux c string</title><link>/language/clang/linux-c-string/</link><pubDate>Mon, 07 Sep 2020 17:43:15 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-c-string/</guid><description>C语言字符串操作 · ZMonster&#39;s Blog 目录 string.h 字符串拷贝(strcpy, strncpy) strcpy strncpy 字符串比较(strcmp, strncmp, strcasecmp, strncasecmp) strcmp strncmp strcasecmp strncasecmp 字符串连接(strcat, strncat) strcat strncat 字符查找</description></item><item><title>clang mongoose</title><link>/language/clang/clang-mongoose/</link><pubDate>Mon, 20 Jul 2020 09:10:32 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/clang-mongoose/</guid><description>static void* ws_task(void* parm); int http_open(int port) { signal(SIGPIPE, SIG_IGN); system(&amp;quot;ifconfig lo 127.0.0.1&amp;quot;); s_received_signal = 0; if(pthread_create(&amp;amp;gpid, NULL, ws_task, (void*)port) != 0) { printf(&amp;quot;create ws_task error%d(%s)\n&amp;quot;,errno, strerror(errno)); return -1; } return 0; } /* * Copyright (c) 2014 Cesanta Software Limited * All rights reserved */ #include &amp;quot;mongoose.h&amp;quot; static const char *s_http_port = &amp;quot;8000&amp;quot;; static struct mg_serve_http_opts s_http_server_opts; static void handle_sum_call(struct mg_connection *nc, struct http_message *hm) { char n1[100], n2[100];</description></item><item><title>c语言位操作黑科技bithacker</title><link>/language/clang/c-bithacker/</link><pubDate>Thu, 16 Jul 2020 10:53:15 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/c-bithacker/</guid><description>http://graphics.stanford.edu/~seander/bithacks.html 1 检测两个数是否异号: int x,y; bool f= ((x^ y) &amp;lt;0); 2 取最大/小值 int x; // we want to find the minimum of x and y int y; int r; // the result goes here r = y ^ ((x ^ y) &amp;amp; -(x &amp;lt; y)); // min(x, y) r = x ^ ((x ^ y) &amp;amp;</description></item><item><title>clang linux kfifo ringbuffer</title><link>/language/clang/clang-linux-kfifo-ringbuffer/</link><pubDate>Wed, 15 Jul 2020 19:06:10 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/clang-linux-kfifo-ringbuffer/</guid><description>git@github.com:dennis-musk/ringbuffer.git Description: 环形缓冲区的实现 Others: 1.min的妙用，(验证剩余有效空间和要求要读出或者写入空间 取最小值) 2.利用unsigned int 的回环,in 和 out一</description></item><item><title>clang gcc</title><link>/language/clang/clang-gcc/</link><pubDate>Tue, 23 Jun 2020 19:09:22 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/clang-gcc/</guid><description>源文件经过预处理器，完成预编译，生成预编译.i文件 gcc -o hello.i -E hello.c 预编译文件经过编译器，完成编译，生成汇编.s文件 gcc -o hello.s -S hello.i 汇编文件进过汇编器，生</description></item><item><title>Epoll&#43;Timerfd实现定时器</title><link>/language/clang/socket/linux-clang-epoll-timerfd/</link><pubDate>Wed, 17 Jun 2020 19:34:29 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/socket/linux-clang-epoll-timerfd/</guid><description>timerfd的使用方法 - 简书 linux新API---timerfd的使用方法 timerfd是Linux为用户程序提供的一个定时器接口。这个</description></item><item><title>linux time elapsed</title><link>/language/clang/linux-time-elapsed/</link><pubDate>Fri, 05 Jun 2020 15:58:23 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-time-elapsed/</guid><description>long elapsed(START_TIME_TYPE start_time) { struct timeval now, res; gettimeofday(&amp;amp;now, NULL); timersub(&amp;amp;now, &amp;amp;start_time, &amp;amp;res); return (res.tv_sec)*1000 + (res.tv_usec)/1000; }</description></item><item><title>clang linux epool socket</title><link>/language/clang/clang-linux-epool-socket/</link><pubDate>Thu, 04 Jun 2020 13:39:23 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/clang-linux-epool-socket/</guid><description>第一篇 TCP server 守护进程daemonize的源码可以借鉴redis的： void daemonize(void) { //come from /redis/server.c/daemonize() int fd; if (fork() != 0) exit(0); /* parent exits */ setsid(); /* create a new session */ /* Every output goes to /dev/null. If Redis is daemonized but * the &#39;logfile&#39;</description></item><item><title>linux clang warpper utils</title><link>/language/clang/linux-clang-warpper-utils/</link><pubDate>Fri, 29 May 2020 19:05:35 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-clang-warpper-utils/</guid><description>/* * ===================================================================================== * * Filename: wrapper.h * * Description: wrapper * * Version: * Created: * Revision: none * Compiler: gcc * * Author: * Company: * Modify: * * ===================================================================================== */ #ifndef __WRAPPER_H__ #define __WRAPPER_H__ #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;errno.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;sys/stat.h&amp;gt; #include &amp;lt;time.h&amp;gt; #include &amp;lt;utime.h&amp;gt; #include &amp;lt;pthread.h&amp;gt; #include &amp;lt;semaphore.h&amp;gt; #include &amp;lt;assert.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;dirent.h&amp;gt; #include &amp;lt;sys/mman.h&amp;gt; #include &amp;lt;sys/time.h&amp;gt; #include</description></item><item><title>linux lib nanomsg</title><link>/language/clang/linux-lib-nanomsg/</link><pubDate>Mon, 25 May 2020 08:30:56 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-lib-nanomsg/</guid><description>海思移植nanomsg 修改 CMakeLists.txt 增加海思支持 ```makefile set cross-compiled system type, it&#39;s better not use the type which cmake cannot recognized. SET ( CMAKE_SYSTEM_NAME Linux ) SET ( CMAKE_SYSTEM_PROCESSOR arm ) when hislicon SDK was installed, toolchain was installed in the path as below: SET ( CMAKE_C_COMPILER /opt/hisi-linux/x86-arm/arm-himix200-linux/bin/arm-himix200-linux-gcc ) SET ( CMAKE_CXX_COMPILER /opt/hisi-linux/x86-arm/arm-himix200-linux/bin/arm-himix200-linux-g++ ) SET (</description></item><item><title>clang mini xml</title><link>/language/clang/clang-mini-xml/</link><pubDate>Tue, 12 May 2020 16:39:52 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/clang-mini-xml/</guid><description>昨天简单写了在VxWorks平台应用mini-XML库解析xml文件，以及怎样用。 https://blog.csdn.net/jianzhao6205/article/details/81638197 今天将根据函数手册写一个例程，主要功能为：使用库函数生成</description></item><item><title>clang jpeg</title><link>/language/clang/clang-jpeg/</link><pubDate>Thu, 30 Apr 2020 16:53:39 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/clang-jpeg/</guid><description>/* 这是read_picture.c 文件的代码 ，主要是对输入的图片的文件（BMP和JPEG类型）进行解码，转换成在LCD中显示的数据； 使用该程</description></item><item><title>linux mqtt</title><link>/language/clang/linux-mqtt/</link><pubDate>Tue, 14 Apr 2020 17:36:59 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-mqtt/</guid><description>将paho.mqtt.c-master.zip复制到/opt下解压 unzip paho.mqtt.c-master.zip 交叉编译： l cmake . -DPAHO_BUILD_STATIC=TRUE -DCMAKE_C_COMPILER=/opt/gcc-cross-arm/FriendlyARM/toolschain/4.4.3/bin/arm-none-linux-gnueabi-gcc -DCMAKE_CXX_COMPILER=/opt/gcc-cross-arm/FriendlyARM/toolschain/4.4.3/bin/arm-none-linux-gnueabi-g++ 其中指定是静态编译、指定交叉编译器 若开启SSL加</description></item><item><title>linux 线程自动使用资源 pthread_detach(pthread_self())</title><link>/language/clang/linux-c-pthread_detach/</link><pubDate>Mon, 06 Apr 2020 17:18:52 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-c-pthread_detach/</guid><description>// 方式1: 子线程自动释放 void* reboot_thread_func() { pthread_detach(pthread_self()); usleep(3000000);/*sleep 3s*/ system(&amp;quot;reboot&amp;quot;); pthread_exit((void *)NULL); } // 方式2: 在主线程中释放 void start_pthread(void *(*func)(void *), void *arg, int count) { int err; pthread_t tid; pthread_attr_t attr; pthread_attr_init(&amp;amp;attr); pthread_attr_setdetachstate(&amp;amp;attr, PTHREAD_CREATE_DETACHED); for (int i = 0; i &amp;lt; count; i++) { err = pthread_create(&amp;amp;tid, &amp;amp;attr, func, arg); if (err)</description></item><item><title>clang setbit clearbit</title><link>/language/clang/clang-setbit-clearbit/</link><pubDate>Tue, 17 Mar 2020 14:31:44 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/clang-setbit-clearbit/</guid><description>/include/linux/bitops.h
#define SET_BIT(x, n) (x |= (1 &amp;lt;&amp;lt; n)) #define CLR_BIT(x, n) (x &amp;amp;= ~(1 &amp;lt;&amp;lt; n)) #define GET_BIT(x, n) ((x &amp;gt;&amp;gt; n) &amp;amp; 0x01) #define set_bit(register_8, bit) (register_8 |= (1 &amp;lt;&amp;lt; bit)) #define clear_bit(register_8, bit) (register_8 &amp;amp;= ~(1 &amp;lt;&amp;lt; bit)) #define toggle_bit(register_8, bit) (register_8 ^= (1 &amp;lt;&amp;lt; bit)) #define set_bit(reg,bit) reg|=(1&amp;lt;&amp;lt;bit) //pondra en 1 el bit elegido de la variable elegida. #define clr_bit(reg,bit) reg&amp;amp;=~(1&amp;lt;&amp;lt;bit) //pondra en 0 el bit elegido de la variable elegida.</description></item><item><title>glibc printf</title><link>/language/clang/glibc-printf/</link><pubDate>Sat, 22 Feb 2020 11:25:31 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/glibc-printf/</guid><description>printf 打印指定长度字符串 转载rusty_knife 最后发布于2018-05-15 11:36:44 阅读数 4682 收藏 展开 1.原样输出字符串: printf(&amp;quot;%s&amp;quot;, str); 输出指定长度的字符串,</description></item><item><title>Linux驱动中的 wait_event_interruptible 与 wake_up_interruptible 深度理解</title><link>/language/clang/linux-wait_event_interruptible/</link><pubDate>Tue, 11 Feb 2020 11:44:43 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-wait_event_interruptible/</guid><description>linux字符驱动之中断按键_lwj103862095的专栏-CSDN博客 等待队列： 在 Linux 驱动程序设计中，可以使用等待队列来实现进程的阻塞. 等</description></item><item><title>linux c crypto</title><link>/language/clang/linux-c-crypto/</link><pubDate>Wed, 05 Feb 2020 19:14:22 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-c-crypto/</guid><description>https://gist.github.com/neikeq/d6d00bd24db606dd0b86
#ifndef _DEFINE_H_ #define _DEFINE_H_ #define OK 0 #define NOK -1 #define YES 1 #define NO 0 #define MAX_SERVER 50 #define MAX_PLAYER 500 #define MAX_ROOM 150 #define MAX_TEAM 150 #define MAX_VIEWER 4 #define MAX_ATHLETE 10 #define MAX_ITEM 70 #define MAX_LEVEL 50 #define MAX_LEVEL_SECTION (MAX_LEVEL/5)+1 #define MAX_TIP 50 #define MAX_MISSION 46 #define MAX_HOLIDAY 50 #define MAX_CARDSKILL 3 #define MAX_CARDRANK 4 #define MAX_BUDDY 30 #define MAX_BLACKLIST 30 #define EMBLEM_TYPE_GOLD 604101101 #define EMBLEM_TYPE_SILVER 604101102 #define MAX_PATH 255 #define GAME_PLAY_TIME 300 #define ID_NAME_SIZE (15 * 2) + 1 #define PLAYER_NAME_SIZE (7 * 2) + 1 #define OBJECT_NAME_SIZE (20 * 2) + 1 #define SERVER_NAME_SIZE (15 * 2) + 1 #define TITLE_NAME_SIZE (23 * 2) + 1 #define CLUB_NAME_SIZE (10 * 2) + 1 #define PLAYER_MENT_SIZE (22 * 2) + 1 #define MESSAGE_SIZE (40 * 2) + 1 #define PASS_SIZE (10 * 2) + 1 #define LOGIN_PASS_SIZE (32 * 2) + 1 #define TIP_SIZE (60 * 2) + 1 #define MISSTION_TEXT_SIZE (60 * 2) + 1 #define MAX_MUSIC_COUNT 3 #define MAX_EQUIP 17 #define MAX_FACULTY 130 #define MAX_CHARACTER 3 #define MAX_INVEN 80 #define MAX_SKILL 50 #define MAX_CEREMONY 5 #define MAX_CARD 100 #define MAX_SCHEDULE_LIST 10 #define MAX_BUDDY_LIST 10 #define MAX_ITEM_LIST 10 #define MAX_ITEM_LIST 10 #define MAX_TRAINING_LIST 10 #define MAX_CEREMONEY_LIST 5 #define MAX_SKILL_LIST 50 #define MAX_QUEST_LIST 10 #define MAX_CARD_LIST 30 #define PACKET_SIZE 2048 #define HEAD_SIZE (int)sizeof(Header) #define IP_SIZE 20 #define TEAM_SIZE 6 #define ITEM_OPTION_SIZE 5 #define SLOT_SIZE 4 #define BASE_CHARACTER_SIZE 1 #define BASE_INVEN_SIZE 20 #define BASE_SKILL_SIZE 8 #define ITEM1_MIX_SIZE 5 #define ITEM2_MIX_SIZE 5 #define CARD_MIX_SIZE 12 #define LIST5_SIZE 5 #define LIST6_SIZE 6 #define LIST8_SIZE 8 #define LIST10_SIZE 10 #define TEAM_SIZE 6 #define SHOP_BIT_EXIST 0 #define SHOP_BIT_NONE 1 #define ITEM_FACE 100 #define ITEM_HAIR 101 #define ITEM_SHIRTS 102 #define ITEM_PANTS 103 #define ITEM_GLOVE 104 #define ITEM_SHOES 105 #define ITEM_DIGIT 1000000 #define OPTION_DIGIT 100000 #define POSITION_NONE 0 #define POSITION_ALL 1 #define POSITION_FW 10 #define POSITION_ST 11 #define POSITION_CF 12 #define POSITION_WF 13 #define POSITION_SS 14 #define POSITION_FW_RANGE 4 #define POSITION_MF 20 #define POSITION_AM 21 #define POSITION_CM 22 #define POSITION_SM 23 #define POSITION_DM 24 #define POSITION_MF_RANGE 4 #define POSITION_DF 30 #define POSITION_SW 31 #define POSITION_CB 32 #define POSITION_SB 33 #define POSITION_DF_RANGE 3 #define POSITION_GK 40 #define POSITION_BG 50 #define AUTO_FACULTY_LEVEL1 10 #define AUTO_FACULTY_LEVEL2 20 #define MAX_AI_COSTUME 61 #define PC_EXIT01 1 #define PC_EXIT02 2 #define PC_EXIT03 3 #define PC_EXIT04 4 #define PC_EXIT11 11 #define PC_EXIT12 12 #define PC_EXIT20 20 #define PC_EXIT21 21 #define PC_EXIT22 22 #define PC_EXIT30 30 #define PC_EXIT31 31 #define PC_EXIT32 32 #define PC_EXIT33 33 #define PC_EXIT90 90 #define ROOT2 1.</description></item><item><title>pthread 使用入门</title><link>/language/clang/linux-c-pthread/</link><pubDate>Wed, 05 Feb 2020 17:15:38 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-c-pthread/</guid><description>POSIX 线程（POSIX threads），简称 Pthreads，是线程的 POSIX 标准。该标准定义了创建和操纵线程的一整套 API。在类 Unix 操作系统（Unix</description></item><item><title>linux fopen open</title><link>/language/clang/linux-fdopen-fileno/</link><pubDate>Thu, 19 Dec 2019 14:17:10 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-fdopen-fileno/</guid><description>每天进步一点点——Linux中的文件描述符与打开文件之间的关系_linux,文件描述符_Cynric 的博客-CSDN博客 1. 来源 从来源的角度看</description></item><item><title>linux mmap</title><link>/language/clang/linux-mmap/</link><pubDate>Thu, 19 Dec 2019 13:41:04 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-mmap/</guid><description>由于在应用层没法用writel，所以参考himm.c写了一个设置，代码如下： void uart1_rtsn_high(void) { void * pMem = NULL; pMem = memmap(0x201d0010, DEFAULT_MD_LEN); (U32)pMem = 0xff; } 文件名是rs485.c —————</description></item><item><title>linux fopen fwrite fflush fsync</title><link>/language/clang/linux-fopen-fwrite-fflush-fsync/</link><pubDate>Thu, 19 Dec 2019 11:28:34 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-fopen-fwrite-fflush-fsync/</guid><description>int readFileList(char *path) { DIR *dir = NULL; struct dirent *ptr = NULL; if ((dir = opendir(path)) == NULL) { fprintf(stderr, &amp;quot;Open dir error...\n&amp;quot;); return 1; } while ((ptr = readdir(dir)) != NULL) { if (ptr-&amp;gt;d_name[0] == &#39;.&#39;) // . .. .svn { continue; } else if (ptr-&amp;gt;d_type == DT_REG) // file { filter_elf(path, ptr-&amp;gt;d_name); } else if (ptr-&amp;gt;d_type == DT_LNK) // link file { //printf(&amp;quot;DT_LNK:%s/%s\n&amp;quot;, path, ptr-&amp;gt;d_name); } else</description></item><item><title>Linux下头文件以及库 编译链接运行时的搜寻路径顺序</title><link>/language/clang/make-gcc-include-order/</link><pubDate>Wed, 11 Dec 2019 11:17:08 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/make-gcc-include-order/</guid><description>Linux下头文件以及库 编译链接运行时的搜寻路径顺序 - ltshan139的专栏 LIBRARY_PATH 环境变量用于在程序编译期间查找动态链接库时指定查找共享库的路</description></item><item><title>clang define extern c</title><link>/language/clang/clang-define-extern-c/</link><pubDate>Wed, 11 Dec 2019 10:23:02 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/clang-define-extern-c/</guid><description>extern &amp;quot;C&amp;quot; 在C/C++中的用法 无论是C++调用C api 还是C调用C++ API， 必须先在API所对应得头文件对API进行 extern &amp;quot;C&amp;quot;声明</description></item><item><title>clang 3维数组的初始化</title><link>/language/clang/clang-array/</link><pubDate>Wed, 11 Dec 2019 10:20:42 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/clang-array/</guid><description>int a[2][3][4] = { {{1,2,3,4},{1,2,3,4},{1,2,3,4}}, {{5,6,7,8},{5,6,7,8},{5,6,7,8}} }; 注意初始化要先从最外围开始。</description></item><item><title>linux string strnicmp</title><link>/language/clang/linux-string-strnicmp/</link><pubDate>Thu, 28 Nov 2019 15:06:06 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-string-strnicmp/</guid><description>char pDescr[100] strcpy(pDescr, &amp;quot;v=0\r\n&amp;quot;); strcat(pDescr, &amp;quot;o=-&amp;quot;); strcat(pDescr, pSdpId); #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; void main() { char *input=&amp;quot;I am OldWolf&amp;quot;; char *str=&amp;quot;I am Oldwolf&amp;quot;; int cmp; printf(&amp;quot;原字符串分别为：\n%s\n%s\n\n&amp;quot;,str1,</description></item><item><title>linux string strsep</title><link>/language/clang/linux-string-strsep/</link><pubDate>Thu, 28 Nov 2019 14:40:23 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-string-strsep/</guid><description>C语言的 strtok 和 strsep 函数的使用 strsep()相比strtok()来说，它是可重入(reentrant)的（更安全），且速度更快。 /* lib/string.c */ strse</description></item><item><title>c http post file</title><link>/language/clang/c-http-post-file/</link><pubDate>Fri, 15 Nov 2019 17:20:47 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/c-http-post-file/</guid><description>基于C语言实现HTTP POST 表单形式上传文件 - fangye945a的博客 - CSDN博客 all: gcc -pthread -I. http_post.c clean: rm -f a.out POST /Server/interface_picture_upload.action?appid=wmj_BZ2WeU7K1iP&amp;amp;appsecret=MXkMcT43JsIgAwBwVJ30EbA2ovIcpfCQ&amp;amp;sn=0 HTTP/1.1 Host: test.inteink.com User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:59.0) Gecko/20100101 Firefox/59.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip,</description></item><item><title>gcc</title><link>/language/clang/gcc/</link><pubDate>Thu, 23 May 2019 10:58:04 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/gcc/</guid><description>linux ldconfig命令,环境变量文件配置详解 - winycg的博客 - CSDN博客 --start-group和--end-group 解决 ld 链接 error</description></item><item><title>c void</title><link>/language/clang/c-void/</link><pubDate>Wed, 22 May 2019 19:17:38 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/c-void/</guid><description>C语言中void和NULL - ascend的专栏 - CSDN博客 #define NULL ((void *)0) void的作用 a. 对函数参数的限定：当不需要传入参数时，即 function (void); b. 对函数返回</description></item><item><title>Linux内核中的offsetof和container_of</title><link>/language/clang/c-container_of/</link><pubDate>Sat, 20 Apr 2019 09:26:47 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/c-container_of/</guid><description>关于list_for_each_entry相关函数 - 简书 链表是内核最经典的数据结构之一，说到链表就不得不提及内核最经典 (没有之一) 的宏con</description></item><item><title>c位操作</title><link>/language/clang/c-bit-operate/</link><pubDate>Fri, 19 Apr 2019 16:29:17 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/c-bit-operate/</guid><description>bitops.h 位运算技巧 记得iOS总有一道面试题在不使用第三个变量的情况下交换两个变量的值，这里用到异或的上面加解密中的特性。我有x、y两个个变量，做如</description></item><item><title>c语言define的使用方法总结</title><link>/language/clang/c-define/</link><pubDate>Fri, 19 Apr 2019 11:13:07 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/c-define/</guid><description>#和##有什么区别？ 他们都不会将参数进行展开 1. # 的作用是将宏定义中的参数转换成“字符串” #define STR(x) #x =&amp;gt; a=1; STR(a) &amp;quot;a&amp;quot; 2. ##的作用是将宏定义中的参数变成字符</description></item><item><title>C语言中的指针</title><link>/language/clang/c-point/</link><pubDate>Sat, 13 Apr 2019 10:15:58 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/c-point/</guid><description>二级指针传参数 - 简书 说透一级指针和二级指以及(void)&amp;amp;在双链表中的应用 注意char*是字符串指针，需要改变其对应的变量必须用地址</description></item></channel></rss>
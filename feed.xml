<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>时光小栈 on 时光小栈</title><link>/</link><language>zh-CN</language><author>rinetd</author><rights>Copyright (c) 2015, rinetd; all rights reserved.</rights><updated>Tue, 20 Oct 2020 17:02:49 CST</updated><item><title>linux_c__attribute__pragma_pack</title><link>/language/clang/linux_c__attribute__pragma_pack/</link><pubDate>Tue, 20 Oct 2020 17:02:49 CST</pubDate><author>rinetd</author><guid>/language/clang/linux_c__attribute__pragma_pack/</guid><description>
&lt;h2 id=&#34;区别-pragma作用于结构内的成员变量-attribute-aligned-n-作用于结构体分配地址的对齐方式-和-结构体的大小&#34;&gt;【区别】 pragma作用于结构内的成员变量；attribute ((aligned(n)))作用于结构体分配地址的对齐方式 和 结构体的大小。&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;typedef struct Student_t
{
int age;
char c;
}__attribute__((aligned (64))) Student;
//影响结构体自身的对齐和大小，每个结构体单独占用64字节 ，不影响其中结构体中元素的对齐
typedef struct Node_t
{
int a;
char c;
} Node __attribute__((aligned(64)));
//只影响Node的对齐, 不影响Node的大小
//对于Node定义的数组，只影响整个数组的起始地址，不影响其中每个数组元素的对齐，每个变量还是占用8个字节，按8字节对齐，总占用内存是64的倍数。
typedef struct Node_p{
int a;
char c;
}__attribute__((packed)) Node_p ;
//影响结构中元素的对齐，通知编译器不做对齐处理等价于 #pragma pack(1)
#pragma pack(push)
#pragma pack(1)
typedef struct
{
int age;
char c;
}user;
#pragma pack(pop)
#pragma pack(push,2)
typedef struct List_t
{
int a;
char c;
}List;
#pragma pack(pop)
//push 和 pop成对出现 ，等价于 #pragma pack(2) 修改结构体中元素对齐规则
typedef int __attribute__((aligned(8))) myint;
// 只影响对齐不影响大小，整个数组按照起始地址8整数倍，数组大小是8的倍数 ，数组元素每个大小还是4
int main()
{
myint MYA[5],mya;
printf(&amp;quot;MYA:%p %p %d mya:%p %d\n&amp;quot;,&amp;amp;MYA[0],&amp;amp;MYA[4],sizeof(MYA),&amp;amp;mya,sizeof(mya));
Student C[5],c;
printf(&amp;quot;C:%p %p %d c:%p %d\n&amp;quot;,&amp;amp;C,&amp;amp;C[4],sizeof(C),&amp;amp;c,sizeof(c)) ;
Node_p cc;
printf(&amp;quot;***%p %p %d***\n&amp;quot;,&amp;amp;(cc.c),&amp;amp;(cc.a),sizeof(Node_p)) ;
Node A[5], a;
printf(&amp;quot;A:%p %p %d a:%p %d\n&amp;quot;,&amp;amp;A,&amp;amp;A[4],sizeof(A),&amp;amp;a,sizeof(a));
List B[5], b;
printf(&amp;quot;B:%p %p %d a:%p %d\n&amp;quot;,&amp;amp;B,&amp;amp;B[4],sizeof(B),&amp;amp;b,sizeof(b)) ;
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;p&gt;x86下，GCC默认按4字节对齐，它会在sex后面跟name后面分别填充三个和两个字节使length和整个结构体对齐。于是我们sizeof(my_stu)会得到长度为20，而不是15.&lt;br /&gt;
　　&lt;br /&gt;
　　四、attribute选项&lt;br /&gt;
　　&lt;br /&gt;
　　struct stu{&lt;br /&gt;
　　 char sex;&lt;br /&gt;
　　 int length;&lt;br /&gt;
　　 char name[10];&lt;br /&gt;
　　}attribute ((aligned (1)));&lt;br /&gt;
　　&lt;br /&gt;
　　struct stu my_stu;　&lt;br /&gt;
　　则sizeof(my_stu)可以得到大小为15。&lt;br /&gt;
　　&lt;br /&gt;
　　上面的定义等同于&lt;br /&gt;
　　struct stu{&lt;br /&gt;
　　 char sex;&lt;br /&gt;
　　 int length;&lt;br /&gt;
　　 char name[10];&lt;br /&gt;
　　}attribute ((packed));&lt;br /&gt;
　　struct stu my_stu;&lt;br /&gt;
　　&lt;br /&gt;
　 attribute((packed))得变量或者结构体成员使用最小的对齐方式，即对变量是一字节对齐，对域（field）是位对齐.&lt;br /&gt;
　　&lt;br /&gt;
　　五、什么时候需要设置对齐&lt;br /&gt;
　　&lt;br /&gt;
　　 在设计不同CPU下的通信协议时，或者编写硬件驱动程序时寄存器的结构这两个地方都需要按一字节对齐。即使看起来本来就自然对齐的也要使其对齐，以免不同的编译器生成的代码不一样.&lt;/p&gt;
&lt;p&gt;一、快速理解&lt;/p&gt;
&lt;p&gt;什么是字节对齐？&lt;br /&gt;
在C语言中，结构是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如数组、结构、联合等）的数据单元。在结构中，编译器为结构的每个成员按其自然边界（alignment）分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同。&lt;/p&gt;
&lt;p&gt;为了使CPU能够对变量进行快速的访问,变量的起始地址应该具有某些特性,即所谓的”对齐”. 比如4字节的int型,其起始地址应该位于4字节的边界上,即起始地址能够被4整除.&lt;/p&gt;
&lt;p&gt;字节对齐有什么作用？&lt;br /&gt;
字节对齐的作用不仅是便于cpu快速访问，同时合理的利用字节对齐可以有效地节省存储空间。&lt;/p&gt;
&lt;p&gt;对于32位机来说，4字节对齐能够使cpu访问速度提高，比如说一个long类型的变量，如果跨越了4字节边界存储，那么cpu要读取两次，这样效率就低了。但是在32位机中使用1字节或者2字节对齐，反而会使变量访问速度降低。所以这要考虑处理器类型，另外还得考虑编译器的类型。在vc中默认是4字节对齐的，GNU gcc 也是默认4字节对齐。&lt;/p&gt;
&lt;p&gt;更改C编译器的缺省字节对齐方式&lt;br /&gt;
在缺省情况下，C编译器为每一个变量或是数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对界条件：&lt;br /&gt;
· 使用伪指令#pragma pack (n)，C编译器将按照n个字节对齐。&lt;br /&gt;
· 使用伪指令#pragma pack ()，取消自定义字节对齐方式。&lt;/p&gt;
&lt;p&gt;另外，还有如下的一种方式：&lt;br /&gt;
· __attribute((aligned (n)))，让所作用的结构成员对齐在n字节自然边界上。如果结构中有成员的长度大于n，则按照最大成员的长度来对齐。&lt;br /&gt;
· attribute ((packed))，取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐。&lt;/p&gt;
&lt;p&gt;举例说明&lt;br /&gt;
struct test&lt;br /&gt;
{&lt;br /&gt;
char x1;&lt;br /&gt;
short x2;&lt;br /&gt;
float x3;&lt;br /&gt;
char x4;&lt;br /&gt;
};&lt;br /&gt;
译器默认情况下会对这个struct作自然边界（有人说“自然对界”我觉得边界更顺口）对齐，结构的第一个成员x1，其偏移地址为0，占据了第1个字节。第二个成员x2为short类型，其起始地址必须2字节对界，因此，编译器在x2和x1之间填充了一个空字节。结构的第三个成员x3和第四个成员x4恰好落在其自然边界地址上，在它们前面不需要额外的填充字节。在test结构中，成员x3要求4字节对界，是该结构所有成员中要求的最大边界单元，因而test结构的自然对界条件为4字节，编译器在成员x4后面填充了3个空字节。整个结构所占据空间为12字节。&lt;/p&gt;</description></item><item><title>libev_io_socket</title><link>/language/clang/libev/libev_io_socket/</link><pubDate>Mon, 19 Oct 2020 17:50:02 CST</pubDate><author>rinetd</author><guid>/language/clang/libev/libev_io_socket/</guid><description>&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/*
* @author :
* @date : 2014-09-04
* @desc : tiny socket server implemented by libev
* to use this, you should install libev at first.
*
* server: just run the program
* client: telnet localhost 8080
*
* @refer : 1). http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod
* 2). http://blog.csdn.net/lengzijian/article/details/8315133
*
*/
#include &amp;lt;ev.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#define PORT 8080
#define BUFFER_SIZE 1024
#define MAX_CONNECTIONS 10
struct ev_io *libevlist[MAX_CONNECTIONS] = {NULL};
void socket_accept_callback(struct ev_loop *loop, struct ev_io *watcher, int revents);
void socket_read_callback(struct ev_loop *loop, struct ev_io *watcher, int revents);
/*
Server Client
socket socket
| |
v v
bind connect
| |
v v
listen write
| |
v v
accept read
| |
v v
read close
|
v
write
|
v
close
*/
int main() {
struct ev_loop *loop = ev_default_loop(0);
/* socket start */
int sd;
struct sockaddr_in addr;
int addr_len = sizeof(addr);
struct ev_io *socket_watcher = (struct ev_io*)malloc(sizeof(struct ev_io));
struct ev_timer *timeout_watcher = (struct ev_timer*)malloc(sizeof(struct ev_timer));
// socket
sd = socket(PF_INET, SOCK_STREAM, 0);
if (sd &amp;lt; 0) {
printf(&amp;quot;socket error\n&amp;quot;);
return -1;
}
bzero(&amp;amp;addr, sizeof(addr));
addr.sin_family = AF_INET;
addr.sin_port = htons(PORT);
addr.sin_addr.s_addr = INADDR_ANY;
// bind
if (bind(sd, (struct sockaddr*) &amp;amp;addr, sizeof(addr)) != 0) {
printf(&amp;quot;bind error\n&amp;quot;);
return -1;
}
// listen
if (listen(sd, SOMAXCONN) &amp;lt; 0) {
printf(&amp;quot;listen error\n&amp;quot;);
return -1;
}
// set sd reuseful
int bReuseaddr = 1;
if (setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, (const char*) &amp;amp;bReuseaddr, sizeof(bReuseaddr)) != 0) {
printf(&amp;quot;setsockopt error in reuseaddr[%d]\n&amp;quot;, sd);
return -1;
}
/* socket end */
ev_io_init(socket_watcher, socket_accept_callback, sd, EV_READ);
ev_io_start(loop, socket_watcher);
while(1) {
ev_run(loop, 0);
}
return 1;
}
void socket_accept_callback(struct ev_loop *loop, struct ev_io *watcher, int revents) {
printf(&amp;quot;I am: %d\n&amp;quot;, getpid());
struct sockaddr_in client_addr;
socklen_t client_len = sizeof(client_addr);
int client_sd;
// ev_io watcher for client
struct ev_io *client_watcher = (struct ev_io*) malloc(sizeof(struct ev_io));
if (client_watcher == NULL) {
printf(&amp;quot;malloc error in accept_cb\n&amp;quot;);
return;
}
if (EV_ERROR &amp;amp; revents) {
printf(&amp;quot;error event in accept\n&amp;quot;);
return;
}
// socket accept: get file description
client_sd = accept(watcher-&amp;gt;fd, (struct sockaddr*) &amp;amp;client_addr, &amp;amp;client_len);
if (client_sd &amp;lt; 0) {
printf(&amp;quot;accept error\n&amp;quot;);
return;
}
// too much connections
if (client_sd &amp;gt; MAX_CONNECTIONS) {
printf(&amp;quot;fd too large[%d]\n&amp;quot;, client_sd);
close(client_sd);
return;
}
if (libevlist[client_sd] != NULL) {
printf(&amp;quot;client_sd not NULL fd is [%d]\n&amp;quot;, client_sd);
return;
}
printf(&amp;quot;client connected\n&amp;quot;);
// listen new client
ev_io_init(client_watcher, socket_read_callback, client_sd, EV_READ);
ev_io_start(loop, client_watcher);
libevlist[client_sd] = client_watcher;
}
void socket_read_callback(struct ev_loop *loop, struct ev_io *watcher, int revents) {
char buffer[BUFFER_SIZE];
ssize_t read;
if (EV_ERROR &amp;amp; revents) {
printf(&amp;quot;error event in read\n&amp;quot;);
return;
}
// socket recv
read = recv(watcher-&amp;gt;fd, buffer, BUFFER_SIZE, 0); // read stream to buffer
if (read &amp;lt; 0) {
printf(&amp;quot;read error\n&amp;quot;);
return;
}
if (read == 0) {
printf(&amp;quot;client disconnected.\n&amp;quot;);
if (libevlist[watcher-&amp;gt;fd] == NULL) {
printf(&amp;quot;the fd already freed[%d]\n&amp;quot;, watcher-&amp;gt;fd);
}
else {
close(watcher-&amp;gt;fd);
ev_io_stop(loop, libevlist[watcher-&amp;gt;fd]);
free(libevlist[watcher-&amp;gt;fd]);
libevlist[watcher-&amp;gt;fd] = NULL;
}
return;
}
else {
printf(&amp;quot;receive message:%s\n&amp;quot;, buffer);
}
// socket send to client
send(watcher-&amp;gt;fd, buffer, read, 0);
bzero(buffer, read);
}
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>libev</title><link>/language/clang/libev/libev/</link><pubDate>Mon, 19 Oct 2020 16:01:15 CST</pubDate><author>rinetd</author><guid>/language/clang/libev/libev/</guid><description>
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weiwangchao_/article/details/52961041&#34; target=&#34;_blank&#34;&gt;libev教程一：libev简单入门_把握自己。-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;libev是个非常优秀的基于事件的循环库，很多开源软件，比如nodejs就是使用其实现基础功能。本系列将对该库进行源码分析。&lt;a href=&#34;http://blog.csdn.net/breaksoftware/article/details/76066676&#34; target=&#34;_blank&#34;&gt;（转载请指明出于breaksoftware的csdn博客）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不知道是被墙了还是网站不再维护，它的官网（&lt;a href=&#34;http://libev.schmorp.de/）在国内已经没法访问了。&#34; target=&#34;_blank&#34;&gt;http://libev.schmorp.de/）在国内已经没法访问了。&lt;/a&gt;&lt;br /&gt;
但是我们仍然可以从github上下载其源码（&lt;a href=&#34;https://github.com/enki/libev）。&#34; target=&#34;_blank&#34;&gt;https://github.com/enki/libev）。&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;交叉编译&#34;&gt;交叉编译&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;./configure --host=arm-none-linux-gnueabi --prefix=&lt;/code&gt;pwd&lt;code&gt;/libev&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;./configure --host=arm-mac-linux-gnueabihf CC=arm-mac-linux-gnueabihf-gcc --prefix=&lt;/code&gt;pwd&lt;code&gt;/libev&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;使用样例&#34;&gt;使用样例&lt;/h2&gt;
&lt;p&gt;libev支持相对时间定时器、绝对时间定时器、文件状态监控和信号监控等功能。我们可以在它基础上，通过少量的代码实现稳健完善的功能。&lt;/p&gt;
&lt;p&gt;我们先看一段实现定时器功能的代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;ev.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
ev_timer timeout_watcher;
static void
timeout_cb(EV_P_ ev_timer *w, int revents)
{
puts(&amp;quot;timeout&amp;quot;);
ev_break(EV_A_ EVBREAK_ONE);
}
int main(void)
{
struct ev_loop *loop = EV_DEFAULT;
ev_timer_init(&amp;amp;timeout_watcher, timeout_cb, 5.5, 0);
ev_timer_start(loop, &amp;amp;timeout_watcher);
ev_run(loop, 0);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/unistd.h&amp;gt;
#include &amp;lt;ev.h&amp;gt;
void io_action(struct ev_loop *main_loop,ev_io *io_w,int e)
{
int rst;
char buf[1024];
memset(buf,0,sizeof(buf));
puts(&amp;quot;In IO action&amp;quot;);
read(STDIN_FILENO,buf,sizeof(buf));
buf[1023]=&#39;\0&#39;;
printf(&amp;quot;String: %s\n&amp;quot;,buf);
ev_io_stop(main_loop,io_w);
}
void timer_action(struct ev_loop *main_loop,ev_timer *time_w,int e)
{
puts(&amp;quot;In Time action&amp;quot;);
ev_timer_stop(main_loop,time_w);
}
void signal_action(struct ev_loop *main_loop,ev_signal *signal_w,int e)
{
puts(&amp;quot;In Signal action&amp;quot;);
ev_signal_stop(main_loop,signal_w);
ev_break(main_loop,EVBREAK_ALL);
}
int main(int argc,char **argv)
{
ev_io io_w;
ev_timer timer_w;
ev_signal signal_w;
struct ev_loop *main_loop = ev_default_loop(0);
ev_init(&amp;amp;io_w,io_action);
ev_io_set(&amp;amp;io_w,STDIN_FILENO,EV_READ);
ev_init(&amp;amp;timer_w,timer_action);
ev_timer_set(&amp;amp;timer_w,2,0);
ev_init(&amp;amp;signal_w,signal_action);
ev_signal_set(&amp;amp;signal_w,SIGINT);
ev_io_start(main_loop,&amp;amp;io_w);
ev_timer_start(main_loop,&amp;amp;timer_w);
ev_signal_start(main_loop,&amp;amp;signal_w);
ev_run(main_loop,0);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码的结构非常简单。首先我们要定义一个名为timeout_cb的回调函数用于响应定时器。然后定义一个ev_timer结构（监视器），它通过ev_timer_init进行初始化。初始化的参数包含之前定义的响应函数指针和迭代器超时时间。ev_timer准备好后，通过ev_timer_start将其和一个ev_loop进行绑定。最后使用ev_run方法运行起来这个ev_loop指针，从而实现一个完整的定时器功能。&lt;/p&gt;
&lt;p&gt;可见使用libev库非常方便。其实我们之后见到的其他用法和上面步骤是类似的，即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化ev_loop。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;定义监视器。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;定义回调函数。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;监视器和回调函数关联。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;监视器和ev_loop关联。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ev_run将ev_loop运行起来。&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假如上面代码是个框架使用的雏形，那么如果让我们去设计这样的框架，该如何设计呢？&lt;/p&gt;
&lt;h2 id=&#34;模型设计&#34;&gt;模型设计&lt;/h2&gt;
&lt;p&gt;首先我们需要考虑到的是使用sleep还是使用事件模型去实现逻辑等待。&lt;/p&gt;
&lt;p&gt;如果使用sleep方法，那么我们就要在唤醒后去检测各个事件，比如要检测文件状态是否发生变化，比如定时器时间是否已经超时。于是有个问题，就是sleep多久怎么确定？我们不知道是5秒后还是1秒后文件状态发生变化，那么只能最小粒度sleep了。那么这就意味着线程在短暂挂起后，马上检测一系列可能尚未发生改变的事件。这种设计明显很消耗CPU，而且非常低效。&lt;/p&gt;
&lt;p&gt;如果使用事件模型去等待，就可以解决上述问题。但是像定时器，在系统中并没有事件与其对应。于是我们需要考虑下对于没有事件对应的功能怎么通过事件模型去封装。&lt;/p&gt;
&lt;p&gt;其次我们需要考虑使用单线程模型还是多线程模型。&lt;/p&gt;
&lt;p&gt;单线程模型是让主流程和事件响应函数在一个线程中执行。其伪代码是&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;If (event is ready) {
event_callback(); // in the main thead
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其特点是实现简单，但是事件响应函数的效率将严重影响主流程对事件的响应速度。比如A、B两个事件同时发生，理论上我们希望两个事件的响应函数被同时执行，或者在允许存在的系统调用时间差（比如创建线程的消耗）内执行。然而单线程模型则会让一个响应函数执行完后再去执行另一响应函数，于是就出现排队现象。所以单线程模型无法保证及时响应。&lt;/p&gt;
&lt;p&gt;多线程模型则完全避免了上述问题。它可在事件发生后启动一个线程去处理响应函数。当然相对来说多线程模型比较复杂，需要考虑多线程同步问题。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;If (event is ready) {
thread_excute(event_callback); // run in another thread
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么libev对上面两个问题是怎么选择的呢？对于sleep和事件模型，libev选择的是后者，所以它是“高性能”的。对于单线程和多线程，libev选择的是前者。至于原因我并不知道，可能是作者希望它足够简单，或者希望它能在不支持多线程的系统上使用。但是要说明一点，并不是说libev不支持多线程。因为一个单线程模型的执行体，是可以放在其他若干个线程中执行的，只要保证数据同步。&lt;/p&gt;
&lt;h2 id=&#34;单-多线程编译&#34;&gt;单/多线程编译&lt;/h2&gt;
&lt;p&gt;libev提供了各种编译选项以支持各种特性。比如在支持多线程的系统上，我们可以指定EV_MULTIPLICITY参数，以让libev编译出多线程版本。&lt;/p&gt;
&lt;p&gt;libev对于单线程版本的数据都是以全局静态变量形式提供。而对于多线程版本，则提供了一个结构体——ev_loop保存数据，这样不同线程持有各自的数据对象，从而做到数据隔离。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#if EV_MULTIPLICITY
struct ev_loop
{
ev_tstamp ev_rt_now;
#define ev_rt_now ((loop)-&amp;gt;ev_rt_now)
#define VAR(name,decl) decl;
#include &amp;quot;ev_vars.h&amp;quot;
#undef VAR
};
#include &amp;quot;ev_wrap.h&amp;quot;
static struct ev_loop default_loop_struct;
EV_API_DECL struct ev_loop *ev_default_loop_ptr = 0; /* needs to be initialised to make it a definition despite extern */
#else
EV_API_DECL ev_tstamp ev_rt_now = 0; /* needs to be initialised to make it a definition despite extern */
#define VAR(name,decl) static decl;
#include &amp;quot;ev_vars.h&amp;quot;
#undef VAR
static int ev_default_loop_ptr;
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不管是哪个版本，它们都提供了ev_default_loop_ptr变量。多线程版本它将指向全局静态变量default_loop_struct，这样对于使用了多线程版本又不想维护ev_loop结构对象的用户来说，直接使用这个对象就行了，非常方便。&lt;/p&gt;
&lt;p&gt;然后再看下ev_vars.h的引入。其实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#define VARx(type,name)VAR(name, type name)
VARx(ev_tstamp, now_floor) /* last time we refreshed rt_time */
VARx(ev_tstamp, mn_now) /* monotonic clock &amp;quot;now&amp;quot; */
VARx(ev_tstamp, rtmn_diff) /* difference realtime - monotonic time */
/* for reverse feeding of events */
VARx(W *, rfeeds)
VARx(int, rfeedmax)
VARx(int, rfeedcnt)
VAR (pendings, ANPENDING *pendings [NUMPRI])
VAR (pendingmax, int pendingmax [NUMPRI])
VAR (pendingcnt, int pendingcnt [NUMPRI])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在多线程版本中，它在ev_loop结构体中被引入的。这样在编译器展开文件时，它将会被定义到结构体内部。在单线程版本中，VAR宏被声明为定义一个静态全局变量的形式。这种利用宏和编译展开技术，在不同结构中定义相同类型数据的方式还是很有意思的。&lt;/p&gt;
&lt;p&gt;但是又会有个问题，如何去访问这些变量呢？在单线程中，它们是静态变量，所有位置可以直接通过名称访问。而多线程版本中，则需要通过一个ev_loop结构体去引导。相关的代码总不能通过EV_MULTIPLICITY宏来区分不同变量形式吧？如果那样，代码将变得非常难看。我们看下libev怎么巧妙解决这个问题的。&lt;/p&gt;
&lt;p&gt;上面代码块的多线程定义区间，引入了ev_wrap.h文件。其实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#ifndef EV_WRAP_H
#define EV_WRAP_H
#define acquire_cb ((loop)-&amp;gt;acquire_cb)
#define activecnt ((loop)-&amp;gt;activecnt)
#define anfdmax ((loop)-&amp;gt;anfdmax)
#define anfds ((loop)-&amp;gt;anfds)
#define async_pending ((loop)-&amp;gt;async_pending)
#define asynccnt ((loop)-&amp;gt;asynccnt)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样使用一个和变量相同名称的宏替代了通过ev_loop结构体对象访问的变量。且这个宏名称和单线程版本中静态变量名相同。这样就让不同版本的关键变量“同名”了。于是代码对这些变量的访问直接使用其原始名称即可——单线程中使用的是真实变量名，多线程中使用的是宏。&lt;br /&gt;
这样的设计，又引入一个问题。那就是所有使用这些变量的函数，在多线程版本中，需要提供一个名字为loop的ev_loop结构体对象；而在单线程版本中则不需要。为了固化这个名称，libev还为此专门定义了一系列宏。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#if EV_MULTIPLICITY
struct ev_loop;
# define EV_P struct ev_loop *loop /* a loop as sole parameter in a declaration */
# define EV_P_ EV_P, /* a loop as first of multiple parameters */
# define EV_A loop /* a loop as sole argument to a function call */
# define EV_A_ EV_A, /* a loop as first of multiple arguments */
# define EV_DEFAULT_UC ev_default_loop_uc_ () /* the default loop, if initialised, as sole arg */
# define EV_DEFAULT_UC_ EV_DEFAULT_UC, /* the default loop as first of multiple arguments */
# define EV_DEFAULT ev_default_loop (0) /* the default loop as sole arg */
# define EV_DEFAULT_ EV_DEFAULT, /* the default loop as first of multiple arguments */
#else
# define EV_P void
# define EV_P_
# define EV_A
# define EV_A_
# define EV_DEFAULT
# define EV_DEFAULT_
# define EV_DEFAULT_UC
# define EV_DEFAULT_UC_
# undef EV_EMBED_ENABLE
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后我们在代码中导出可见的EV_P和EV_A就是为了保证不同版本的实现在代码层面是相同的。&lt;/p&gt;
&lt;h2 id=&#34;libev&#34;&gt;libev&lt;/h2&gt;
&lt;h3 id=&#34;1-1-introduction&#34;&gt;1.1 Introduction&lt;/h3&gt;
&lt;p&gt;主页&lt;a href=&#34;http://software.schmorp.de/pkg/libev.html&#34; target=&#34;_blank&#34;&gt;http://software.schmorp.de/pkg/libev.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;文档&lt;a href=&#34;http://software.schmorp.de/pkg/libev.html&#34; target=&#34;_blank&#34;&gt;http://software.schmorp.de/pkg/libev.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;libev所实现的功能就是一个强大的reactor,可能notify事件主要包括下面这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ev_io // IO可读可写&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ev_stat // 文件属性变化&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ev_async // 激活线程&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ev_signal // 信号处理&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ev_timer // 定时器&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ev_periodic // 周期任务&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ev_child // 子进程状态变化&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ev_fork // 开辟进程&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ev_cleanup // event loop退出触发事件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ev_idle // 每次event loop空闲触发事件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ev_embed // TODO(zhangyan04):I have no idea.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ev_prepare // 每次event loop之前事件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ev_check // 每次event loop之后事件&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-2-about-the-code&#34;&gt;1.2 About The Code&lt;/h3&gt;
&lt;p&gt;代码风格相当严谨而且排版也非常工整，并且从域名看出作者是德国人。但是内部使用了大量的宏造成阅读代码并不是非常方便。&lt;/p&gt;
&lt;p&gt;并且从代码角度分析，应该是一开始支持有一个默认的event_loop,但是随着多核产生实际应用中可能会使用到多个event_loop, 猜想作者应该是为了方便的话使用了很多宏进行替换。&lt;/p&gt;
&lt;p&gt;允许使用多个event_loop的宏是EV_MULTIPLICITY.&lt;/p&gt;
&lt;p&gt;比如下面这段代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void noinline
ev_io_start (EV_P_ ev_io *w)
{
int fd = w-&amp;gt;fd;
if (expect_false (ev_is_active (w)))
return;
assert ((&amp;quot;libev: ev_io_start called with negative fd&amp;quot;, fd &amp;gt;= 0));
assert ((&amp;quot;libev: ev_io_start called with illegal event mask&amp;quot;, !(w-&amp;gt;events &amp;amp; ~(EV__IOFDSET | EV_READ | EV_WRITE))));
EV_FREQUENT_CHECK;
ev_start (EV_A_ (W)w, 1);
array_needsize (ANFD, anfds, anfdmax, fd + 1, array_init_zero);
wlist_add (&amp;amp;anfds[fd].head, (WL)w);
fd_change (EV_A_ fd, w-&amp;gt;events &amp;amp; EV__IOFDSET | EV_ANFD_REIFY);
w-&amp;gt;events &amp;amp;= ~EV__IOFDSET;
EV_FREQUENT_CHECK;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初次阅读这个代码会觉得非常难懂。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;宏&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;定义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;EV_P&lt;/td&gt;
&lt;td&gt;event parameter&lt;/td&gt;
&lt;td&gt;struct ev_loop* loop&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EV&lt;em&gt;P&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;EV_P,&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EV_A&lt;/td&gt;
&lt;td&gt;event argument&lt;/td&gt;
&lt;td&gt;loop&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EV&lt;em&gt;A&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;EV_A,&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;然后很多变量只要是ev_loop成员的话都被封装成为了宏。比如代码里面的anfds,实际上的宏定义是&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#define anfds ((loop)-&amp;gt;anfds)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;事实上一个ev_loop里面的字段是相当多的，不过也很正常本身就是一个强大的reactor.但是这造成一个直接后果，就是对于想要了解ev_loop的全貌比较困难，所以想要彻底地了解libev也比较麻烦，所以我们只能够从应用层面来尝试了解它。&lt;/p&gt;
&lt;h3 id=&#34;1-3-eventloop&#34;&gt;1.3 EventLoop&lt;/h3&gt;
&lt;p&gt;首先我们关注一下reactor本身。在libev下面reactor对象称为event_loop.&lt;/p&gt;
&lt;p&gt;event_loop允许动态创建和销毁，并且允许绑定自定义数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct ev_loop * ev_loop_new (unsigned int flags);
void ev_loop_destroy (EV_P);
void ev_set_userdata (EV_P_ void *data);
void *ev_userdata (EV_P);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们这里主要关注一下flags.这里面主要是选择使用什么backend来进行poll操作，可以选择的有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EVBACKEND_SELECT&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;EVBACKEND_POLL&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;EVBACKEND_EPOLL // 通常我们选择这个&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;EVBACKEND_KQUEUE&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;EVBACKEND_DEVPOLL&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;EVBACKEND_PORT&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是还有三个比较重要选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EVFLAG_NOINOTIFY // 不适用inofity调用来使用ev_stat.这样可以减少fd使用。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;EVFLAG_SIGNALFD // 使用signalfd来检测信号是否发生，同样这样可以减少fd使用。&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大部分时候我们使用EVFLAG_AUTO(0)一般就足够满足需求了，从代码角度来看如果支持epoll的话那么首先会选择epoll. 因为在watcher的回调函数里面是可以知道当前event_loop的，这样就可以获得自定义数据。然后我们看看这个event_loop如何运行和停止的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void ev_run (EV_P_ int flags);
void ev_break (EV_P_ int how);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样我们这里比较关注flags和how这两个参数。flags有下面这几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0.通常这是我们想要的，每次轮询在poll都会等待一段时间然后处理pending事件。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;EVRUN_NOWAIT.运行一次，在poll时候不会等待。这样效果相当于只是处理pending事件。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;EVRUN_ONCE.运行一次，但是在poll时候会等待，然后处理pending事件。&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而how有下面这几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EVBREAK_ONE.只是退出一次ev_run这个调用。通常来说使用这个就可以了。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;EVBREAK_ALL.退出所有的ev_run调用。这种情况存在于ev_run在pengding处理时候会递归调用。&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在backend/epoll底层每次epoll_wait时候，libev提供了接口回调可以在epoll_wait前后调用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void ev_set_loop_release_cb (loop, void (*release)(EV_P), void (*acquire)(EV_P))
static void
epoll_poll (EV_P_ ev_tstamp timeout)
{
/* epoll wait times cannot be larger than (LONG_MAX - 999UL) / HZ msecs, which is below */
/* the default libev max wait time, however. */
EV_RELEASE_CB;
eventcnt = epoll_wait (backend_fd, epoll_events, epoll_eventmax,
epoll_epermcnt ? 0 : ev_timeout_to_ms (timeout));
EV_ACQUIRE_CB;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在event_loop里面我们还关心一件事情，就是每次event_loop轮询的时间长短。通常来说这个不会是太大问题，但是在高性能情况下面我们需要设置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void ev_set_io_collect_interval (EV_P_ ev_tstamp interval);
void ev_set_timeout_collect_interval (EV_P_ ev_tstamp interval);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在ev_run里面有使用这些参数的代码比较麻烦。但是大意是这样，如果我们这是了timeout_interval的话，那么我们每次检查timeout时间的话必须在timeout_interval，使用这段时间ev_sleep.但是这个又会影响到io_interval,所以内部做了一些换算，换算的结果作为epoll_wait超时时间。不过同样在大部分时候我们不需要关心它，默认时候是0.0,系统会使用最快的响应方式来处理。&lt;/p&gt;
&lt;h3 id=&#34;1-4-watcher&#34;&gt;1.4 Watcher&lt;/h3&gt;
&lt;p&gt;然后我们关心一下EventHandler.在libev下面watcher相当于EventHandler这么一个概念，通常里面会绑定fd回调函数以及我们需要关注的事件。然后一旦触发事件之后会触发我们使用的回调函数，回调函数参数通常有reactor,watcher以及触发的事件。这里不打算重复文档里面的watcher 相关的内容和对应的API,但是对于某些内容的话可能会提到并且附带一些注释。之前我们还是看看通用过程，这里使用TYPE区分不同类型watcher.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;typedef void (*)(struct ev_loop *loop, ev_TYPE *watcher, int revents) callback; // callback都是这种类型
ev_init (ev_TYPE *watcher, callback); // 初始化watcher
ev_TYPE_set (ev_TYPE *watcher, [args]); // 设置watcher
ev_TYPE_init (ev_TYPE *watcher, callback, [args]); // 通常使用这个函数最方便，初始化和设置都在这里
ev_TYPE_start (loop, ev_TYPE *watcher); // 注册watcher
ev_TYPE_stop (loop, ev_TYPE *watcher); // 注销watcher
ev_set_priority (ev_TYPE *watcher, int priority); // 设置优先级
ev_feed_event (loop, ev_TYPE *watcher, int revents); // 这个做跨线程通知非常有用，相当于触发了某个事件。
bool ev_is_active (ev_TYPE *watcher); // watcher是否active.
bool ev_is_pending (ev_TYPE *watcher); // watcher是否pending.
int ev_clear_pending (loop, ev_TYPE *watcher); // 清除watcher pending状态并且返回事件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;wacther的状态有下面这么几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;initialiased. 调用init函数初始化&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;active. 调用start进行注册&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;pending. 已经触发事件但是没有处理&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;inactive. 调用stop注销。这个状态等同于initialised这个状态。&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实关于每个watcher具体是怎么实现的没有太多意思，因为大部分现有代码都差不多。会在下一节说说内部数据结构是怎么安排的，了解内部数据结构以及过程之后很多问题就可以避免了，比如&amp;quot;The special problem of disappearing file descriptors&amp;quot;这类问题。&lt;/p&gt;
&lt;h3 id=&#34;1-5-how-it-works&#34;&gt;1.5 How it works&lt;/h3&gt;
&lt;h4 id=&#34;1-5-1-ev-run&#34;&gt;1.5.1 ev_run&lt;/h4&gt;
&lt;p&gt;最主要的还是看看ev_run这个部分代码。我们不打算仔细阅读只是看看梗概然后大体分析一下数据结构应该怎么样的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void
ev_run (EV_P_ int flags)
{
assert ((&amp;quot;libev: ev_loop recursion during release detected&amp;quot;, loop_done != EVBREAK_RECURSE));
loop_done = EVBREAK_CANCEL;
EV_INVOKE_PENDING; /* in case we recurse, ensure ordering stays nice and clean */
do
{
if (expect_false (loop_done))
break;
/* update fd-related kernel structures */
fd_reify (EV_A);
/* calculate blocking time */
{
ev_tstamp waittime = 0.;
ev_tstamp sleeptime = 0.;
/* remember old timestamp for io_blocktime calculation */
ev_tstamp prev_mn_now = mn_now;
/* update time to cancel out callback processing overhead */
time_update (EV_A_ 1e100);
if (expect_true (!(flags &amp;amp; EVRUN_NOWAIT || idleall || !activecnt)))
{
waittime = MAX_BLOCKTIME;
if (timercnt)
{
ev_tstamp to = ANHE_at (timers [HEAP0]) - mn_now + backend_fudge;
if (waittime &amp;gt; to) waittime = to;
}
/* don&#39;t let timeouts decrease the waittime below timeout_blocktime */
if (expect_false (waittime &amp;lt; timeout_blocktime))
waittime = timeout_blocktime;
/* extra check because io_blocktime is commonly 0 */
if (expect_false (io_blocktime))
{
sleeptime = io_blocktime - (mn_now - prev_mn_now);
if (sleeptime &amp;gt; waittime - backend_fudge)
sleeptime = waittime - backend_fudge;
if (expect_true (sleeptime &amp;gt; 0.))
{
ev_sleep (sleeptime);
waittime -= sleeptime;
}
}
}
assert ((loop_done = EVBREAK_RECURSE, 1)); /* assert for side effect */
backend_poll (EV_A_ waittime);
assert ((loop_done = EVBREAK_CANCEL, 1)); /* assert for side effect */
/* update ev_rt_now, do magic */
time_update (EV_A_ waittime + sleeptime);
}
/* queue pending timers and reschedule them */
timers_reify (EV_A); /* relative timers called last */
EV_INVOKE_PENDING;
}
while (expect_true (
activecnt
&amp;amp;&amp;amp; !loop_done
&amp;amp;&amp;amp; !(flags &amp;amp; (EVRUN_ONCE | EVRUN_NOWAIT))
));
if (loop_done == EVBREAK_ONE)
loop_done = EVBREAK_CANCEL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以总结一下大致步骤，其实和大部分的event loop写出来差不多。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先触发那些已经pending的watchers.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;判断是否loop_done&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;fd_reify.这个后面会单独说。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;计算出waittime并且进行必要的sleep.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;backend_poll开始轮询,并且整理好pending事件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;timers_reify.这个和fd_reify不同&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;调用EV_INVOKE_PENDING来触发pending的io事件&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;非常简单。接下来我们看看fd_reify,backend_poll,timers_reify以及EV_INVOKE_PENDING.&lt;/p&gt;
&lt;h4 id=&#34;1-5-2-fd-reify&#34;&gt;1.5.2 fd_reify&lt;/h4&gt;
&lt;p&gt;下面是fd_reify代码片段.可以看出，这个部分就是在修改fd关注的events。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;inline_size void
fd_reify (EV_P)
{
int i;
for (i = 0; i &amp;lt; fdchangecnt; ++i)
{
int fd = fdchanges [i];
ANFD *anfd = anfds + fd;
ev_io *w;
unsigned char o_events = anfd-&amp;gt;events;
unsigned char o_reify = anfd-&amp;gt;reify;
anfd-&amp;gt;reify = 0;
/*if (expect_true (o_reify &amp;amp; EV_ANFD_REIFY)) probably a deoptimisation */
{
anfd-&amp;gt;events = 0;
for (w = (ev_io *)anfd-&amp;gt;head; w; w = (ev_io *)((WL)w)-&amp;gt;next)
anfd-&amp;gt;events |= (unsigned char)w-&amp;gt;events;
if (o_events != anfd-&amp;gt;events)
o_reify = EV__IOFDSET; /* actually |= */
}
if (o_reify &amp;amp; EV__IOFDSET)
backend_modify (EV_A_ fd, o_events, anfd-&amp;gt;events);
}
fdchangecnt = 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而这个fdchanges这个是在哪里调用的呢。我们可以看到就是在ev_io_start这个部分。也就是说如果我们想要修改 fd关注事件的话，我们必须显示地ev_io_stop掉然后修正之后重新ev_io_start.底层调用fd_change的话底层维护数组fdchanges来保存发生events变动的fd.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void noinline
ev_io_start (EV_P_ ev_io *w)
{
int fd = w-&amp;gt;fd;
if (expect_false (ev_is_active (w)))
return;
assert ((&amp;quot;libev: ev_io_start called with negative fd&amp;quot;, fd &amp;gt;= 0));
assert ((&amp;quot;libev: ev_io_start called with illegal event mask&amp;quot;, !(w-&amp;gt;events &amp;amp; ~(EV__IOFDSET | EV_READ | EV_WRITE))));
EV_FREQUENT_CHECK;
ev_start (EV_A_ (W)w, 1);
array_needsize (ANFD, anfds, anfdmax, fd + 1, array_init_zero);
wlist_add (&amp;amp;anfds[fd].head, (WL)w);
fd_change (EV_A_ fd, w-&amp;gt;events &amp;amp; EV__IOFDSET | EV_ANFD_REIFY);
w-&amp;gt;events &amp;amp;= ~EV__IOFDSET;
EV_FREQUENT_CHECK;
}
inline_size void
fd_change (EV_P_ int fd, int flags)
{
unsigned char reify = anfds [fd].reify;
anfds [fd].reify |= flags;
if (expect_true (!reify))
{
++fdchangecnt;
array_needsize (int, fdchanges, fdchangemax, fdchangecnt, EMPTY2);
fdchanges [fdchangecnt - 1] = fd;
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;1-5-3-backend-poll&#34;&gt;1.5.3 backend_poll&lt;/h4&gt;
&lt;p&gt;backend_poll底层支持很多poll实现，我们这里仅仅看ev_epoll.c就可以.代码在这里面我们不列举了，如果某个fd触发事件的话那么最终会调用fd_event(EV&lt;em&gt;A&lt;/em&gt;,fd,event)来进行通知。所以我们看看fd_event.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;inline_speed void
fd_event_nocheck (EV_P_ int fd, int revents)
{
ANFD *anfd = anfds + fd;
ev_io *w;
for (w = (ev_io *)anfd-&amp;gt;head; w; w = (ev_io *)((WL)w)-&amp;gt;next)
{
int ev = w-&amp;gt;events &amp;amp; revents;
if (ev)
ev_feed_event (EV_A_ (W)w, ev);
}
}
void noinline
ev_feed_event (EV_P_ void *w, int revents)
{
W w_ = (W)w;
int pri = ABSPRI (w_);
if (expect_false (w_-&amp;gt;pending))
pendings [pri][w_-&amp;gt;pending - 1].events |= revents;
else
{
w_-&amp;gt;pending = ++pendingcnt [pri];
array_needsize (ANPENDING, pendings [pri], pendingmax [pri], w_-&amp;gt;pending, EMPTY2);
// set the watcher and revents.
pendings [pri][w_-&amp;gt;pending - 1].w = w_;
pendings [pri][w_-&amp;gt;pending - 1].events = revents;
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到底层是一个ANFD的数组，根据fd进行偏移。如果fd过大的话似乎会影响性能没有hpserver里面的demuxtable实现方式好。然后得到这个fd下面所有的watcher,然后在loop-&amp;gt;pendings里面记录所有这些触发的watcher.&lt;/p&gt;
&lt;h4 id=&#34;1-5-4-timers-reify&#34;&gt;1.5.4 timers_reify&lt;/h4&gt;
&lt;p&gt;其中HEAP0就是最小堆下标。如果repeat的话说明需要重复发生，那么就会重新调整时间戳，如果不是repeat的话，那么内部会调用ev_timer_stop这个方法将这个计时器移除。所有的定时任务都通过feed_reverse添加。feed_reverse 内部是维护一个动态数组来保存所有的定时器任务，然后在feed_reverse_done里面遍历这些任务来触发这些定时器任务。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;inline_size void
timers_reify (EV_P)
{
EV_FREQUENT_CHECK;
if (timercnt &amp;amp;&amp;amp; ANHE_at (timers [HEAP0]) &amp;lt; mn_now)
{
do
{
ev_timer *w = (ev_timer *)ANHE_w (timers [HEAP0]);
/*assert ((&amp;quot;libev: inactive timer on timer heap detected&amp;quot;, ev_is_active (w)));*/
/* first reschedule or stop timer */
if (w-&amp;gt;repeat)
{
ev_at (w) += w-&amp;gt;repeat;
if (ev_at (w) &amp;lt; mn_now)
ev_at (w) = mn_now;
assert ((&amp;quot;libev: negative ev_timer repeat value found while processing timers&amp;quot;, w-&amp;gt;repeat &amp;gt; 0.));
ANHE_at_cache (timers [HEAP0]);
downheap (timers, timercnt, HEAP0);
}
else
ev_timer_stop (EV_A_ w); /* nonrepeating: stop timer */
EV_FREQUENT_CHECK;
feed_reverse (EV_A_ (W)w);
}
while (timercnt &amp;amp;&amp;amp; ANHE_at (timers [HEAP0]) &amp;lt; mn_now);
feed_reverse_done (EV_A_ EV_TIMER);
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;1-5-5-ev-invoke-pending&#34;&gt;1.5.5 EV_INVOKE_PENDING&lt;/h4&gt;
&lt;p&gt;这个宏最终调用的函数就是下面这个，遍历所有的pendings事件并且逐一触发。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void noinline
```c++
ev_invoke_pending (EV_P)
{
int pri;
for (pri = NUMPRI; pri--; )
while (pendingcnt [pri])
{
ANPENDING *p = pendings [pri] + --pendingcnt [pri];
p-&amp;gt;w-&amp;gt;pending = 0;
EV_CB_INVOKE (p-&amp;gt;w, p-&amp;gt;events);
EV_FREQUENT_CHECK;
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;1-6-example&#34;&gt;1.6 Example&lt;/h3&gt;
&lt;p&gt;尝试编写一个简单的带有超时的echo-server和echo-client就发现其实还有非常多的其他的工作量，比如buffer的管理状态机实现等。所以我没有写出一个完整的example,只是简单地写了假设echo-client连接上server的话就简单地打印链接信息并且关闭。&lt;/p&gt;
&lt;h4 id=&#34;1-6-1-common-h&#34;&gt;1.6.1 common.h&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;\#ifndef _COMMON_H_
\#define _COMMON_H_
\#include &amp;lt;unistd.h&amp;gt;
\#include &amp;lt;fcntl.h&amp;gt;
\#include &amp;lt;sys/types.h&amp;gt;
\#include &amp;lt;sys/socket.h&amp;gt;
\#include &amp;lt;arpa/inet.h&amp;gt;
\#include &amp;lt;strings.h&amp;gt;
\#include &amp;lt;cstdlib&amp;gt;
\#include &amp;lt;cstdio&amp;gt;
\#include &amp;lt;cstddef&amp;gt;
\#include &amp;lt;string&amp;gt;
namespace common{
\#define D(exp,fmt,...) do {
\
if(!(exp)){
\
fprintf(stderr,fmt,\##__VA_ARGS__); \
abort(); \
} \
}while(0)
static void setnonblock(int fd){
fcntl(fd,F_SETFL,fcntl(fd,F_GETFL) | O_NONBLOCK);
}
static void setreuseaddr(int fd){
int ok=1;
setsockopt(fd,SOL_SOCKET,SO_REUSEADDR,&amp;amp;ok,sizeof(ok));
}
static void setaddress(const char* ip,int port,struct sockaddr_in* addr){
bzero(addr,sizeof(*addr));
addr-&amp;gt;sin_family=AF_INET;
inet_pton(AF_INET,ip,&amp;amp;(addr-&amp;gt;sin_addr));
addr-&amp;gt;sin_port=htons(port);
}
static std::string address_to_string(struct sockaddr_in* addr){
char ip[128];
inet_ntop(AF_INET,&amp;amp;(addr-&amp;gt;sin_addr),ip,sizeof(ip));
char port[32];
snprintf(port,sizeof(port),&amp;quot;%d&amp;quot;,ntohs(addr-&amp;gt;sin_port));
std::string r;
r=r+&amp;quot;(&amp;quot;+ip+&amp;quot;:&amp;quot;+port+&amp;quot;)&amp;quot;;
return r;
}
static int new_tcp_server(int port){
int fd=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
D(fd&amp;gt;0,&amp;quot;socket failed(%m)\n&amp;quot;);
setnonblock(fd);
setreuseaddr(fd);
sockaddr_in addr;
setaddress(&amp;quot;0.0.0.0&amp;quot;,port,&amp;amp;addr);
bind(fd,(struct sockaddr*)&amp;amp;addr,sizeof(addr));
listen(fd,64); // backlog = 64
return fd;
}
static int new_tcp_client(const char* ip,int port){
int fd=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
setnonblock(fd);
sockaddr_in addr;
setaddress(ip,port,&amp;amp;addr);
connect(fd,(struct sockaddr*)(&amp;amp;addr),sizeof(addr));
return fd;
}
}; // namespace common
\#endif // _COMMON_H_
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;1-6-2-echo-client-cc&#34;&gt;1.6.2 echo-client.cc&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;\#include &amp;quot;ev.h&amp;quot;
\#include &amp;quot;common.h&amp;quot;
static void do_connected(struct ev_loop* reactor,ev_io* w,int events){
close(w-&amp;gt;fd);
ev_break(reactor,EVBREAK_ALL);
}
int main(){
struct ev_loop* reactor=ev_loop_new(EVFLAG_AUTO);
int fd=common::new_tcp_client(&amp;quot;127.0.0.1&amp;quot;,34567);
ev_io io;
ev_io_init(&amp;amp;io,&amp;amp;do_connected,fd,EV_WRITE);
ev_io_start(reactor,&amp;amp;io);
ev_run(reactor,0);
close(fd);
ev_loop_destroy(reactor);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;1-6-3-echo-server-cc&#34;&gt;1.6.3 echo-server.cc&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;\#include &amp;quot;ev.h&amp;quot;
\#include &amp;quot;common.h&amp;quot;
static void do_accept(struct ev_loop* reactor,ev_io* w,int events){
struct sockaddr_in addr;
socklen_t addr_size=sizeof(addr);
int conn=accept(w-&amp;gt;fd,(struct sockaddr*)&amp;amp;addr,&amp;amp;addr_size);
std::string r=common::address_to_string(&amp;amp;addr);
fprintf(stderr,&amp;quot;accept %s\n&amp;quot;,r.c_str());
close(conn);
}
int main(){
struct ev_loop* reactor=ev_loop_new(EVFLAG_AUTO);
int fd=common::new_tcp_server(34567);
ev_io w;
ev_io_init(&amp;amp;w,do_accept,fd,EV_READ);
ev_io_start(reactor,&amp;amp;w);
ev_run(reactor,0);
close(fd);
ev_loop_destroy(reactor);
}
http://wangjunle23.blog.163.com/blog/static/11783817120124308920321/
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>linux socket keepalive</title><link>/language/clang/socket/linux-socket-keepalive/</link><pubDate>Fri, 09 Oct 2020 15:03:47 CST</pubDate><author>rinetd</author><guid>/language/clang/socket/linux-socket-keepalive/</guid><description>&lt;p&gt;// int keepalive = 1; // 开启keepalive属性&lt;br /&gt;
// int keepidle = 60; // 如该连接在60秒内没有任何数据往来,则进行探测&lt;br /&gt;
// int keepinterval = 5; // 探测时发包的时间间隔为5 秒&lt;br /&gt;
// int keepcount = 3; // 探测尝试的次数.如果第1次探测包就收到响应了,则后2次的不再发.&lt;/p&gt;
&lt;p&gt;// setsockopt(rs, SOL_SOCKET, SO_KEEPALIVE, (void &lt;em&gt;)&amp;amp;keepalive , sizeof(keepalive ));&lt;br /&gt;
// setsockopt(rs, SOL_TCP, TCP_KEEPIDLE, (void&lt;/em&gt;)&amp;amp;keepidle , sizeof(keepidle ));&lt;br /&gt;
// setsockopt(rs, SOL_TCP, TCP_KEEPINTVL, (void *)&amp;amp;keepinterval , sizeof(keepinterval ));&lt;br /&gt;
// setsockopt(rs, SOL_TCP, TCP_KEEPCNT, (void *)&amp;amp;keepcount , sizeof(keepcount ));&lt;/p&gt;</description></item><item><title>linux clib gear lib</title><link>/language/clang/linux-clib-gear-lib/</link><pubDate>Wed, 07 Oct 2020 15:57:45 CST</pubDate><author>rinetd</author><guid>/language/clang/linux-clib-gear-lib/</guid><description>
&lt;h2 id=&#34;macos-下的交叉编译&#34;&gt;Macos 下的交叉编译&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;修改 build的目录下的&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;修改Makefile&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;# ARCH ?= linux
CROSS_PREFIX ?=arm-none-linux-gnueabi-
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;###&lt;/p&gt;</description></item><item><title>hafun 4g hefangyuan socket</title><link>/hardware/hafun-4g-hefangyuan-socket/</link><pubDate>Wed, 30 Sep 2020 10:29:07 CST</pubDate><author>rinetd</author><guid>/hardware/hafun-4g-hefangyuan-socket/</guid><description>
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;typedef enum
{
SOCK_ERR_EAI = -9,
SOCK_INVAL_PARA = -8,
SOCK_ERROR = -7,
SOCK_PEER_NOT_REACHABLE = -6, // 连接失败，连接不可达
SOCK_PEER_NO_RESPONSE = -5,
SOCK_CNT_RESET_BY_PEER = -4, // disconnect 断开连接
SOCK_UNKNOWN_APP = -3,
SOCK_BUSY = -2,
SOCK_NO_MEMORY = -1,
SOCK_SUCCESS = 0, // connect 连接成功
SOCK_ERR_CONN_PENDING = 1,
} sock_result_enum;
static uint8 g_conn_id = 1;
int _on_connect(sock_result_enum result)
{
// 创建和断开连接的时候都会回调这个函数，根据不同的网络状态，result的值不同
// 一般在开始创建网络的时候，这时候网络还不通，result=-6 ，当创建网络成功后 result=0 ，当网络断开时 result=-4
// SOCK_PEER_NOT_REACHABLE = -6, // 连接失败，连接不可达
// SOCK_CNT_RESET_BY_PEER = -4, // disconnect 断开连接
// SOCK_SUCCESS = 0, // connect 连接成功
printf(&amp;quot;%s %d \n&amp;quot;,__func__,result);
return SOCK_SUCCESS;
}
int _on_recv(const uint8 *data, int len)
{
printf(&amp;quot;%s %s %d\n&amp;quot;,__func__,data,len);
SIO_WRITE_ATCORE(data,len,1);
return SOCK_SUCCESS;
}
int _on_send(sock_result_enum result, int len)
{
printf(&amp;quot;%s %d %d \n&amp;quot;,__func__,result,len);
return SOCK_SUCCESS;
}
int _on_close(sock_result_enum result)
{
printf(&amp;quot;%s %d\n&amp;quot;,__func__,result);
return SOCK_SUCCESS;
}
int _send_keepalive_probe(uint8 idx)
{
// idx 返回的是连接号
struct timespec sys_time = {0, 0};
clock_gettime(CLOCK_REALTIME, &amp;amp;sys_time);
// g_sys_second = sys_time.tv_sec;
uint8 * data = (uint8*)&amp;quot;ping\n&amp;quot;;
sock_cont_put_tail(idx,data,strlen((char *)data));
printf(&amp;quot;%s %d %d\n&amp;quot;,__func__,idx,sys_time.tv_sec);
return SOCK_SUCCESS;
}
// static int _cam_send_keepalive_probe(uint8 idx)
// {
// if (m_sock_cb_cam.conn_id != idx)
// return SOCK_ERROR;
// _cam_sock_send_resp(CS_CODE_SUCCESS, CAM_SOCK_CMD_KEEPALIVE_REQ, NULL, 0);
// return SOCK_SUCCESS;
// }
static sock_event_callback_struct m_socket_event_cb = {
_on_connect, _on_recv, _on_send, _on_close, _send_keepalive_probe};
void socket_callback_init()
{
m_socket_event_cb.conn_id = g_conn_id;
int id = sock_cont_init(
g_conn_id,
SOCK_TCP,
&amp;quot;47.104.136.74&amp;quot;,
4000, // 端口
1, // keepalive 是否保持长链接
1, // AT命令调用1,还是函数调用0, 当参数为1 时从AT指令中可以查看其状态。
&amp;amp;m_socket_event_cb);
char data[100];
sprintf(data,&amp;quot;tcp sock_cont_init:%d\n&amp;quot;, id);
SIO_WRITE_ATCORE(data,100,1);
}
int get_socket_id()
{
return g_conn_id;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;当不使用-keepalive-错误-soc-ignore-pack-for-invalid-connect&#34;&gt;当不使用 keepalive 错误【SOC: Ignore pack for invalid connect】&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;当不使用 keepalive时 可能因为网络的问题连接创建失败，这是要自己去创建连接
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;1-connect-fail&#34;&gt;1,CONNECT FAIL&lt;/h3&gt;
&lt;p&gt;如何配置 自动重连的时间？&lt;br /&gt;
配置重连间隔参数：&lt;br /&gt;
设置命令 AT+CIPRECONN=&lt;reboot_timeout&gt;,&lt;wait_time&gt;&lt;br /&gt;
&lt;reboot_timeout&gt; 0,1,2 断线重连间隔次数&lt;br /&gt;
&lt;wait_time&gt; [0],0-3600000单位：秒 等待间隔时间再发起重连&lt;/p&gt;
&lt;h3 id=&#34;休眠-多次释放休眠锁&#34;&gt;【休眠】 多次释放休眠锁&lt;/h3&gt;
&lt;p&gt;int m_sleep_handler 是个文件描述符， 所以多次执行 acquire release 都没关系，以最后一次为准&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; // 1. 获取休眠锁，防止系统进入休眠
sleep_acquire(m_sleep_handler);
// 3. 释放休眠锁
sleep_release(m_sleep_handler);
sleep_release(m_sleep_handler);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A: 多次释放休眠锁，不影响系统运行&lt;/p&gt;
&lt;p&gt;B: 不释放休眠锁，等待强制休眠&lt;/p&gt;</description></item><item><title>linux clock_settime</title><link>/language/clang/linux-clock_settime/</link><pubDate>Sun, 27 Sep 2020 17:40:07 CST</pubDate><author>rinetd</author><guid>/language/clang/linux-clock_settime/</guid><description>
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;time.h&amp;gt;
int main ()
{
// 获取时间戳
time_t seconds = time(NULL); //The function time(NULL) returns the time since the Epoch (00:00:00 UTC, January 1, 1970), measured in seconds.
sprintf(timestamp, &amp;quot;%-llu&amp;quot;, (unsigned long long int)seconds);
time_t start_t, end_t;
double diff_t;
printf(&amp;quot;程序启动...\n&amp;quot;);
time(&amp;amp;start_t);
printf(&amp;quot;休眠 5 秒...\n&amp;quot;);
sleep(5);
time(&amp;amp;end_t);
diff_t = difftime(end_t, start_t);
printf(&amp;quot;执行时间 = %f\n&amp;quot;, diff_t);
printf(&amp;quot;程序退出...\n&amp;quot;);
return(0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;方法一-long-clock&#34;&gt;方法一： long clock&lt;/h3&gt;
&lt;p&gt;#include&lt;time.h&gt;&lt;br /&gt;
clock_t start = clock();&lt;br /&gt;
需要计时的代码段&lt;br /&gt;
clock_t end = clock();&lt;br /&gt;
运行时间t ＝ end - start; (单位ms)&lt;/p&gt;
&lt;p&gt;本方法有一定缺陷，在32bit机器上，运行时间较长达到（超过1小时），有可能出现计时错误。&lt;br /&gt;
clock()文档说明如下：&lt;br /&gt;
Note that the time can wrap around. On a 32-bit system where CLOCKS_PER_SEC equals 1000000 this function will return the same value approximately every 72 minutes.&lt;/p&gt;
&lt;p&gt;因此，当出现计时为负数或者很小的数时，需要人为凭经验加上若干个72minutes。。。&lt;/p&gt;
&lt;h3 id=&#34;方法二-timeval-gettimeofday&#34;&gt;方法二： timeval gettimeofday&lt;/h3&gt;
&lt;p&gt;显然方法一有一定局限性，方法二解决了长时间计时的问题。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;time.h&amp;gt;
timeval start, end;
gettimeofday(&amp;amp;start, null);
&amp;lt;!-- 需要计时的代码段 --&amp;gt;
gettimeofday(&amp;amp;end, null);
diffTime(start,end) * 0.001
struct timeval tv_begin;
struct timeval tv_end;
int passed_milliseconds;
gettimeofday (&amp;amp;tv_begin, NULL);
temp = quickSort (temp);
gettimeofday (&amp;amp;tv_end, NULL);
passed_milliseconds = (tv_end.tv_sec - tv_begin.tv_sec) * 1000 + (tv_end.tv_usec - tv_begin.tv_usec) / 1000;
printf(&amp;quot;master_load_file %.3f s \n&amp;quot;, diffTime(start,end) * 0.001 );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行时间 t ＝ 1000*(end.tv_sec - start.tv_sec) + (end.tv_usec - start.tv_usec)/1000; （单位ms）&lt;/p&gt;
&lt;h4 id=&#34;时间函数介绍&#34;&gt;时间函数介绍&lt;/h4&gt;
&lt;p&gt;Linux c/c++中提供了很多操作时间的库函数，这里简要介绍。&lt;/p&gt;
&lt;p&gt;常用的时间函数包括以下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;time()&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原型：&lt;code&gt;#include &amp;lt;time.h&amp;gt;&lt;/code&gt; &lt;code&gt;time_t time(time_t *t);&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;返回从公元1970-1-1 0:0:0的UTC时间到现在所经过的秒数&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果t 并非空指针的话，此函数也会将返回值存到t指针所指的内存&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;成功则返回秒数，失败则返回((time_t)-1)值，错误原因存于errno中&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;用time()函数结合其他函数（如：localtime、gmtime、asctime、ctime）可以获得当前系统时间或是标准时间。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果需要更高的时间精确度，就需要struct timespec 和 struct timeval来处理：&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;localtime_r()&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原型：&lt;code&gt;struct tm *localtime_r(const time_t * t);&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;将参数timep所指的time_t结构中的信息转换成真实世界所使用的时间日期表示方法，然后将结果由结构tm返回&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;成功则返回0，失败返回－1，错误代码存于errno&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;结构tm的定义如下，此函数返回的时间日期已经转换成当地时区&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct tm {
int tm_sec;
int tm_min;
int tm_hour;
int tm_mday;
int tm_mon;
int tm_year;
int tm_wday;
int tm_yday;
int tm_isdst;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;gettimeofday&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;原型：&lt;code&gt;int gettimeofday ( struct timeval * tv , struct timezone * tz )&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;把目前的时间由tv所指的结构返回，当地时区的信息则放到tz所指的结构中&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;timeval结构定义为：&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct timeval {
long tv_sec; /*秒*/
long tv_usec; /*微秒*/
};
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;timezone 结构定义为:&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct timezone {
int tz_minuteswest; /*和Greenwich 时间差了多少分钟*/
int tz_dsttime; /*日光节约时间的状态*/
};
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;clock_settime&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;系统调用可以设置系统时间秒数与纳秒数。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;返回值。0成功，-1失败&lt;br /&gt;
```cpp&lt;br /&gt;
#include &lt;time.h&gt;&lt;br /&gt;
int clock_settime(clockid_t clk_id, const struct timespec *tp);&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;clockid_t clk_id 用于指定计时时钟的类型，有以下4种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; CLOCK_REALTIME:系统实时时间,随系统实时时间改变而改变,即从UTC1970-1-1 0:0:0开始计时,中间时刻如果系统时间被用户该成其他,则对应的时间相应改变
CLOCK_MONOTONIC:从系统启动这一刻起开始计时,不受系统时间被用户改变的影响
CLOCK_PROCESS_CPUTIME_ID:本进程到当前代码系统CPU花费的时间
CLOCK_THREAD_CPUTIME_ID:本线程到当前代码系统CPU花费的时间
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;struct timespec *tp 用来存储当前的时间，其结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct timespec
{
time_t tv_sec; /* seconds */
long tv_nsec; /* nanoseconds */
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ctime&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原型：&lt;code&gt;char *ctime(const time_t *timep);&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;将参数timep所指的time_t结构中的信息转换成真实世界所使用的时间日期表示方法，然后将结果以字符串形态返回&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;此函数已经由时区转换成当地时间，字符串格式为&lt;code&gt;Wed Jun 30 21 :49 :08 1993&lt;/code&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;asctime&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原型：&lt;code&gt;char * asctime(const struct tm * timeptr);&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;将参数timeptr所指的tm结构中的信息转换成真实世界所使用的时间日期表示方法，然后将结果以字符串形态返回&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;此函数已经由时区转换成当地时间，字符串格式为: &lt;code&gt;Wed Jun 30 21:49:08 1993\n&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;若再调用相关的时间日期函数，此字符串可能会被破坏。此函数与ctime不同处在于传入的参数是不同的结构&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;gmtime&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原型：&lt;code&gt;struct tm* gmtime(const time_t*timep);&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;将参数timep 所指的time_t 结构中的信息转换成真实世界所使用的时间日期表示方法，然后将结果由结构tm返回&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;settimeofday&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原型：&lt;code&gt;int settimeofday ( const struct timeval *tv,const struct timezone *tz);&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;把目前时间设成由tv所指的结构信息，当地时区信息则设成tz所指的结构&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;注意，只有root权限才能使用此函数修改时间&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多详细信息请使用man手册。&lt;/p&gt;
&lt;p&gt;string &amp;lt;-------- asctime() &amp;lt;------ struct tm&lt;br /&gt;
string &amp;lt;-------- ctime() &amp;lt;--------- time_t&lt;/p&gt;
&lt;p&gt;formatted string &amp;lt;----- strftime() &amp;lt;----- struct tm&lt;/p&gt;
&lt;p&gt;struct tm &amp;lt;------- gmtime() / localtime &amp;lt;--- time_t&lt;/p&gt;
&lt;h4 id=&#34;获取精确到毫秒的时间&#34;&gt;获取精确到毫秒的时间&lt;/h4&gt;
&lt;hr /&gt;
&lt;p&gt;可以结合&lt;code&gt;time, localtime, strftime&lt;/code&gt;得到本地时间，精确到秒。代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;static string CurrentLocalTime(void)
{
time_t t; //秒时间
tm *local; //本地时间
char buf[128] = {0};
t = time(NULL); //获取目前秒时间
local = localtime(&amp;amp;t); //转为本地时间，注意，该函数非线程安全，下面的例子会使用线程安全函数localtime_r
strftime(buf, 64, &amp;quot;%Y-%m-%d %H:%M:%S&amp;quot;, local); //根据需要自定义格式
return buf;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要想得到精确到毫秒的时间，就需要使用&lt;code&gt;gettimeofday&lt;/code&gt;了。代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
* @name: GetLocalTimeWithMs
* @msg: 获取本地时间，精确到毫秒
* @param {type}
* @return: string字符串，格式为YYYYMMDDHHMMSSsss，如：20190710130510368
*/
static string GetLocalTimeWithMs(void)
{
string defaultTime = &amp;quot;19700101000000000&amp;quot;;
try
{
struct timeval curTime;
gettimeofday(&amp;amp;curTime, NULL);
int milli = curTime.tv_usec / 1000;
char buffer[80] = {0};
struct tm nowTime;
localtime_r(&amp;amp;curTime.tv_sec, &amp;amp;nowTime);//把得到的值存入临时分配的内存中，线程安全
strftime(buffer, sizeof(buffer), &amp;quot;%Y%m%d%H%M%S&amp;quot;, &amp;amp;nowTime);
char currentTime[84] = {0};
snprintf(currentTime, sizeof(currentTime), &amp;quot;%s%03d&amp;quot;, buffer, milli);
return currentTime;
}
catch(const std::exception&amp;amp; e)
{
return defaultTime;
}
catch (...)
{
return defaultTime;
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到字符串表示的本地时间信息后，可根据需要对字符串进行操作，简单方便。&lt;/p&gt;
&lt;p&gt;本地时间的获取在各种程序中使用率较高，可以放在项目的util中，供所有代码使用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void test_clock_settime()
{
int rc;
struct timespec tp, request = { 1, 0 }, remain;
rc = clock_gettime(CLOCK_REALTIME, &amp;amp;tp);
assert(rc == 0);
printf(&amp;quot;[%10&amp;quot;PRId64&amp;quot;.%09d] clock_gettime (CLOCK_REALTIME)\n&amp;quot;, (__int64) tp.tv_sec, (int) tp.tv_nsec);
rc = clock_settime(CLOCK_MONOTONIC, &amp;amp;tp);
assert(rc == -1 &amp;amp;&amp;amp; (errno == EINVAL));
rc = clock_settime(CLOCK_PROCESS_CPUTIME_ID, &amp;amp;tp);
assert(rc == -1 &amp;amp;&amp;amp; (errno == EINVAL));
rc = clock_settime(CLOCK_THREAD_CPUTIME_ID, &amp;amp;tp);
assert(rc == -1 &amp;amp;&amp;amp; (errno == EINVAL));
rc = clock_settime(CLOCK_REALTIME, &amp;amp;tp);
assert(rc == 0 || (errno == EPERM));
rc = clock_gettime(CLOCK_REALTIME, &amp;amp;tp);
assert(rc == 0);
printf(&amp;quot;[%10&amp;quot;PRId64&amp;quot;.%09d] clock_gettime (CLOCK_REALTIME)\n&amp;quot;, (__int64) tp.tv_sec, (int) tp.tv_nsec);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;time.h&amp;gt;
#include &amp;lt;stdint.h&amp;gt;
#include &amp;lt;error.h&amp;gt;
int main()
{
struct timespec tpset, tsreset;
if (clock_gettime(CLOCK_REALTIME, &amp;amp;tsreset) != 0) {
perror(&amp;quot;clock_gettime() did not return success\n&amp;quot;);
}
tpset.tv_sec = 0;
tpset.tv_nsec = 0;
clock_settime(CLOCK_REALTIME, &amp;amp;tpset);
perror(&amp;quot;clock_settime&amp;quot;);
}
// 直接的结果会在调用clock_settime的时候提示非法参数，原因如下：
// clock_settime-&amp;gt;kc-&amp;gt;clock_set(which_clock, &amp;amp;new_tp)-&amp;gt;posix_clock_realtime_set-&amp;gt;do_sys_settimeofday-&amp;gt;do_sys_settimeofday64-&amp;gt;do_settimeofday64
int do_settimeofday64(const struct timespec64 *ts)
{
struct timekeeper *tk = &amp;amp;tk_core.timekeeper;
struct timespec64 ts_delta, xt;
unsigned long flags;
int ret = 0;
if (!timespec64_valid_strict(ts))
return -EINVAL;
raw_spin_lock_irqsave(&amp;amp;timekeeper_lock, flags);
write_seqcount_begin(&amp;amp;tk_core.seq);
timekeeping_forward_now(tk);
xt = tk_xtime(tk);
ts_delta.tv_sec = ts-&amp;gt;tv_sec - xt.tv_sec;
ts_delta.tv_nsec = ts-&amp;gt;tv_nsec - xt.tv_nsec;
// 这里就换返回failed，从这里看到调用clock_settime 是设置和当前时间的差值，像上面的case，如果tpset.tv_sec = 0 和 tpset.tv_nsec = 0 都是零的话，这个差值会非常大，例如：clock_gettime(CLOCK_REALTIME, {1498723813, 202715700})
//因此在调用timespec64_compare时候就提示failed
if (timespec64_compare(&amp;amp;tk-&amp;gt;wall_to_monotonic, &amp;amp;ts_delta) &amp;gt; 0) {
ret = -EINVAL;
goto out;
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#define _XOPEN_SOURCE
#define _POSIX_C_SOURCE 199309L
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;linux/rtc.h&amp;gt;
#include &amp;lt;sys/ioctl.h&amp;gt;
#include &amp;lt;time.h&amp;gt;
#include &amp;lt;sys/time.h&amp;gt;
/*
time_t : type long int ,用来存储从1970到现在过了多少秒；
更精确一点，可以使用 struct timeval
struct timeval{
long tv_sec; //秒
long tv_usec; //微秒
}
struct timeval有两个成员，一个是秒，一个是微秒, 所以最高精确度是微秒。
一般由函数int gettimeofday(struct timeval *tv, struct timezone *tz)获取系统的时间
struct timespec {
time_t tv_sec; // seconds
long tv_nsec; // and nanoseconds
};
struct timespec有两个成员，一个是秒，一个是纳秒, 所以最高精确度是纳秒。
eg:
struct timespec ts;
clock_gettime(CLOCK_MONOTONIC,&amp;amp;ts);
CLOCK_REALTIME 统当前时间，从1970年1.1日算起
CLOCK_MONOTONIC 系统的启动时间，不能被设置
CLOCK_PROCESS_CPUTIME_ID 本进程运行时间
CLOCK_THREAD_CPUTIME_ID 本线程运行时间
*/
/*
int clock_gettime(clockid_t clk_id, struct timespec *tp);
Return 0 on success, or –1 on error
clock_gettime ——&amp;gt;struct timespec s ——&amp;gt; struct tm ——&amp;gt;format string
*/
void nowtime_ns()
{
struct timespec ts;
struct tm tm_time;
time_t t;
printf(&amp;quot;---------------------------struct timespec---------------------------------------\n&amp;quot;);
printf(&amp;quot;[time(NULL)] : %ld\n&amp;quot;, time(NULL));
if(clock_gettime(CLOCK_MONOTONIC,&amp;amp;ts)&amp;lt;0)
{
printf(&amp;quot;clock_gettime failed \n&amp;quot;);
perror(&amp;quot;clock_gettime&amp;quot;);
return;
}
printf(&amp;quot;clock_gettime : tv_sec=%ld, tv_nsec=%ld\n&amp;quot;, ts.tv_sec, ts.tv_nsec);
localtime_r(&amp;amp;(ts.tv_sec),&amp;amp;tm_time);
char date_time[50]={0};
strftime(date_time,sizeof(date_time),&amp;quot;%Y-%m-%d %H:%M:%S&amp;quot;,&amp;amp;tm_time);
printf(&amp;quot;clock_gettime : date_time=%s, tv_nsec=%ld\n&amp;quot;, date_time, ts.tv_nsec);
}
/*
gettimeofday ——&amp;gt;struct timeval s ——&amp;gt;struct tm ——&amp;gt;format string
int gettimeofday(struct timeval *tv, struct timezone *tz);
int settimeofday(const struct timeval *tv, const struct timezone *tz);
gettimeofday() and settimeofday() return 0 for success, or -1 for failure (in which case errno is set appropriately).
*/
void nowtime_us()
{
struct timeval tv;
struct tm tm_time;
printf(&amp;quot;---------------------------struct timeval----------------------------------------\n&amp;quot;);
printf(&amp;quot;[time(NULL)] : %ld\n&amp;quot;, time(NULL));
if(gettimeofday(&amp;amp;tv,NULL)&amp;lt;0)
{
perror(&amp;quot;gettimeofday&amp;quot;);
return;
}
printf(&amp;quot;gettimeofday: tv_sec=%ld, tv_usec=%ld\n&amp;quot;, tv.tv_sec, tv.tv_usec);
localtime_r(&amp;amp;(tv.tv_sec),&amp;amp;tm_time);
char date_time[50]={0};
strftime(date_time,sizeof(date_time),&amp;quot;%Y-%m-%d %H:%M:%S&amp;quot;,&amp;amp;tm_time);
printf(&amp;quot;clock_gettime : date_time=%s, tv_usec=%ld\n&amp;quot;, date_time, tv.tv_usec);
}
int main()
{
nowtime_ns();
printf(&amp;quot;\n&amp;quot;);
nowtime_us();
printf(&amp;quot;\n&amp;quot;);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>linux hlist_head</title><link>/language/clang/linux-hlist_head/</link><pubDate>Fri, 25 Sep 2020 22:11:14 CST</pubDate><author>rinetd</author><guid>/language/clang/linux-hlist_head/</guid><description>&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;CC = gcc
CFLAGXX := -Wall -g3
CFLAGXX += -fPIC
INCDIR := . -I ../inc
BINDIR := ../bin
LIBDIR := ../lib
LIB := libhlist.so
TARGET = hlist_demo
all: $(TARGET)
SOURCE := $(wildcard *.c) $(wildcard *.cpp)
OBJS := $(patsubst %.c, %.o, $(patsubst %.cpp, %.o, $(SOURCE)))
LIBOBJS = $(filter-out rbtreedemo.o, $(OBJS))
%.o: %.c
$(CC) $(CFLAGXX) -I $(INCDIR) -c $^ -o $@
%.o: %.cpp
$(CC) $(CFLAGXX) -I $(INCDIR) -c $^ -o $@
$(TARGET): $(OBJS)
@mkdir -p $(BINDIR)
$(CC) $^ -o $(shell pwd)/$(BINDIR)/$(TARGET)
# $(CC) -fPIC -shared $(LIBOBJS) -L $(LIBDIR) -lrbtree -o $(shell pwd)/$(LIBDIR)/$(LIB)
.PHONY:
clean:
@echo Removing binary and object files ...
-rm -f *.o $(TARGET)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;time.h&amp;gt;
#include &amp;quot;list.h&amp;quot;
#define PAIR_TABLE_BITS 4
#define PAIR_TABLE_SIZE (1 &amp;lt;&amp;lt; PAIR_TABLE_BITS)
#define PAIR_TABLE_MASK (PAIR_TABLE_SIZE - 1)
static struct hlist_head *pair_map;
struct my_pair {
int key;
int value;
struct hlist_node hlist;
};
static int hash_func(struct my_pair *obj) {
int hashkey = obj-&amp;gt;key &amp;amp; PAIR_TABLE_MASK;
/* hashkey = 2; */
return hashkey;
}
void dump_entry(struct my_pair *obj) {
printf(&amp;quot;key: %-15d value: %-15d\n&amp;quot;, obj-&amp;gt;key, obj-&amp;gt;value);
}
void dump_hash_table(struct hlist_head *map) {
int i;
struct my_pair *pos;
for (i = 0; i &amp;lt; PAIR_TABLE_SIZE; ++i) {
hlist_for_each_entry(pos, &amp;amp;map[i], hlist) {
printf(&amp;quot;[bucket %2d]: &amp;quot;, i);
dump_entry(pos);
}
}
}
void flush_hash_table(struct hlist_head *map) {
int i;
struct my_pair *pos;
for (i = 0; i &amp;lt; PAIR_TABLE_SIZE; ++i) {
hlist_for_each_entry(pos, &amp;amp;map[i], hlist) {
hlist_del(pos);
/* free(pos); */
}
}
}
int main(int argc, char *argv[])
{
int i;
srand(time(NULL));
pair_map = (struct hlist_head *)malloc(sizeof(struct hlist_head) * PAIR_TABLE_SIZE);
/* init hash table */
for (i = 0; i &amp;lt; PAIR_TABLE_SIZE; ++i) {
INIT_HLIST_HEAD(&amp;amp;pair_map[i]);
}
struct my_pair *pair;
int hashkey = 0;
for (i = 0; i &amp;lt; 5; ++i) {
pair = (struct my_pair*) malloc(sizeof(struct my_pair));
pair-&amp;gt;key = rand();
pair-&amp;gt;value = pair-&amp;gt;key + 1;
/* calc hash key, i.e. the NO. of buckets */
hashkey = hash_func(pair);
/* add entry into hash map */
hlist_add_head(&amp;amp;pair-&amp;gt;hlist, &amp;amp;pair_map[hashkey]);
}
dump_hash_table(pair_map);
/* printf(&amp;quot;Del entry key = %d\n&amp;quot;, ); */
flush_hash_table(pair_map);
/* dump_entry(pair_map); */
return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>linux list_head</title><link>/language/clang/linux-list_head/</link><pubDate>Fri, 25 Sep 2020 20:23:58 CST</pubDate><author>rinetd</author><guid>/language/clang/linux-list_head/</guid><description>
&lt;h2 id=&#34;一起分析内核最重要的链表list-head&#34;&gt;一起分析内核最重要的链表list_head&lt;/h2&gt;
&lt;h2 id=&#34;一-链表结构&#34;&gt;一、链表结构&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct list_head {
struct list_head *next, *prev;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;二-链表初始化函数&#34;&gt;二、链表初始化函数&lt;/h2&gt;
&lt;p&gt;list_head 链表的初始化只是把 *next, *prev连个指针指向链表头，形成双向循环链表；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#define LIST_HEAD_INIT(name) { &amp;amp;(name), &amp;amp;(name) }
#define LIST_HEAD(name) \
struct list_head name = LIST_HEAD_INIT(name)
static inline void INIT_LIST_HEAD(struct list_head *list)
{
WRITE_ONCE(list-&amp;gt;next, list);
list-&amp;gt;prev = list;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面是各种不同的初始化或者定义并初始化链表的函数，我们都可以使用，&lt;br /&gt;
例如：&lt;br /&gt;
1）我们自己定义一个链表头,然后调用函数初始化：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct list_head name；
LIST_HEAD_INIT(name)；
//INIT_LIST_HEAD（name）;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2）或者使用下面宏定义并初始化一个双向循环链表头；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;LIST_HEAD(name)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;三-增-删-遍历接口&#34;&gt;三、增、删、遍历接口&lt;/h2&gt;
&lt;p&gt;我们都知道链表是用来保存一下有意义的字段的，但是list_haed结构中并没有其他字段，所以内核使用该链表时，总是把它嵌套到一个宿主结构中来使用。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct zj_list{
int val ;
struct list_head mylist;
}；
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-1-增加节点&#34;&gt;3.1 增加节点&lt;/h2&gt;
&lt;p&gt;内核中提供了添加一个节点的接口，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;static inline void list_add(struct list_head *new, struct list_head *head)；//首插入
static inline void list_add_tail(struct list_head *new, struct list_head *head)；//尾插入
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-2-删除节点&#34;&gt;3.2 删除节点&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;static inline void list_del(struct list_head *entry)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-3-遍历链表&#34;&gt;3.3 遍历链表&lt;/h2&gt;
&lt;p&gt;内核是同过下面这个宏定义来完成对list_head链表进行遍历的，如下 :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#define list_for_each(pos, head) for (pos = (head)-&amp;gt;next; pos != (head); pos = pos-&amp;gt;next`) //从前往后
#define list_for_each_prev(pos, head) for (pos = (head)-&amp;gt;prev; pos != (head); pos = pos-&amp;gt;prev) //从后往前
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-4-定位宿主&#34;&gt;3.4 定位宿主&lt;/h2&gt;
&lt;p&gt;上面的所有操作都是基于list_head这个链表进行的，涉及的结构体也都是该结构体，但是我们知道，这个结构体是嵌入到别的宿主中使用的，所以我们应该定位到该结构体的宿主位置,内核中有定义宏去直接得到宿主的地址,如下：&lt;br /&gt;
&lt;strong&gt;作用：已知某结构体的成员member和指向该成员的指针ptr(也就是member的地址)，算出该结构体的起始地址。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#define container_of(ptr,type,member)
{const typeof(((type*)0)-&amp;gt;member)* _myptr=(ptr);
(type*)((char*)_myptr-offsetof(type,member));})
#define offsetof(TYPE, MEMBER) ((size_t) &amp;amp;((TYPE*)0)-&amp;gt;MEMBER)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们分析上面这个宏，发现有好些都不认识，这里一个一个分析：&lt;br /&gt;
( (TYPE *)0 ) 将零转型为TYPE类型指针;&lt;br /&gt;
((TYPE *)0)-&amp;gt;MEMBER 访问结构中的数据成员;&lt;br /&gt;
&amp;amp;( ( (TYPE _)0 )-&amp;gt;MEMBER )取出数据成员的地址;，因为是从0开始的，所以就相当于该成员在结构体中的偏移量。&lt;br /&gt;
(size&lt;em&gt;t)(&amp;amp;(((TYPE&lt;/em&gt;)0)-&amp;gt;MEMBER))结果转换类型；&lt;br /&gt;
typeof为C语言的关键字，用来由变量得到变量的类型，eg；typeof(a)得到变量a的类型。&lt;/p&gt;
&lt;p&gt;经过上面分析可以看出来，其实现就是通过mem成员的地址减去mem的偏移量，来得到首地址，即宿主的地址。&lt;/p&gt;
&lt;h2 id=&#34;3-5-宿主结构的遍历&#34;&gt;3.5 宿主结构的遍历&lt;/h2&gt;
&lt;p&gt;宿主结构的遍历，它们的实现都是利用list_entry宏。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#define list_entry((ptr)-&amp;gt;next, type, member) container_of(ptr,type,member)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#define list_for_each_entry(pos, head, member) \
for (pos = list_entry((head)-&amp;gt;next, typeof(*pos), member); \
&amp;amp;pos-&amp;gt;member != (head); \
pos = list_entry(pos-&amp;gt;member.next, typeof(*pos), member))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;list.h&amp;quot; /*由于我的机器上没有list.h,所以我拷贝了一个，如果你机器上有，应该是加#include &amp;lt;linux/list.h&amp;gt;*/
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#define MAX_USER_LEN 32
#define MAX_PAS_LEN 32
#define MAX_SERVER_LEN 1024
typedef struct server_detect_ftp
{
struct list_head list;
char server[MAX_SERVER_LEN];
int port;
char username[MAX_USER_LEN];
char password[MAX_PAS_LEN];
}server_detect_ftp_t;
int main(void)
{
struct list_head head;//头部
server_detect_ftp_t ftp_link;
server_detect_ftp_t ftp_link1;
server_detect_ftp_t *entry;
struct list_head *p;
INIT_LIST_HEAD(&amp;amp;head);//初始化头部
strcpy(ftp_link.server,&amp;quot;www.163.com&amp;quot;);
ftp_link.port=34;
strcpy(ftp_link.username,&amp;quot;good&amp;quot;);
strcpy(ftp_link.password,&amp;quot;good&amp;quot;);
strcpy(ftp_link1.server,&amp;quot;www.163.com&amp;quot;);
ftp_link1.port=34;
strcpy(ftp_link1.username,&amp;quot;good&amp;quot;);
strcpy(ftp_link1.password,&amp;quot;good&amp;quot;);
INIT_LIST_HEAD(&amp;amp;head);
list_add(&amp;amp;ftp_link.list,&amp;amp;head);
list_add(&amp;amp;ftp_link1.list,&amp;amp;head);//添加链表
list_del(&amp;amp;ftp_link1.list);//删除链表
list_for_each(p,&amp;amp;head)//遍历
{
entry=list_entry(p,struct server_detect_ftp,list);//读取某个值
printf(&amp;quot;%s\n&amp;quot;,entry-&amp;gt;username);
}
return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>linux cross libuv</title><link>/language/clang/linux-cross-libuv/</link><pubDate>Mon, 21 Sep 2020 18:01:09 CST</pubDate><author>rinetd</author><guid>/language/clang/linux-cross-libuv/</guid><description>&lt;p&gt;交叉编译&lt;/p&gt;
&lt;p&gt;git clone &lt;a href=&#34;https://github.com/libuv/libuv&#34; target=&#34;_blank&#34;&gt;https://github.com/libuv/libuv&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sh autogen.sh
$ ./configure --prefix=/tmp/libuv_prefix --host=arm-none-linux-gnueabi CC=arm-none-linux-gnueabi-gcc
$ make
$ make check
$ make install
2.交叉编译libuv
./autogen.sh
CC=/opt/embedded/tools/bin/arm-linux-gnueabihf-gcc
CFLAGS=-I/opt/embedded/platform/usr/include
LDFLAGS=-L/opt/embedded/platform/usr/lib
LIBS=-ludev
./configure --prefix=/opt/embedded/platform/usr/ --host=arm-linux
make install
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>linux c string</title><link>/language/clang/linux-c-string/</link><pubDate>Mon, 07 Sep 2020 17:43:15 CST</pubDate><author>rinetd</author><guid>/language/clang/linux-c-string/</guid><description>
&lt;p&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html&#34; target=&#34;_blank&#34;&gt;C语言字符串操作 · ZMonster&#39;s Blog&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html#orgheadline1&#34; target=&#34;_blank&#34;&gt;string.h&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html#orgheadline2&#34; target=&#34;_blank&#34;&gt;字符串拷贝(strcpy, strncpy)&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html#orgheadline3&#34; target=&#34;_blank&#34;&gt;strcpy&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html#orgheadline4&#34; target=&#34;_blank&#34;&gt;strncpy&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html#orgheadline5&#34; target=&#34;_blank&#34;&gt;字符串比较(strcmp, strncmp, strcasecmp, strncasecmp)&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html#orgheadline6&#34; target=&#34;_blank&#34;&gt;strcmp&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html#orgheadline7&#34; target=&#34;_blank&#34;&gt;strncmp&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html#orgheadline8&#34; target=&#34;_blank&#34;&gt;strcasecmp&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html#orgheadline9&#34; target=&#34;_blank&#34;&gt;strncasecmp&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html#orgheadline10&#34; target=&#34;_blank&#34;&gt;字符串连接(strcat, strncat)&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html#orgheadline11&#34; target=&#34;_blank&#34;&gt;strcat&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html#orgheadline12&#34; target=&#34;_blank&#34;&gt;strncat&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html#orgheadline13&#34; target=&#34;_blank&#34;&gt;字符查找(strchr, strrchr, strchrnul, strpbrk)&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html#orgheadline14&#34; target=&#34;_blank&#34;&gt;strchr&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html#orgheadline15&#34; target=&#34;_blank&#34;&gt;strrchr&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html#orgheadline16&#34; target=&#34;_blank&#34;&gt;strchrnul&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html#orgheadline17&#34; target=&#34;_blank&#34;&gt;strpbrk&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html#orgheadline18&#34; target=&#34;_blank&#34;&gt;字符串分割(strtok, strtok_r, strsep)&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html#orgheadline19&#34; target=&#34;_blank&#34;&gt;strtok&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html#orgheadline20&#34; target=&#34;_blank&#34;&gt;strtok_r&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html#orgheadline21&#34; target=&#34;_blank&#34;&gt;strsep&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html#orgheadline22&#34; target=&#34;_blank&#34;&gt;字符串匹配(strstr)&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html#orgheadline23&#34; target=&#34;_blank&#34;&gt;字符串副本创建(strdup, strndup, strdupa, strndupa)&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html#orgheadline24&#34; target=&#34;_blank&#34;&gt;strdup&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html#orgheadline25&#34; target=&#34;_blank&#34;&gt;strndup&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html#orgheadline26&#34; target=&#34;_blank&#34;&gt;strdupa&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zmonster.me/2014/03/06/string-operation-in-c.html#orgheadline27&#34; target=&#34;_blank&#34;&gt;strndupa&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;string-h&#34;&gt;string.h&lt;/h2&gt;
&lt;p&gt;其实在C语言的标准库中，也有非常丰富的字符串操作函数。当然了，由于C语言中 &lt;strong&gt;字符串&lt;/strong&gt; 并不是基本数据类型，也没有 &lt;strong&gt;类&lt;/strong&gt; 这个概念，相对来说操作上可能没有Python/Java之类的语言方便。不过了解一下C语言中的字符串操作还是有意义的。&lt;/p&gt;
&lt;p&gt;C语言中的字符串操作函数在 &lt;strong&gt;string.h&lt;/strong&gt; 中，不过要了解都有什么函数，阅读string.h并不是什么好的方式。如果是在Unix/Linux系统下，只要执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;man string
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就可以了解都有哪些字符串操作函数了，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.zmonster.me/assets/img/string_manual.png&#34; alt=&#34;string_manual.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;其中一些常用的函数及其大致功能如下(具体细节后面再细说)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;字符串拷贝&lt;/p&gt;
&lt;p&gt;stcpy, strncpy&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;字符串比较&lt;/p&gt;
&lt;p&gt;strcmp, strncmp, strcasecmp, strncasecmp&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;字符串连接&lt;/p&gt;
&lt;p&gt;strcat, strncat&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;字符查找&lt;/p&gt;
&lt;p&gt;strchr, strrchr, strchrnul, strpbrk&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;建立字符串副本&lt;/p&gt;
&lt;p&gt;strdup, strndup, strdupa, strndupa&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;字符串分割&lt;/p&gt;
&lt;p&gt;strsep, strtok, strtok_r&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;字符串匹配&lt;/p&gt;
&lt;p&gt;strstr&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面根据功能的不同来展示各个函数的用法。这里我会用一些实例来进行示范，同时，其结果由org-babel对代码块求值得到。&lt;/p&gt;
&lt;h2 id=&#34;字符串拷贝-strcpy-strncpy&#34;&gt;字符串拷贝(strcpy, strncpy)&lt;/h2&gt;
&lt;h3 id=&#34;strcpy&#34;&gt;strcpy&lt;/h3&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;char *strcpy(char *dest, const char *src);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
int main(int argc, char *argv[])
{
char dest[1024] = {0};
char *src = &amp;quot;abcde&amp;quot;;
strcpy(dest, src);
printf(&amp;quot;%s\n&amp;quot;, dest);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abcde
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;strcpy()函数会将源字符串中的结束符(&#39;\0&#39;)也拷贝到目的字符串中。&lt;/p&gt;
&lt;p&gt;注意，strcpy()可能会导致溢出。&lt;/p&gt;
&lt;h3 id=&#34;strncpy&#34;&gt;strncpy&lt;/h3&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;char *strncpy(char *dest, const char *src, size_t n);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该函数从源字符串中拷贝n个字符到目的字符串；如果源字符串长度不足，则用 &lt;strong&gt;NULL&lt;/strong&gt; 填充，以保证将n个字符写入目的字符串中；如果源字符串中前n个字符不包含字符串结束符，函数不会为目的字符串添加上结束符。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
int main(int argc, char *argv[])
{
char dest[7] = {0};
char *src = &amp;quot;abcde&amp;quot;;
dest[5] = &#39;A&#39;;
strncpy(dest, src, 5);
printf(&amp;quot;%s\n&amp;quot;, dest);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abcdeA
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以如果有需要，应该在拷贝后自己在目的字符串尾部添加结束符。&lt;/p&gt;
&lt;h2 id=&#34;字符串比较-strcmp-strncmp-strcasecmp-strncasecmp&#34;&gt;字符串比较(strcmp, strncmp, strcasecmp, strncasecmp)&lt;/h2&gt;
&lt;h3 id=&#34;strcmp&#34;&gt;strcmp&lt;/h3&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;intstrcmp(const char *s1, const char *s2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果s1小于s2，函数返回一个负数；如果s1等于s2，函数返回0；否则返回一个正数。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
int main(int argc, char *argv[])
{
char *s1 = &amp;quot;abcde&amp;quot;;
char *s2 = &amp;quot;abcef&amp;quot;;
char *s3 = &amp;quot;ad&amp;quot;;
printf(&amp;quot;compare(%s, %s) -&amp;gt; %d\n&amp;quot;, s1, s2, strcmp(s1, s2));
printf(&amp;quot;compare(%s, %s) -&amp;gt; %d\n&amp;quot;, s1, s3, strcmp(s1, s3));
printf(&amp;quot;compare(%s, %s) -&amp;gt; %d\n&amp;quot;, s2, s3, strcmp(s2, s3));
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;compare(abcde, abcef) -&amp;gt; -1
compare(abcde, ad) -&amp;gt; -2
compare(abcef, ad) -&amp;gt; -2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从这个结果可以发现，strcmp()是根据字典序来对字符串进行比较的。进一步的，还可以发现strcmp()的返回值是比较过程中最后一次比较时两个字符的值的差，如比较&amp;quot;abcde&amp;quot;和&amp;quot;abcef&amp;quot;，有：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a - a = 0
b - b = 0
c - c = 0
d - e = -1 #按字典序，大小已分，不再比较
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;strncmp&#34;&gt;strncmp&lt;/h3&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;intstrncmp(const char *s1, const char *s2, size_t n);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和strcmp()的区别是，strncmp()只对s1和s2的前n个字节进行比较。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
int main(int argc, char *argv[])
{
char *s1 = &amp;quot;abcde&amp;quot;;
char *s2 = &amp;quot;abcfg&amp;quot;;
char *s3 = &amp;quot;abd&amp;quot;;
printf(&amp;quot;compare(%s, %s, 4) -&amp;gt; %d\n&amp;quot;, s1, s2, strncmp(s1, s2, 4));
printf(&amp;quot;compare(%s, %s, 2) -&amp;gt; %d\n&amp;quot;, s1, s3, strncmp(s1, s3, 2));
printf(&amp;quot;compare(%s, %s, 3) -&amp;gt; %d\n&amp;quot;, s2, s3, strncmp(s2, s3, 3));
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;compare(abcde, abcfg, 4) -&amp;gt; -2
compare(abcde, abd, 2) -&amp;gt; 0
compare(abcfg, abd, 3) -&amp;gt; -1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;strcasecmp&#34;&gt;strcasecmp&lt;/h3&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;intstrcasecmp(const char *s1, const char *s2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;strcasecmp()也是用来比较字符串的，和strcmp()有两点区别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用strcasecmp()应该包含 &lt;strong&gt;strings.h&lt;/strong&gt; 而不是 &lt;strong&gt;string.h&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;strcasecmp()在比较时不区分大小写&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;strings.h&amp;gt;
int main(int argc, char *argv[])
{
char *s1 = &amp;quot;AbcdE&amp;quot;;
char *s2 = &amp;quot;abcdE&amp;quot;;
printf(&amp;quot;compare(%s, %s) with case -&amp;gt; %d\n&amp;quot;, s1, s2, strcmp(s1, s2));
printf(&amp;quot;compare(%s, %s) ignore case -&amp;gt; %d\n&amp;quot;, s1, s2, strcasecmp(s1, s2));
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;compare(AbcdE, abcdE) with case -&amp;gt; -32
compare(AbcdE, abcdE) ignore case -&amp;gt; 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;strncasecmp&#34;&gt;strncasecmp&lt;/h3&gt;
&lt;p&gt;strncasecmp()之于strcasecmp()就如strncmp()之于strcmp()，不再赘述。&lt;/p&gt;
&lt;h2 id=&#34;字符串连接-strcat-strncat&#34;&gt;字符串连接(strcat, strncat)&lt;/h2&gt;
&lt;h3 id=&#34;strcat&#34;&gt;strcat&lt;/h3&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;char *strcat(char *dest, const char *src);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;strcat()首先会覆盖掉目的字符串的结束符，然后把源字符串的内容追加到后面，并在最后添加结束符。如果目的字符串缓冲区长度不够，将导致溢出。&lt;/p&gt;
&lt;p&gt;strcat()在操作完成后，返回目的字符串的首地址，这样可以方便地进行链式操作。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
int main(int argc, char *argv[])
{
char dest[1024] = &amp;quot;hello &amp;quot;;
char *src = &amp;quot;world!&amp;quot;;
printf(&amp;quot;%s\n&amp;quot;, strcat(dest, src));
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hello world!
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;strncat&#34;&gt;strncat&lt;/h3&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;char *strncat(char *dest, const char *src, size_t n);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;strncat()将最多n个字节的内容追加到目的字符串尾部，并且会在追加后添加终止符号。&lt;/p&gt;
&lt;p&gt;同strcat()一样，它返回目的字符串的首地址。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
int main(int argc, char *argv[])
{
char dest[1024] = &amp;quot;hello &amp;quot;;
char *src = &amp;quot;world!lkjsdljsd&amp;quot;;
printf(&amp;quot;%s\n&amp;quot;, strncat(dest, src, 6));
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hello world!
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;字符查找-strchr-strrchr-strchrnul-strpbrk&#34;&gt;字符查找(strchr, strrchr, strchrnul, strpbrk)&lt;/h2&gt;
&lt;h3 id=&#34;strchr&#34;&gt;strchr&lt;/h3&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;char *strchr(const char *s, int c);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;strchr()返回一个字符指针，指向指定字符在指定字符串中第一次出现的位置。如果在指定字符串中没有找到指定字符，则返回 &lt;strong&gt;NULL&lt;/strong&gt; 。该函数的第二个参数按理来说应当是一个字符，不过标准库中确实是int类型。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
int main(int argc, char *argv[])
{
char *s = &amp;quot;hello world!&amp;quot;;
char c = &#39;l&#39;;
printf(&amp;quot;%s\n&amp;quot;, strchr(s, c));
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;llo world!
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;strrchr&#34;&gt;strrchr&lt;/h3&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;char *strrchr(const char *s, int c);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;strrchr()和strchr()类似，但它返回的是指定字符在指定字符串中最后一次出现的位置。如果未找到，同样返回 &lt;strong&gt;NULL&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
int main(int argc, char *argv[])
{
char *s = &amp;quot;hello world!&amp;quot;;
char c = &#39;l&#39;;
printf(&amp;quot;%s\n&amp;quot;, strrchr(s, c));
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ld!
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;strchrnul&#34;&gt;strchrnul&lt;/h3&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;char *strchrnul(const char *s, int c);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;strchrnul()的功能和strchr()只有细微的区别，那就是，当没有找到指定字符时，strchrnul()不返回 &lt;strong&gt;NULL&lt;/strong&gt; ，而是返回字符串结束符的位置。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
int main(int argc, char *argv[])
{
char *s = &amp;quot;abcde&amp;quot;;
char c = &#39;m&#39;;
printf(&amp;quot;%p, %p\n&amp;quot;, s, strchrnul(s, c));
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0x40065c, 0x400661
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里由于strchrnul()的特性，没办法通过打印字符串来了解strchrnul()的操作，不过观察这两个指针的值，会发现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0x400661 - 0x40065c = 0x5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而字符串s的第六个元素(从0开始，5即第六个)，正好是结束符。&lt;/p&gt;
&lt;h3 id=&#34;strpbrk&#34;&gt;strpbrk&lt;/h3&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;char *strpbrk(const char *s, const char *accept);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;strpbrk()和strchr()的区别在于，strchr()是从字符串里搜索 &lt;strong&gt;一个字符&lt;/strong&gt; ，而strpbrk()则是在字符串里搜索 &lt;strong&gt;一个字符集中的字符&lt;/strong&gt; ，看第二个参数就明白了。strpbrk()遍历字符串，如果发现某个字符在指定的 &lt;strong&gt;字符集&lt;/strong&gt; 中，则立即返回指向该字符的指针。如果最后没有找到任何在指定字符集中的字符，则返回 &lt;strong&gt;NULL&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
int main(int argc, char *argv[])
{
char *s = &amp;quot;Hello World!&amp;quot;;
char *accept = &amp;quot;Wo&amp;quot;;
printf(&amp;quot;%s\n&amp;quot;, strpbrk(s, accept));
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;o World!
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;字符串分割-strtok-strtok-r-strsep&#34;&gt;字符串分割(strtok, strtok_r, strsep)&lt;/h2&gt;
&lt;h3 id=&#34;strtok&#34;&gt;strtok&lt;/h3&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;char *strtok(char *str, const char *delim);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;strtok()根据第二个参数指定的分隔符(可能存在多个不同的分隔符)将指定字符串分割成多个子串。通过多次调用strtok()，可以依次获得字符串的多个子串的首地址。要注意的是，除了第一次调用时将待分割字符串作为第一个参数，后续的调用要将第一个参数置为 &lt;strong&gt;NULL&lt;/strong&gt; 。当字符串已经无法再分割时，strtok()返回 &lt;strong&gt;NULL&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
int main(int argc, char *argv[])
{
char s[1024] = &amp;quot;abc;lsdk:lskdj,;slsj&amp;quot;;
char *delm = &amp;quot;;:,&amp;quot;;
char *result = NULL;
int len = strlen(s);
int i = 0;
result = strtok(s, delm);
while (result != NULL) {
printf(&amp;quot;Source:%s, Sub:%s\n&amp;quot;, s, result);
result = strtok(NULL, delm);
}
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Source:abc Sub:abc
Source:abc Sub:lsdk
Source:abc Sub:lskdj
Source:abc Sub:slsj
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了上面说过的strtok()的用法外，还要注意的是，作为待分割的字符串，它必须是 &lt;strong&gt;可更改的&lt;/strong&gt; 。否则虽然可以通过编译，但运行会出错。要理解这个现象，首先要了解strtok()的内部机制。&lt;/p&gt;
&lt;p&gt;了解其机制，没必要去寻找其实现源代码，只要对它的操作过程进行剖析就知道了。先看下面的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;int main(int argc, char *argv[])
{
char s[64] = &amp;quot;To be or not to be&amp;quot;;
char *delm = &amp;quot; ,.&amp;quot;; /* 分隔符：空格 \*/
char *result = NULL;
int i = 0, len = strlen(s);
for (i = 0; i &amp;lt; len; ++i) { /* 逐个打印s中的字符 \*/
printf(&amp;quot;%c &amp;quot;, s[i]);
}
printf(&amp;quot;\n&amp;quot;);
for (i = 0; i &amp;lt; len; ++i) { /* 逐个打印s中字符的数值 \*/
printf(&amp;quot;%d &amp;quot;, (int)s[i]);
}
printf(&amp;quot;\n&amp;quot;);
result = strtok(s, delm);
while (result != NULL) { /* 观察s中字符数值的变化 \*/
for (i = 0; i &amp;lt; len; ++i) {
printf(&amp;quot;%d &amp;quot;, (int)s[i]);
}
printf(&amp;quot;\n&amp;quot;);
result = strtok(NULL, delm);
}
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;colgroup&gt;&lt;br /&gt;
&lt;col class=&#34;org-right&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;col class=&#34;org-right&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;col class=&#34;org-right&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;col class=&#34;org-right&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;col class=&#34;org-right&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;col class=&#34;org-right&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;col class=&#34;org-right&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;col class=&#34;org-right&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;col class=&#34;org-right&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;col class=&#34;org-right&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;col class=&#34;org-right&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;col class=&#34;org-right&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;col class=&#34;org-right&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;col class=&#34;org-right&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;col class=&#34;org-right&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;col class=&#34;org-right&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;col class=&#34;org-right&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;col class=&#34;org-right&#34;&gt;&lt;br /&gt;
&lt;/colgroup&gt;&lt;br /&gt;
col 1 | col 2 | col 3 | col 4 | col 5 | col 6 | col 7 | col 8 | col 9 | col 10 | col 11 | col 12 | col 13 | col 14 | col 15 | col 16 | col 17 | col 18&lt;br /&gt;
----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------&lt;br /&gt;
T | o | | b | e | | o | r | | n | o | t | | t | o | | b | e&lt;br /&gt;
84 | 111 | 32 | 98 | 101 | 32 | 111 | 114 | 32 | 110 | 111 | 116 | 32 | 116 | 111 | 32 | 98 | 101&lt;br /&gt;
84 | 111 | 0 | 98 | 101 | 32 | 111 | 114 | 32 | 110 | 111 | 116 | 32 | 116 | 111 | 32 | 98 | 101&lt;br /&gt;
84 | 111 | 0 | 98 | 101 | 0 | 111 | 114 | 32 | 110 | 111 | 116 | 32 | 116 | 111 | 32 | 98 | 101&lt;br /&gt;
84 | 111 | 0 | 98 | 101 | 0 | 111 | 114 | 0 | 110 | 111 | 116 | 32 | 116 | 111 | 32 | 98 | 101&lt;br /&gt;
84 | 111 | 0 | 98 | 101 | 0 | 111 | 114 | 0 | 110 | 111 | 116 | 0 | 116 | 111 | 32 | 98 | 101&lt;br /&gt;
84 | 111 | 0 | 98 | 101 | 0 | 111 | 114 | 0 | 110 | 111 | 116 | 0 | 116 | 111 | 0 | 98 | 101&lt;br /&gt;
84 | 111 | 0 | 98 | 101 | 0 | 111 | 114 | 0 | 110 | 111 | 116 | 0 | 116 | 111 | 0 | 98 | 101&lt;/p&gt;
&lt;p&gt;可以看到，s中的分隔符，逐次地被置为&#39;\0&#39;即字符串结束符。这就是strtok()分割字符串的内部原理了。而strtok()返回的指针，其实就是s中各个子串的起始位置了。如果s指向的内容是无法被修改的，那么strtok()自然也就无法将原先的分隔符置为字符结束符了。&lt;/p&gt;
&lt;p&gt;当然了，由于源字符串会被修改，在实际中，如果需要，可以用strdup()来建立一个源字符串的副本。&lt;/p&gt;
&lt;h3 id=&#34;strtok-r&#34;&gt;strtok_r&lt;/h3&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;char *strtok_r(char *str, const char *delim, char **saveptr);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;strtok_r()是Linux下的strtok()的可重入版本(线程安全版本)，它比strtok()多了一个参数 &lt;strong&gt;saveptr&lt;/strong&gt; ，这个参数用于在分割字符串时保存上下文。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
int main(int argc, char *argv[])
{
char s[64] = &amp;quot;Hello world&amp;quot;;
char *delm = &amp;quot; &amp;quot;;
char *result = NULL, *ptr = NULL;
printf(&amp;quot;Source:%p\n&amp;quot;, s);
result = strtok_r(s, delm, &amp;amp;ptr);
while (result != NULL) {
printf(&amp;quot;Result:%p\t&amp;quot;, result);
printf(&amp;quot;Saveptr:%p\n&amp;quot;, ptr);
printf(&amp;quot;---%s\t&amp;quot;, result);
printf(&amp;quot;---%s\n&amp;quot;, ptr);
result = strtok_r(NULL, delm, &amp;amp;ptr);
}
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Source:0x7fff180f3de0
Result:0x7fff180f3de0 Saveptr:0x7fff180f3de6
---Hello ---world
Result:0x7fff180f3de6 Saveptr:0x7fff180f3deb
---world ---
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，saveptr这个指针在每次调用strtok_r()后就指向了未分割的部分的首地址。相对地，strtok()则是在内部有一个静态缓冲区，通过这个静态缓冲区来记录未处理的起始位置，所以strtok()不是线程安全的。&lt;/p&gt;
&lt;h3 id=&#34;strsep&#34;&gt;strsep&lt;/h3&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;char *strsep(char **stringp, const char *delim);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;strsep()同样是字符串分割函数，它和strtok()的不同之处在于，它会直接修改待分割的指针的值，让它始终指向未处理部分的起始位置。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
int main(int argc, char *argv[])
{
char s[64] = &amp;quot;To be or not to be&amp;quot;;
char *source = s;
char *delm = &amp;quot; &amp;quot;;
char *result = NULL;
while (source != NULL) {
printf(&amp;quot;Source:%s | &amp;quot;, source);
result = strsep(&amp;amp;source, delm);
printf(&amp;quot;result:%s\n&amp;quot;, result);
}
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Source:To be or not to be | result:To
Source:be or not to be | result:be
Source:or not to be | result: or
Source:not to be | result: not
Source:to be | result: to
Source:be | result: be
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为和strtok()的这个不同之处，strsep不需要区分第一次调用后后续的连续调用，可以用统一的操作来对字符串进行分割。&lt;/p&gt;
&lt;h2 id=&#34;字符串匹配-strstr&#34;&gt;字符串匹配(strstr)&lt;/h2&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;char *strstr(const char *haystack, const char *needle);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;strstr()返回字符串needle在字符串haystack中第一次出现的位置；如果没有匹配，则返回 &lt;strong&gt;NULL&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
int main(int argc, char *argv[])
{
char *s = &amp;quot;To be or not to be.&amp;quot;;
char *p = &amp;quot;be&amp;quot;;
printf(&amp;quot;%s\n&amp;quot;, strstr(s, p));
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;be or not to be.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;字符串副本创建-strdup-strndup-strdupa-strndupa&#34;&gt;字符串副本创建(strdup, strndup, strdupa, strndupa)&lt;/h2&gt;
&lt;h3 id=&#34;strdup&#34;&gt;strdup&lt;/h3&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;char *strdup(const char *s);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;strdup()调用malloc()分配一块内存并将字符串s的内容拷贝进去，产生s的副本。要注意的是，在最后应该调用free()来释放副本。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
int main(int argc, char *argv[])
{
char *s = &amp;quot;abcde&amp;quot;;
char *dup = strdup(s);
printf(&amp;quot;%s\n&amp;quot;, dup);
free(dup);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abcde
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;strndup&#34;&gt;strndup&lt;/h3&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;char *strndup(const char *s, size_t n);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;strndup()和strdup()类似，但最多只拷贝s的前n个字节。如果s的长度大于n，还会在副本后添加终止符。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
int main(int argc, char *argv[])
{
char *s = &amp;quot;abcde&amp;quot;;
char *dup = strndup(s, 4);
printf(&amp;quot;%s\n&amp;quot;, dup);
free(dup);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abcd
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;strdupa&#34;&gt;strdupa&lt;/h3&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;char *strdupa(const char *s);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;strdupa()和strdup()类似，但在分配内存时，它使用alloca()而不是malloc()。&lt;/p&gt;
&lt;h3 id=&#34;strndupa&#34;&gt;strndupa&lt;/h3&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;char *strndupa(const char *s, size_t n);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;strndupa()之于strdupa()就如strndup()之于strdup()，不再赘述。&lt;/p&gt;</description></item><item><title>SGM41511-bq2560</title><link>/hardware/sgm41511/</link><pubDate>Sat, 22 Aug 2020 17:03:59 CST</pubDate><author>rinetd</author><guid>/hardware/sgm41511/</guid><description>&lt;p&gt;bq2560x_charger&lt;/p&gt;</description></item><item><title>移远EC20 Opencpu方案调试记录</title><link>/hardware/opencpu/%E8%80%8C%E5%87%BA0/</link><pubDate>Thu, 13 Aug 2020 11:13:10 CST</pubDate><author>rinetd</author><guid>/hardware/opencpu/%E8%80%8C%E5%87%BA0/</guid><description>&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_35570735/article/details/87180048?&amp;amp;depth_1-&#34; target=&#34;_blank&#34;&gt;(2条消息)移远EC20二次开发之4G图像传输_qq_35570735的博客-CSDN博客_ec20模块二次开发&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/pengphei/quectel-ec20&#34; target=&#34;_blank&#34;&gt;pengphei/quectel-ec20&lt;/a&gt; EC20 手册&lt;/p&gt;
&lt;p&gt;EC20 SDK &lt;a href=&#34;https://github.com/czplove/linux_kernel_ec20/tree/master/ql-ol-sdk&#34; target=&#34;_blank&#34;&gt;https://github.com/czplove/linux_kernel_ec20/tree/master/ql-ol-sdk&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;移远EC20 Opencpu方案调试记录 - 打电话 发短信 接收短信 定位（郑州新正圆）&lt;/p&gt;
&lt;p&gt;gaoqiang13513893373 2019-07-23 19:31:40 1088 收藏 1&lt;br /&gt;
分类专栏： 调试记录&lt;br /&gt;
版权&lt;br /&gt;
microcom -s 115200 /dev/smd8 4G模块 Ctrl+x 退出&lt;/p&gt;
&lt;p&gt;microcom -s 115200 /dev/smd7 GPS Ctrl+x 退出&lt;/p&gt;
&lt;p&gt;ATD13803892789；&lt;/p&gt;
&lt;p&gt;ATA 接通 ATH 挂断&lt;/p&gt;
&lt;p&gt;AT+CLCC 查看来电显示&lt;/p&gt;
&lt;p&gt;发送短信&lt;/p&gt;
&lt;p&gt;AT+CMGF=1&lt;br /&gt;
OK&lt;br /&gt;
AT+CMGS=&amp;quot;13803892789&amp;quot;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HELLO&lt;br /&gt;
1A&lt;/p&gt;
&lt;p&gt;+CMGS: 0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接收短信&lt;/p&gt;
&lt;p&gt;AT+CMGR=0&lt;br /&gt;
+CMGR: &amp;quot;REC READ&amp;quot;,&amp;quot;18606508762&amp;quot;,,&amp;quot;19/07/22,18:40:22+32&amp;quot;&lt;br /&gt;
shax&lt;/p&gt;
&lt;p&gt;OK&lt;br /&gt;
AT+CMGR=1&lt;br /&gt;
+CMGR: &amp;quot;REC UNREAD&amp;quot;,&amp;quot;18606508762&amp;quot;,,&amp;quot;19/07/22,18:40:37+32&amp;quot;&lt;br /&gt;
2buw&lt;/p&gt;
&lt;p&gt;查看短信&lt;/p&gt;
&lt;p&gt;AT+CMGF=1&lt;br /&gt;
OK&lt;br /&gt;
AT+CMGR=1&lt;br /&gt;
+CMGR: &amp;quot;REC READ&amp;quot;,&amp;quot;18606508762&amp;quot;,,&amp;quot;19/07/22,18:40:37+32&amp;quot;&lt;br /&gt;
2buw&lt;/p&gt;
&lt;p&gt;删除短信&lt;/p&gt;
&lt;p&gt;AT+CMGD=0&lt;/p&gt;
&lt;p&gt;定位&lt;/p&gt;
&lt;p&gt;root@mdm9607-perf:/usrdata# microcom -s 115200 /dev/smd8&lt;br /&gt;
AT+QGPSCFG=&amp;quot;outport&amp;quot;,&amp;quot;linuxsmd&amp;quot;&lt;br /&gt;
OK&lt;br /&gt;
AT+QGPS=1&lt;br /&gt;
OK&lt;br /&gt;
root@mdm9607-perf:/usrdata# microcom -s 115200 /dev/smd7&lt;br /&gt;
$GPGSV,4,1,14,05,69,298,52,12,16,233,41,15,05,202,50,25,14,272,49*78&lt;br /&gt;
$GPGSV,4,2,14,29,25,316,48,02,68,036,,06,31,092,,07,02,074,*7E&lt;br /&gt;
$GPGSV,4,3,14,09,12,040,,13,28,174,,19,13,150,,30,02,104,*75&lt;br /&gt;
$GPGSV,4,4,14,39,,,39,41,,,49*74&lt;br /&gt;
$GPGGA,083737.00,3449.205308,N,11333.297982,E,1,05,1.7,145.8,M,-15.0,M,,*4C&lt;br /&gt;
$GPVTG,0.0,T,4.2,M,0.0,N,0.0,K,A*25&lt;br /&gt;
$GPRMC,083737.00,A,3449.205308,N,11333.297982,E,0.0,0.0,230719,4.2,W,A*2D&lt;br /&gt;
$GPGSA,A,2,05,12,15,25,29,,,,,,,,1.9,1.7,0.8*3B&lt;br /&gt;
$GPGSV,4,1,14,05,69,298,51,12,16,233,41,15,05,202,50,25,14,272,49*7B&lt;br /&gt;
$GPGSV,4,2,14,29,25,316,47,02,68,036,,06,31,092,,07,02,074,*71&lt;br /&gt;
$GPGSV,4,3,14,09,12,040,,13,28,174,,19,13,150,,30,02,104,*75&lt;br /&gt;
$GPGSV,4,4,14,39,,,38,41,,,49*75&lt;br /&gt;
$GPGGA,083738.00,3449.205442,N,11333.298279,E,1,05,1.7,145.7,M,-15.0,M,,*45&lt;br /&gt;
$GPVTG,0.0,T,4.2,M,0.0,N,0.0,K,A*25&lt;br /&gt;
$GPRMC,083738.00,A,3449.205442,N,11333.298279,E,0.0,0.0,230719,4.2,W,A*2B&lt;br /&gt;
$GPGSA,A,2,05,12,15,25,29,,,,,,,,1.9,1.7,0.8*3B&lt;br /&gt;
$GPGSV,4,1,14,05,69,298,51,12,16,233,41,15,05,202,50,19,13,150,25*7A&lt;br /&gt;
$GPGSV,4,2,14,25,14,272,48,29,25,316,46,30,02,104,34,02,68,036,*73&lt;br /&gt;
$GPGSV,4,3,14,06,31,092,,07,02,074,,09,12,040,,13,28,174,*76&lt;br /&gt;
$GPGSV,4,4,14,39,,,39,41,,,49*74&lt;br /&gt;
$GPGGA,083739.00,3449.205733,N,11333.298826,E,1,05,1.7,145.0,M,-15.0,M,,*46&lt;br /&gt;
$GPVTG,0.0,T,4.2,M,0.0,N,0.0,K,A*25&lt;br /&gt;
$GPRMC,083739.00,A,3449.205733,N,11333.298826,E,0.0,0.0,230719,4.2,W,A*2F&lt;br /&gt;
$GPGSA,A,2,05,12,15,25,29,,,,,,,,1.9,1.7,0.8*3B&lt;br /&gt;
$GPGSV,4,1,14,05,69,298,51,12,16,233,41,15,05,202,50,19,13,150,25*7A&lt;br /&gt;
$GPGSV,4,2,14,25,14,272,49,29,25,316,46,30,02,104,33,02,68,036,*75&lt;br /&gt;
$GPGSV,4,3,14,06,31,092,,07,02,074,,09,12,040,,13,28,174,*76&lt;br /&gt;
$GPGSV,4,4,14,39,,,38,41,,,50*7D&lt;br /&gt;
$GPGGA,083740.00,3449.206125,N,11333.29&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;作者：GQ ；XN&lt;/p&gt;
&lt;p&gt;微信交流 ： 18606508762&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.xzhengyuan.com/&#34; target=&#34;_blank&#34;&gt;http://www.xzhengyuan.com/&lt;/a&gt;&lt;/p&gt;</description></item><item><title>linux yocto bitbake poky</title><link>/hardware/linux-yocto-bitbake-poky/</link><pubDate>Tue, 11 Aug 2020 17:11:14 CST</pubDate><author>rinetd</author><guid>/hardware/linux-yocto-bitbake-poky/</guid><description>
&lt;p&gt;&lt;a href=&#34;https://www.webfalse.com/read/205697/2299548.html&#34; target=&#34;_blank&#34;&gt;Yocto tips (6): Yocto中如何共享已经下载的文件&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-名词解释&#34;&gt;1.名词解释&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Yocto：Yocto是这个开源项目的名称，该项目旨在帮助我们自定义Linux系统&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Poky：Poky有两个含义。第一个含义是用来构建Linux的构建系统，值得注意的该Poky仅仅是一个概念，而非一个实体：它包含了 BitBake工具、编译工具链、BSP、诸多程序包或层，可以认为Poky即是Yocto的本质；此外Poky还有另外一层意思，使用Poky系统得到的默认参考 Linux 发行版也叫Poky（当然，我们可以对此发行版随意命名）。Poky的两个含义千万不能混淆&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Metadata：元数据集，所谓元数据集就是发行版内各基本元素的描述与来源&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Recipes：.bb/.bbappend文件，配方文件，描述了从哪获取软件源码，如何配置，如何编译。bbappend和bb的区别主要在于bbappend是基于bb的，功能是对相应的bb文件作补充和覆盖，有点类似于“重写”的概念&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Class：.bbclass文件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Configuration：.conf文件，即配置文件，我们可以用它来改变构建方式&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Layers：即各种meta-xxx目录，将Metadata按层进行分类，有助于项目的维护&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Bitbake：一个任务执行引擎，用来解析并执行Metadata&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Output：即各种输出image&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;总结：假如用烹饪一桌酒席来形容构建发行版，则Yocto就是饭店名，Poky就是厨房（以及提供作为参考的菜的搭配套餐），Metadata就是烹饪资源（.bb/.bbappend表示配方/配方上的贴士，.conf表示厨房里的管事的小组长），Layers就是菜谱的分类（如川菜谱、粤菜谱），Bitbake就是厨师，Output就是得到的一桌酒席&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-yocto的架构&#34;&gt;2.Yocto的架构&lt;/h2&gt;
&lt;p&gt;假设现在有一个已经构建好的Yocto环境。有关Yocto的具体操作和环境构建详见&lt;a href=&#34;http://blog.csdn.net/qq_28992301/article/details/52922314&#34; target=&#34;_blank&#34;&gt;Yocto的使用实例&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设我们的项目名称叫imx6_avi，那么进入我们的项目目录，查看，其结构为&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-bash&#34;&gt;注意：该目录省略了很多不必要的细节，只把重要的文件显示了出来
imx6_avi_super
|__Makefile
|__build
| |__cache
| |__conf
| |__bblayers.conf
| |__local.conf
|
|__sources
|__base
|__cache
| |__conf
| |__bblayers.conf(和build目录中的一样)
| |__local.conf(和build目录中的一样）
|
|
|__meta-avi(放硬件无关的内容，主要和文件系统相关的东西)
| |__classes
| |__conf
| | |__distro
| | | |__imx6.conf
| | |__layer.conf
| |
| |__recipes-core
| | |__busybox
| | |__images
| | | |__avi-common-package.inc
| | | |__avi-image-core.inc
| | | |__avi-image-core.bb
| | | |__avi-image.inc
| | |__ifupdown
| | |__openssh-keys
| |
| |__recipes-qt
| |__recipes-graphics
| |__recipes-devtools
|
|
|__meta-imx6-avi
| |__conf
| | |__machine
| | |__layer.conf
| | |__include
| | |__imx6-avi-super.conf
| | |__imx6-avi_mini.conf
| |
| |__recipes-bsp
| | |__u-boot
| | |__u-boot-imx6-avi.bb
| |
| |__recipes-core
| | |__images
| | |__avi-image-core.bbappend
| |
| |__recipes-kernel
| |__linux
| |__linux-imx6-avi/
| | |__defconfig
| |__linux-imx6-avi.bb
|
|
|__meta-Exynos-avi
|__meta-qt5-avi
|__meta-fsl-arm
|__meta-openembedded
|__meta-qt5
|__poky
|__meta-skeketon
|__meta-yocto
|__meta
|__classes
|__conf
|__recipes-bsp
|
|__recipes-connectivity
| |__dhcp
| |__nfs-utils
|
|__recipes-devtools
|__recipes-core
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;首先来分析一下目录结构，不难发现主要有三级构成：meta-xxx-&amp;gt;recipes-yyy-&amp;gt;zzz/ttt.bb。比如：meta-avi-&amp;gt; recipes-core-&amp;gt;openssh-keys&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;meta-xxx就是layer（菜谱的分类如川菜谱、粤菜谱），recipes-yyy就是Metadata（具体某一本菜谱），zzz就是菜谱上具体的一个配方&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从目录中不难看出，主要有这么几个layer&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;meta-avi：由我们创建并维护。和avi有关的项目需要的配方。可以认为这个目录中的配方都是通用的、与平台无关的内容&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;meta-imx6-avi：由我们创建并维护。imx6平台avi项目需要的配方&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;meta-Exynos-avi：由我们创建并维护。Exynos平台avi项目需要的配方&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;meta-qt5-avi：由我们创建并维护。avi项目中qt5需要的配方&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;meta-fsl-arm：飞思卡尔官方推出的配方大全&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;meta-openembedded：openembedded推出的配方大全&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;meta-qt5：qt5官方推出的qt5配方大全&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;poky中的一堆meta：yocto官方推出的参考配方。虽然这些meta被放在了poky里面，但是还是不影响使用的，他们具有和上面那些meta相同的地位，如下图&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不难看出，这里面很多的layer只是我们照搬过来的，目的是为了借用里面现成的配方（可以认为这些layer充当了“库”），而真正由我们维护的仅仅是几个名字中带有avi的layer，而且它们是依赖于那些充当“库”的layer的。如下图&lt;br /&gt;
&lt;img src=&#34;https://img-blog.csdn.net/20161030093056033&#34; alt=&#34;【图二】&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;介绍完了layer，那么问题来了，那么是否可以认为，这些layer全部被enable了呢？答案固然是否定的，我们的项目是imx6_avi_super，显然不可能去包含meta-Exynos-avi这个三星平台专用的layer&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;具体的layer选择由imx6_avi_super/sources/conf/bblayers.conf负责，直观位置在前面目录中可以体现。仔细观察该文件，重点在BBLAYERS这个变量，里面有一些layer，这些layer就被enable了。不难发现这里面并没有meta-Exynos-avi，这也恰好印证了我们建立开发环境（repo sync）时，从git仓库中拉的是imx6_avi_super这个项目对应的Poky。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-bash&#34;&gt;LCONF_VERSION = &amp;quot;6&amp;quot;
BBPATH = &amp;quot;${TOPDIR}&amp;quot;
BSPDIR := &amp;quot;/home/username/yocto/imx6_avi_super&amp;quot;
BBFILES ?= &amp;quot;&amp;quot;
BBLAYERS = &amp;quot; \
${BSPDIR}/sources/poky/meta \
${BSPDIR}/sources/poky/meta-yocto \
\
${BSPDIR}/sources/meta-openembedded/meta-oe \
${BSPDIR}/sources/meta-openembedded/meta-multimedia \
${BSPDIR}/sources/meta-qt5 \
${BSPDIR}/sources/meta-qt5-avi \
\
${BSPDIR}/sources/meta-fsl-arm \
\
${BSPDIR}/sources/meta-avi \
${BSPDIR}/sources/meta-imx6-avi \
&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdn.net/20161030094244533&#34; alt=&#34;这里写图片描述&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这些layer目前是被enable了，那么是否可以认为，这些layer中的配方也全部被使能了呢？答案固然是否定的，我们的发行版中不可能把所有的软件包放进去。在Yocto中，这个选择配置操作是由好多个conf、bb文件协同完成的，并不存在一个总的大纲，这也是和buildroot最大的不同之处（buildroot是由menuconfig来进行大纲式的配置）。可以理解为Yocto是“分封制”，皇帝说的不一定能落实，具体还是各种大小地方官说了算；而buildroot是“中央集权制”，皇帝一人说了算&lt;br /&gt;
&lt;img src=&#34;https://img-blog.csdn.net/20161103135915315&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如何理解Yocto的配置方法？这要从发行版的定制流程说起。我们的目的很简单，是要得到uboot、kernel、rootfs这三个image；Yocto的目的也很简单，它要经过一级一级配置，逐步缩小配方，直至得到uboot、kernel、rootfs这三个image。每一级需要哪些配方，由该级对应的配置文件（conf/bb）决定。越上级的配置是越笼统的，越下级的配置越细致。如果下级的配置项相对于上级有补充或者冲突，则以下级的内容为准，可以认为下级会对上级进行“重写”。这其实有点类似交通法规&lt;br /&gt;
&lt;img src=&#34;https://img-blog.csdn.net/20161103133240153&#34; alt=&#34;这里写图片描述&#34; /&gt;&lt;br /&gt;
&lt;img src=&#34;https://img-blog.csdn.net/20161103134617815&#34; alt=&#34;这里写图片描述&#34; /&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有关构建的路线和流程：对于整个发行版构建，虽然每一级的配方由（conf/bb）决定，但是每一级路线和方向的选择，是由我们最终bitbake的对象决定的，比如我们最终&lt;code&gt;bitbake avi-image-core&lt;/code&gt;，我们想要获得rootfs.img，那么：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步Poky就会从local.conf开始，一路向下，一级一级配置，直到配置到和rootfs有关的那一堆bb，最终形成完整完全的配方&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;然后获取配方需要的资源，比如各种软件包，比如kernel的源码&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;最后把所有的资源编译出我们需要的镜像&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdn.net/20161103133401016&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最后说一下bitbake，比如我们要选择编译rootfs.img，那么使用&lt;code&gt;bitbake avi-image-core&lt;/code&gt;即可，但是很多时候并不直接采用这种做法。大多数情况下我们会在项目目录下写一个Makefile，里面包含各种各样的功能，内部以bitbake指令实现&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-配置文件详解&#34;&gt;3.配置文件详解&lt;/h2&gt;
&lt;p&gt;上一节简单介绍了Yocto是如何配置我们的项目，这一节开始分析具体的配置文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;local.conf&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>go gin multipart</title><link>/language/golang/go-gin-multipart/</link><pubDate>Wed, 05 Aug 2020 16:42:23 CST</pubDate><author>rinetd</author><guid>/language/golang/go-gin-multipart/</guid><description>
&lt;p&gt;如何获取所有的请求参数&lt;br /&gt;
这个其实和gin框架没有啥关系，我刚开始使用的时候以为使用request.ParseForm，然后在request.Form中就能得到了。&lt;/p&gt;
&lt;p&gt;结果发现当我的Content-type为multipart/form-data的时候，竟然解析不到数据。&lt;/p&gt;
&lt;p&gt;追到ParseForm里面发现，http/request.go里面有这么一个部分代码&lt;/p&gt;
&lt;p&gt;case ct == &amp;quot;multipart/form-data&amp;quot;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// handled by ParseMultipartForm (which is calling us, or should be)
// TODO(bradfitz): there are too many possible
// orders to call too many functions here.
// Clean this up and write more tests.
// request_test.go contains the start of this,
// in TestParseMultipartFormOrder and others.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;br /&gt;
我的golang版本是1.11.4。当content-type为multipart/form-data的时候是空的调用的。&lt;/p&gt;
&lt;p&gt;当然注释也写很清楚了，建议使用ParseMultipartForm&lt;/p&gt;
&lt;p&gt;所以获取http参数的函数我就写成这个样子：&lt;/p&gt;
&lt;p&gt;// 这个函数只返回json化之后的数据，且不处理错误，错误就返回空字符串&lt;br /&gt;
func getArgs(c *gin.Context) []byte {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if c.ContentType() == &amp;quot;multipart/form-data&amp;quot; {
c.Request.ParseMultipartForm(defaultMemory)
} else {
c.Request.ParseForm()
}
args, _ := json.Marshal(c.Request.Form)
return args
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt; router.POST(&amp;quot;/upload&amp;quot;, func(c *gin.Context) {
c.Request.ParseMultipartForm(202020)
if c.ContentType() == &amp;quot;multipart/form-data&amp;quot; {
c.Request.ParseMultipartForm(1024 * 1024)
} else {
c.Request.ParseForm()
}
// args, _ := json.Marshal(c.Request.Form)
fmt.Println(&amp;quot;c.Request.Form\n&amp;quot;, c.Request.Form)
// fmt.Println(&amp;quot;c.Request.PostForm\n&amp;quot;, c.Request.PostForm)
// fmt.Println(&amp;quot;c.Request.MultipartForm.Value\n&amp;quot;, c.Request.MultipartForm.Value)
// c.Request.Form
// map[battery:[3.998] dev_id:[356802050038933] firmware_version:[1.8.16_CAM100S21] signal:[-72dbm] temp_cpu:[42] temp_env:[42] timestamp:[1596616340]]
// c.Request.PostForm
// map[battery:[3.998] dev_id:[356802050038933] firmware_version:[1.8.16_CAM100S21] signal:[-72dbm] temp_cpu:[42] temp_env:[42] timestamp:[1596616340]]
// c.Request.MultipartForm.Value
// map[battery:[3.998] dev_id:[356802050038933] firmware_version:[1.8.16_CAM100S21] signal:[-72dbm] temp_cpu:[42] temp_env:[42] timestamp:[1596616340]]
for key, file := range c.Request.MultipartForm.File {
for k, f := range file {
fmt.Println(&amp;quot;c.Request.MultipartForm.File&amp;quot;, key, k, f.Filename)
}
}
// c.Request.MultipartForm.File upload0 0 20200805163835-30.jpg
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;golang-gin-打印所有的参数信息-gintest&#34;&gt;golang gin 打印所有的参数信息 gintest&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package middlewares
import (
&amp;quot;bytes&amp;quot;
&amp;quot;encoding/json&amp;quot;
&amp;quot;fmt&amp;quot;
&amp;quot;io/ioutil&amp;quot;
&amp;quot;net/http&amp;quot;
&amp;quot;strings&amp;quot;
&amp;quot;github.com/gin-gonic/gin&amp;quot;
&amp;quot;github.com/gin-gonic/gin/binding&amp;quot;
)
const DefaultMemory = 32 * 1024 * 1024
//一些中间件 备用
// GetHeaders ...
func GetHeaders(head http.Header) map[string]string {
hdr := make(map[string]string, len(head))
for k, v := range head {
hdr[k] = v[0]
}
return hdr
}
// GetIP ...
func GetIP(c *gin.Context) string {
ip := c.ClientIP()
return ip
}
// GetMultiPartFormValue ...
func GetMultiPartFormValue(c *http.Request) interface{} {
var requestBody interface{}
multipartForm := make(map[string]interface{})
if err := c.ParseMultipartForm(DefaultMemory); err != nil {
// handle error
}
if c.MultipartForm != nil {
for key, values := range c.MultipartForm.Value {
multipartForm[key] = strings.Join(values, &amp;quot;&amp;quot;)
}
for key, file := range c.MultipartForm.File {
for k, f := range file {
formKey := fmt.Sprintf(&amp;quot;%s%d&amp;quot;, key, k)
multipartForm[formKey] = map[string]interface{}{&amp;quot;filename&amp;quot;: f.Filename, &amp;quot;size&amp;quot;: f.Size}
}
}
if len(multipartForm) &amp;gt; 0 {
requestBody = multipartForm
}
}
return requestBody
}
// GetFormBody ...
func GetFormBody(c *http.Request) interface{} {
var requestBody interface{}
form := make(map[string]string)
if err := c.ParseForm(); err != nil {
// handle error
}
for key, values := range c.PostForm {
form[key] = strings.Join(values, &amp;quot;&amp;quot;)
}
if len(form) &amp;gt; 0 {
requestBody = form
}
return requestBody
}
// GetRequestBody ...
func GetRequestBody(c *gin.Context) interface{} {
//multiPartFormValue := GetMultiPartFormValue(c.Request)
//if multiPartFormValue != nil {
// return multiPartFormValue
//}
//
//formBody := GetFormBody(c.Request)
//if formBody != nil {
// return formBody
//}
method := c.Request.Method
if method == &amp;quot;GET&amp;quot; {
return nil
}
contentType := c.ContentType()
body := c.Request.Body
var model interface{}
bodyContent, err := ioutil.ReadAll(body)
if err != nil {
return model
}
// Restore the io.ReadCloser to its original state
c.Request.Body = ioutil.NopCloser(bytes.NewBuffer(bodyContent))
switch contentType {
case binding.MIMEJSON:
json.Unmarshal(bodyContent, &amp;amp;model)
return model
default:
model = string(bodyContent)
return model
}
}
&lt;/code&gt;&lt;/pre&gt;</description></item></channel></rss>
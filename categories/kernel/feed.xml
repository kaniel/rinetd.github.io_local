<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>kernel on 时光小栈</title><link>/categories/kernel/</link><description>Recent content in kernel on 时光小栈</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><managingEditor>rinetd@163.com (rinetd)</managingEditor><webMaster>rinetd@163.com (rinetd)</webMaster><copyright>Copyright (c) 2017. All rights reserved. (版权所有) &lt;a href=&#39;http://www.miitbeian.gov.cn/&#39;&gt;鲁ICP备17074587号-1&lt;/a&gt;</copyright><lastBuildDate>Sat, 01 Aug 2020 10:51:16 +0800</lastBuildDate><atom:link href="/categories/kernel/feed.xml" rel="self" type="application/rss+xml"/><item><title>linux kernel usb suspended</title><link>/hardware/kernel/linux-kernel-usb-suspended/</link><pubDate>Sat, 01 Aug 2020 10:51:16 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/kernel/linux-kernel-usb-suspended/</guid><description>Suspend USB devices (turn the power off) EC20 USB 1-1 注意。这个答案中的信息与旧的内核相关（最多2.6.32）。有关新内核的信息，请参阅tlwhitec。 disable external wake-up; do this only once echo disabled &amp;gt;</description></item><item><title>启用linux内核对usb摄像头的支持</title><link>/hardware/kernel/linux-kernel-uvc-usb-camera/</link><pubDate>Sat, 29 Feb 2020 20:02:14 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/kernel/linux-kernel-uvc-usb-camera/</guid><description>1、配置内核；允许如下命令配置linux内核 make menuconfig 2、启用摄像头支持，最后一步时根据自己需要进行选择摄像头配置。 Device Drivers ---&amp;gt; &amp;lt;&amp;gt; Multimedia support ---&amp;gt; [] Video capture adapters ---&amp;gt; [] V4L USB</description></item><item><title>linux driver power sleep</title><link>/hardware/kernel/linux-driver-power-sleep/</link><pubDate>Sat, 22 Feb 2020 10:27:04 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/kernel/linux-driver-power-sleep/</guid><description>wakeup events framework device wakeup 功能 &amp;amp; wake_lock电源锁 pm_stay_awake()和pm_relax()的意义_移动开发_chizhang7815的博客</description></item><item><title>Linux RTC驱动模型分析之rtc-sysfs.c</title><link>/hardware/kernel/linux-kernel-rtc-sysfs/</link><pubDate>Sat, 22 Feb 2020 10:21:58 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/kernel/linux-kernel-rtc-sysfs/</guid><description>Linux RTC驱动模型分析之rtc-sysfs.c - 嵌入式Linux中文站 linux RTC 驱动模型分析 RTC(real time clock)实时时钟，主要作用是给Linux系统提供</description></item><item><title>Linux驱动：module_platform_driver</title><link>/hardware/kernel/linux-platform-module_platform_driver/</link><pubDate>Mon, 09 Dec 2019 19:45:38 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/kernel/linux-platform-module_platform_driver/</guid><description>该宏是用来定义驱动的入口函数 module_platform_driver(hibvt_i2c_driver); static SIMPLE_DEV_PM_OPS(hibvt_i2c_dev_pm, hibvt_i2c_suspend, hibvt_i2c_resume); static const struct of_device_id hibvt_i2c_match[] = { { .compatible = &amp;quot;hisilicon,hibvt-i2c&amp;quot;}, { .compatible = &amp;quot;hisilicon,hi3516cv300-i2c&amp;quot;}, { .compatible = &amp;quot;hisilicon,hi3536dv100-i2c&amp;quot;}, {}, }; MODULE_DEVICE_TABLE(of, hibvt_i2c_match); static struct platform_driver hibvt_i2c_driver = { .driver = { .name = &amp;quot;hibvt-i2c&amp;quot;, .of_match_table = hibvt_i2c_match, .pm = &amp;amp;hibvt_i2c_dev_pm, }, .probe = hibvt_i2c_probe, .remove = hibvt_i2c_remove, }; module_platform_driver(hibvt_i2c_driver); /*</description></item><item><title>linux i2c</title><link>/hardware/kernel/linux-i2c/</link><pubDate>Sat, 23 Nov 2019 16:17:55 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/kernel/linux-i2c/</guid><description>Linux驱动之I2C设备驱动完全解析 - 夜黯竹亭风的博客 - CSDN博客 如何生成 /dev/i2c-0 i2c-dev.c /********************************************************************** /dev/i2c-*不见了 说明： 能在他的系统中没找到/d</description></item><item><title>Linux 驱动头文件说明</title><link>/hardware/kernel/linux-include/</link><pubDate>Sat, 23 Nov 2019 12:00:12 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/kernel/linux-include/</guid><description>#include &amp;lt;fcntl.h&amp;gt; // fcntl() #include &amp;lt;unistd.h&amp;gt; // read() / write() #include &amp;lt;sys/stat.h&amp;gt; // mkfifo() #include &amp;lt;string.h&amp;gt; // strncpy() / strlen() #include &amp;lt;stdlib.h&amp;gt; // malloc() / free() #include &amp;lt;sys/socket.h&amp;gt; // socket() / bind() / listen() / connect() / send() #include &amp;lt;sys/un.h&amp;gt; // sockaddr_un #include &amp;lt;netinet/in.h&amp;gt; /* For htonl and ntohl */ #include &amp;lt;errno.h&amp;gt; // errno #include &amp;lt;linux/***.h&amp;gt; //是在linux-2.6.</description></item><item><title>linux readl writel</title><link>/hardware/kernel/linux-readl-writel/</link><pubDate>Sat, 23 Nov 2019 11:49:50 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/kernel/linux-readl-writel/</guid><description>#include &amp;lt;linux/io.h&amp;gt; // #include &amp;lt;asm/io.h&amp;gt; void writel (unsigned char data , unsigned short addr ) unsigned char readl (unsigned int addr ) //从内存映射的 I/O 空间读取数据,readl 从 I/O 读取 32 位数据 ( 4 字节 )。 内核里面writel(re</description></item><item><title>linux bitops</title><link>/hardware/kernel/linux-bitops/</link><pubDate>Sat, 23 Nov 2019 11:34:11 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/kernel/linux-bitops/</guid><description>bitops.h GENMASK_ULL 和GENMASK，产生high和low之间全是1的值 GENMASK_ULL(39, 21) 这行执行后的值等于0x000000ffffe00000， 简单说就是将39和21 之</description></item><item><title>linux iio</title><link>/linux/kernel/linux-iio/</link><pubDate>Sat, 12 Oct 2019 17:16:40 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/kernel/linux-iio/</guid><description>直接读取sys 以下方式使用软件写入start的方式，每次触发一次采样 cat /sys/bus/iio/devices/iio:device0/xxx_raw 通过外部硬件trigger读取 这种方式下，每次ADC的触发都需要AD</description></item><item><title>linux adc</title><link>/linux/kernel/linux-adc/</link><pubDate>Sat, 12 Oct 2019 16:01:03 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/kernel/linux-adc/</guid><description>linux adc读取应用 - 简书 linux adc读取应用 1原理图 image.png 2设备节点 image.png 3控制代码 #include &amp;lt;stdio.h&amp;gt; //文件操作函数头文件 #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;sys/stat.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; int main(int argv,char *argc[]) { char *adc_path=&amp;quot;/dev/adc&amp;quot;; int fd,len; char</description></item><item><title>linux device</title><link>/linux/kernel/linux-device/</link><pubDate>Fri, 11 Oct 2019 17:50:45 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/kernel/linux-device/</guid><description>(8条消息)linux设备模型六（device细节） - To_run_away的博客 - CSDN博客 总线驱动设备 - 简书</description></item><item><title>linux jiffies</title><link>/linux/kernel/linux-jiffies/</link><pubDate>Fri, 11 Oct 2019 16:13:27 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/kernel/linux-jiffies/</guid><description>linux内核中jiffies的回绕问题_网络_yuanlulu的博客 深度学习开发者-CSDN博客 static inline presstype buttons_getpresstype(uint16_t downtime) { uint16_t now = buttons_gettime(); uint16_t timedown; // 解决uint16</description></item><item><title>Linux电源管理-Linux Regulator Framework代码分析</title><link>/linux/kernel/linux-kernel-regulator/</link><pubDate>Fri, 30 Aug 2019 15:29:55 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/kernel/linux-kernel-regulator/</guid><description>Linux 内核 regulator 机制 Linux电源管理-Linux Regulator Framework代码分析 本文链接：https://blog.csdn.net/longwang</description></item><item><title>devm_xxx机制</title><link>/linux/kernel/devm_xxx/</link><pubDate>Mon, 26 Aug 2019 21:56:34 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/kernel/devm_xxx/</guid><description>前言 devm是内核提供的基础机制，用于方便驱动开发者所分配资源的自动回收。参考内核文档devres.txt。总的来说，就是驱动开发者只需要调</description></item></channel></rss>
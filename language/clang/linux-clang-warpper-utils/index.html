<!doctype html><html lang=zh-cn class=no-js><title>linux clang warpper util</title><meta charset=utf-8><meta name=robots content=index,nofollow><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta http-equiv=x-dns-prefetch-control content=on><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content=origin-when-cross-origin><meta name=description content="/* * ===================================================================================== * * Filename: wrapper.h * * Description: wrapper * * Version: * Created: * Revision: none * Compiler: gcc * * Author: * Company: * Modify: * * ===================================================================================== */ #ifndef __WRAPPER_H__ #define __WRAPPER_H__ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;errno.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;time.h&gt; #include &lt;utime.h&gt; #include &lt;pthread.h&gt; #include &lt;semaphore.h&gt; #include &lt;assert.h&gt; #include &lt;fcntl.h&gt; #include &lt;dirent.h&gt; #include &lt;sys/mman.h&gt; #include &lt;sys/time.h&gt; #include"><meta name=author content=rinetd><meta name=google-site-verification content=ifeWsnNpU7w8vP3ii_Cjq-P9LKw3ngVitnMWv4XmJqk><link rel=canonical href=../../../language/clang/linux-clang-warpper-utils/><link rel=icon href=../../../public/favicon.ico><link rel="shortcut icon" href=../../../public/favicon.ico><link rel=stylesheet href=../../../front/css/main.min.css><link href=https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css rel=stylesheet><link rel=stylesheet href=//cdn.bootcss.com/video.js/6.2.8/alt/video-js-cdn.min.css><body class="single single-post single-format-standard col-3cm full-width topbar-enabled chrome"><div id=wrapper><header id=header class="top-menu-mobile-on one-mobile-menu top_menu header-ads-desktop  topbar-transparent"><nav class="nav-container group mobile-menu mobile-sticky" id=nav-mobile data-menu-id=header-1><div class=mobile-title-logo-in-header><p class=site-title><a class=custom-logo-link href rel=home title="Pytool | Home">Pytool</a></div><div class="ham__navbar-toggler-two collapsed" title=Menu aria-expanded=false><div class=ham__navbar-span-wrapper><span class="line line-1"></span><span class="line line-2"></span><span class="line line-3"></span></div></div><div class=nav-text>linux clang warpper utils</div><div class="nav-wrap container"><ul class="nav container-inner group mobile-search"><li><form class="searchform themeform" action=https://demo-hueman.presscustomizr.com/><div><input class=search name=s onblur="if(this.value=='')this.value='To search type and hit enter';" onfocus="if(this.value=='To search type and hit enter')this.value='';" value="To search type and hit enter"></div></form></ul><ul id=menu-topbar-menu class="nav container-inner group"><li class="menu-item menu-item-type-custom menu-item-object-custom current-menu-item current_page_item menu-item-home"><a href>Home</a><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children"><a href=../../../hardware/>Hardware</a><ul class=sub-menu><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../hardware/kernel/>Kernel</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../hardware/hisilicon/>Hisilicon</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../hardware/rtmp/>Rtmp</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../hardware/rk3399/>Rk3399</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../hardware/dts/>Dts</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../hardware/rk3288/>Rk3288</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../hardware/%E8%BD%A6%E8%81%94%E7%BD%91/>车联网</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../hardware/android-%E5%BA%95%E5%B1%82/>Android-底层</a></ul><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children"><a href=../../../language/>Language</a><ul class=sub-menu><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../language/clang/>Clang</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../language/golang/>Golang</a><ul class=sub-menu><li class="menu-item menu-item-type-custom menu-item-object-custom"><a href=../../../language/golang/cgo/>Cgo</a><li class="menu-item menu-item-type-custom menu-item-object-custom"><a href=../../../language/golang/hugo/>Hugo</a><li class="menu-item menu-item-type-custom menu-item-object-custom"><a href=../../../language/golang/sys/>Sys</a><li class="menu-item menu-item-type-custom menu-item-object-custom"><a href=../../../language/golang/goher/>Goher</a></ul><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../language/cpp/>Cpp</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../language/python/>Python</a><ul class=sub-menu><li class="menu-item menu-item-type-custom menu-item-object-custom"><a href=../../../language/python/scrapy/>Scrapy</a></ul><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../language/java/>Java</a><ul class=sub-menu><li class="menu-item menu-item-type-custom menu-item-object-custom"><a href=../../../language/java/hadoop/>Hadoop</a></ul><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../language/awesome/>Awesome</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../language/php/>Php</a><ul class=sub-menu><li class="menu-item menu-item-type-custom menu-item-object-custom"><a href=../../../language/php/magento/>Magento</a></ul><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../language/android/>Android</a></ul><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children"><a href=../../../linux/>Linux</a><ul class=sub-menu><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../linux/shell/>Shell</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../linux/cmd/>Cmd</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../linux/nginx/>Nginx</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../linux/ip/>Ip</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../linux/git/>Git</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../linux/haproxy/>Haproxy</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../linux/lvs/>Lvs</a></ul><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children"><a href=../../../macos/>Macos</a><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children"><a href=../../../ai/>Ai</a><ul class=sub-menu><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../ai/yolo/>Yolo</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../ai/caffe/>Caffe</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../ai/math/>Math</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../ai/ncnn/>Ncnn</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../ai/dataset/>Dataset</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../ai/pytorch/>Pytorch</a></ul><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children"><a href=../../../frontend/>Frontend</a><ul class=sub-menu><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../frontend/css/>Css</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../frontend/vue/>Vue</a></ul><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children"><a href=../../../devops/>Devops</a><ul class=sub-menu><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../devops/docker/>Docker</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../devops/elk/>Elk</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../devops/ansible/>Ansible</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../devops/prometheus/>Prometheus</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../devops/drone/>Drone</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../devops/kubernetes/>Kubernetes</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../devops/oauth2/>OAuth2</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../devops/etcd/>Etcd</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../devops/apidoc/>Apidoc</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../devops/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7/>系统监控</a></ul><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children"><a href=../../../database/>Database</a><ul class=sub-menu><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../database/mysql/>Mysql</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../database/mongo/>Mongo</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../database/redis/>Redis</a></ul><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children"><a href=../../../windows/>Windows</a><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children"><a href=../../../hacker/>Hacker</a><ul class=sub-menu><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../hacker/01_%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/>01_端口扫描</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../hacker/00_%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E9%9A%A7%E9%81%93/>00_端口转发(隧道)</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../hacker/01-info-gather/>01-Info-Gather</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../hacker/02-spoof/>02-Spoof</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../hacker/shells/>Shells</a></ul><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children"><a href=../../../work/>Work</a><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children"><a href=../../../weixin/>Weixin</a><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children"><a href=../../../edit/>Edit</a><li class=item><a class=text href=../../../series/>series</a><li class=item><a class=text href=../../../categories/>categories</a><li class=item><a class=text href=../../../tags/>tags</a><li class=item><a class=text href=../../../me/>about</a></ul></div></nav><nav class="nav-container group desktop-menu desktop-sticky" id=nav-topbar data-menu-id=header-2><div class=nav-text>linux clang warpper utils</div><div class=topbar-toggle-down><i class="fas fa-angle-double-down" aria-hidden=true data-toggle=down title="Expand menu"></i><i class="fas fa-angle-double-up" aria-hidden=true data-toggle=up title="Collapse menu"></i></div><div class="nav-wrap container"><ul id=menu-topbar-menu-1 class="nav container-inner group"><li class="menu-item menu-item-type-custom menu-item-object-custom current-menu-item current_page_item menu-item-home"><a href=../../../>Home</a><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../hardware/>Hardware</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../hardware/kernel/>Kernel</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../hardware/hisilicon/>Hisilicon</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../hardware/rtmp/>Rtmp</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../hardware/rk3399/>Rk3399</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../hardware/dts/>Dts</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../hardware/rk3288/>Rk3288</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../hardware/%E8%BD%A6%E8%81%94%E7%BD%91/>车联网</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../hardware/android-%E5%BA%95%E5%B1%82/>Android-底层</a></ul><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../language/>Language</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../language/clang/>Clang</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../language/golang/>Golang</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../language/cpp/>Cpp</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../language/python/>Python</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../language/java/>Java</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../language/awesome/>Awesome</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../language/php/>Php</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../language/android/>Android</a></ul><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../linux/>Linux</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../linux/shell/>Shell</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../linux/cmd/>Cmd</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../linux/nginx/>Nginx</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../linux/ip/>Ip</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../linux/git/>Git</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../linux/haproxy/>Haproxy</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../linux/lvs/>Lvs</a></ul><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../macos/>Macos</a><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../post/>Post</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../post/english/>English</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../post/seo/>Seo</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../post/life/>Life</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../post/wiki/>Wiki</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../post/software/>Software</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../post/basic/>Basic</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../post/reship/>Reship</a></ul><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../ai/>Ai</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../ai/yolo/>Yolo</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../ai/caffe/>Caffe</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../ai/math/>Math</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../ai/ncnn/>Ncnn</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../ai/dataset/>Dataset</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../ai/pytorch/>Pytorch</a></ul><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../frontend/>Frontend</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../frontend/css/>Css</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../frontend/vue/>Vue</a></ul><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../devops/>Devops</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../devops/docker/>Docker</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../devops/elk/>Elk</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../devops/ansible/>Ansible</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../devops/prometheus/>Prometheus</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../devops/drone/>Drone</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../devops/kubernetes/>Kubernetes</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../devops/oauth2/>OAuth2</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../devops/etcd/>Etcd</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../devops/apidoc/>Apidoc</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../devops/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7/>系统监控</a></ul><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../database/>Database</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../database/mysql/>Mysql</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../database/mongo/>Mongo</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../database/redis/>Redis</a></ul><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../windows/>Windows</a><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../hacker/>Hacker</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../hacker/01_%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/>01_端口扫描</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../hacker/00_%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E9%9A%A7%E9%81%93/>00_端口转发(隧道)</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../hacker/01-info-gather/>01-Info-Gather</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../hacker/02-spoof/>02-Spoof</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../hacker/shells/>Shells</a></ul><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../work/>Work</a><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../weixin/>Weixin</a><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../edit/>Edit</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../series/>series</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../categories/>categories</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../tags/>tags</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../me/>about</a></ul></div></nav></header><div class=container id=page><div class=container-inner><div class=main><div class="main-inner group"><div class=content><div class="pad group page-title"><ul class="meta-single group"><li><span class="fa fa-folder-open"></span><li class=category><a href=../../../categories/clang/ rel="category tag">clang</a></ul></div><div class="pad group"><article class="post type-post status-publish format-standard has-post-thumbnail hentry category-lifestyle tag-classical-grid tag-masonry-grid tag-standard-list"><div class="post-inner group"><h1 class=post-title>linux clang warpper utils</h1><p class=post-byline>by · 2020年05月29日 · 6875 Words ·
~14min reading time |
<a href=https://gitlab.com/rinetd/blog/edit/master/language/clang/linux-clang-warpper-utils.md target=_blank>Improve on <i class="fa fa-gitlab"></i></a><div class=clear></div><div class="entry themeform"><div class=entry-inner></br>原文链接：<a target=_blank href=../../../language/clang/linux-clang-warpper-utils/> linux clang warpper utils</a><pre><code class=language-cpp>/*
 * =====================================================================================
 *
 *       Filename:  wrapper.h
 *
 *    Description:  wrapper
 *
 *        Version:  
 *        Created:  
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  
 *        Company:  
 *         Modify:  
 *
 * =====================================================================================
 */
#ifndef __WRAPPER_H__
#define __WRAPPER_H__

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;time.h&gt;
#include &lt;utime.h&gt;
#include &lt;pthread.h&gt;
#include &lt;semaphore.h&gt;
#include &lt;assert.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;dirent.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;net/if.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;net/if_arp.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/sem.h&gt;
#include &lt;ctype.h&gt;
#include &lt;math.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;sched.h&gt;
#include &lt;sys/timeb.h&gt;
#include &lt;netdb.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;termios.h&gt;
#include &lt;sys/syscall.h&gt;


/* ------------ time ----------------- */
time_t os_make_time(int year,int month,int day
        ,int hour,int minute,int second);
void os_local_time(time_t utc
        ,unsigned int *pyear,unsigned int *pmonth,unsigned int *pday
        ,unsigned int *phour,unsigned int *pminute,unsigned int *psecond
        ,unsigned int *pweekday);

char *os_local_time_str(time_t time, char *time_str);

int os_get_days(int year, int month);
int os_set_time(time_t t);
int os_get_rand(int min, int max);
int os_get_time(unsigned int *pyear, unsigned int *pmonth, unsigned int *pday
        		,unsigned int *phour, unsigned int *pminute, unsigned int *psecond);


/* ------------ io &amp;&amp; string ----------------- */
ssize_t os_writen(int fd, const void *vptr, size_t n);
ssize_t os_readn(int fd, void *vptr, size_t n);
ssize_t os_readline(int fd, void *vptr, size_t maxlen);

char *os_strsep(char **stringp, const char *delim);

int os_str2number(char *str , uint32_t* pulValue);


/* ------------ mem ----------------- */
void *os_calloc(size_t nmemb, size_t size);
void *os_malloc(size_t size);
void *os_realloc(void *ptr, size_t size);
void os_free(void *ptr);

/* ------------ other ----------------- */
unsigned int os_crc32(const void *buf, unsigned int size);
pid_t os_gettid(void);

/* ------------ com port ----------------- */
int os_set_com_param(int fd, int baut, int parity, int stop, int databit);


/* ------------ net ----------------- */
#define OS_ETH0  &quot;eth0&quot;
#define OS_ETH1  &quot;eth1&quot;
#define OS_PPP0  &quot;ppp0&quot;
#define OS_PPP1  &quot;ppp1&quot;
int os_get_if_index(const char *if_name, int *ifindex);
int os_get_mac_addr(const char *if_name, char *macaddr, size_t len);
int os_get_ip_addr(const char *if_name, char *ipaddr, size_t len);
int os_get_net_mask(const char *if_name, char *netmask, size_t len);
int os_get_net_addr(const char *if_name, char *netaddr, size_t len);
int os_get_broad_cast(const char *if_name, char *broadcast, size_t len);
int os_get_gateway(const char *if_name, char *gateway, size_t len);
int os_get_dns(char *firstdns, char *seconddns, size_t len);
int os_check_mac_addr(const char *macaddr);
int os_check_ip_addr(const char *ipaddr);
int os_set_mac_addr(const char *if_name, const char *macaddr);
int os_set_mac_addr_2(const char *if_name, const char *pmac);
int os_set_ip_addr(const char* if_name, const char *ipaddr);
int os_set_net_mask(const char *if_name, const char *netmask);
int os_set_net_addr(const char *netaddr);
int os_set_broad_cast(const char *if_name, const char *broadcast);
int os_del_gateway(const char *gateway);
int os_set_gateway(const char *if_name, const char *gateway);
int os_set_dns(const char *firstdns, const char *seconddns);
int os_set_auto_dns(void);
int os_get_link_status(const char *if_name);



/* ------------ file ----------------- */

int os_is_file_exist(const char *pathname);
int os_get_file_length(const char *pathname);
int os_get_file_Name(const char *pathname, char *file, size_t len);
int os_get_file_path(const char *pathname, char *path, size_t len);
time_t os_get_file_Atime(const char *pathname);
time_t os_get_file_Mtime(const char *pathname);
int os_is_file_read(const char *pathname);
int os_is_file_write(const char *pathname);
int os_is_file_exec(const char *pathname);
int os_is_link_file(const char *pathname);
int os_is_device_file(const char *pathname);
int os_is_regular_file(const char *pathname);
int os_copy_file(const char *oldpath, const char *newpath, int flag);
int os_rm_file(const char *pathname);
int os_rename_file(const char *oldpath, const char *newpath);
int os_set_file_length(const char *pathname, int newlen);
int os_set_file_mode(const char *pathname, mode_t mode);
int os_read_lock(int fd, off_t offset, int whence, off_t len);
int os_readW_lock(int fd, off_t offset, int whence, off_t len);
int os_write_lock(int fd, off_t offset, int whence, off_t len);
int os_writeW_lock(int fd, off_t offset, int whence, off_t len);
int os_unlock(int fd, off_t offset, int whence, off_t len);
off_t os_seek(int fd, off_t offset, int whence);
off_t os_seek2begin(int fd);
off_t os_seek2end(int fd);
int os_set_Utime(const char *pathname, const struct utimbuf *times);
int os_fsync(int fd);
int os_fflush(FILE *stream);
int os_is_dir_exist(const char *pathname);
int os_is_dir(const char *pathname);
int os_get_dir_name(const char *pathname, char *dirname, size_t len);
int os_get_absolute_dir(const char *pathname, char *dirname, size_t len);
int os_is_dir_empty(const char *pathname);
long long os_get_dir_size(const char *pathname);
int os_get_dir_fileCount(const char *pathname);
int os_mk_dir(const char *pathname, mode_t mode);
int os_set_dir_mode(const char *pathname, mode_t mode);
int os_copy_dir(const char *oldpath, const char *newpath, int flag, long sleeptime);
int os_rename_dir(const char *oldpath, const char *newpath);
int os_rm_dir(const char *pathname);
int os_get_delFileCount(void);
int os_clear_delFileCount(void);

int os_stack_set_fd(FILE *fd);
void os_stack_trace(void);

#endif  //__WRAPPER_H__



/*
 * =====================================================================================
 *
 *       Filename:  wrapper.c
 *
 *    Description:  wrapper
 *
 *        Version:  1.0
 *        Created:  2011年08月27日 17时43分18秒
 *       Revision:  none
 *       Compiler:  gcc
 * 
 *
 * =====================================================================================
 */
 

#include &lt;stdarg.h&gt;
//#include &quot;log.h&quot;
#include &quot;wrapper.h&quot;

time_t os_make_time(int year,int month,int day
        ,int hour,int minute,int second)
{
    time_t ret;
    struct tm t;
	memset(&amp;t, 0, sizeof(t));
	
    t.tm_year = year-1900;
    t.tm_mon = month-1;
    t.tm_mday = day;
    t.tm_hour = hour;
    t.tm_min = minute;
    t.tm_sec = second;
	
    ret = mktime(&amp;t);
    if(ret &lt; 0) 
    {
    	printf(&quot;mktime error! errno:%s\n&quot;, strerror(errno));
        return 0;
    }
    return ret;
}

void os_local_time(time_t utc
        ,unsigned int *pyear,unsigned int *pmonth,unsigned int *pday
        ,unsigned int *phour,unsigned int *pminute,unsigned int *psecond
        ,unsigned int *pweekday)
{
    struct timeval tv;
    struct tm tm,*ret;
    if(utc&lt;0)
    {
        utc=0;
    }
    tv.tv_sec=utc;
    tv.tv_usec=0;
    ret=localtime_r(&amp;tv.tv_sec,&amp;tm);
    if(ret == NULL)
    {
        return;
    }
    if(pyear   != NULL) *pyear    = tm.tm_year+1900;
    if(pmonth  != NULL) *pmonth   = tm.tm_mon+1;
    if(pday    != NULL) *pday     = tm.tm_mday;
    if(phour   != NULL) *phour    = tm.tm_hour;
    if(pminute != NULL) *pminute  = tm.tm_min;
    if(psecond != NULL) *psecond  = tm.tm_sec;
    if(pweekday!= NULL) *pweekday = tm.tm_wday;
}

char *os_local_time_str(time_t time, char *time_str)
{   
    if(time_str == NULL)return NULL;

    unsigned int year,mon,day,hour,min,sec,weekday;
	os_local_time(time, &amp;year, &amp;mon, &amp;day, &amp;hour, &amp;min, &amp;sec, &amp;weekday);
    sprintf(time_str, &quot;%04d-%02d-%02d %02d:%02d:%02d weekday:%d&quot;
            , year
            , mon
            , day
            , hour
            , min
            , sec
            , weekday);

    return time_str;
}

int os_set_time(time_t t)
{
    struct timeval tv;

    tv.tv_sec = t;
    tv.tv_usec = 0;

	printf(&quot;-----------3---------settimeofday time:%d\n&quot;,0);

    if (settimeofday(&amp;tv, NULL) &lt; 0)
    {
        return(-1);
    }

    return(0);
}

int os_get_time(unsigned int *pyear, unsigned int *pmonth, unsigned int *pday
        		,unsigned int *phour, unsigned int *pminute, unsigned int *psecond)
{
	time_t seconds;
	struct tm *p = NULL;
	
	seconds = time((time_t *)NULL);
	p = localtime(&amp;seconds);
	if (NULL == p)
	{
		printf(&quot;localtime error!\n&quot;);
		return -1;
	}

	if(pyear   != NULL) *pyear   = 1900 + p-&gt;tm_year;
	if(pmonth  != NULL) *pmonth  = 1 + p-&gt;tm_mon;
	if(pday    != NULL) *pday    = p-&gt;tm_mday;
	if(phour   != NULL) *phour   = p-&gt;tm_hour;
	if(pminute != NULL) *pminute = p-&gt;tm_min;
	if(psecond != NULL) *psecond = p-&gt;tm_sec;

	return 0;
}

int os_get_days(int year, int month)
{
    switch (month)
    {
        case 1:
        case 3:
        case 5:
        case 7:
        case 8:
        case 10:
        case 12:
            return(31);	
        case 4:
        case 6:
        case 9:
        case 11:
            return(30);
        case 2:
            if (year%4 == 0)
                return(29);
            else
                return(28);
        default:
            return(-1);
    }
}


ssize_t os_writen(int fd, const void *vptr, size_t n)
{
    size_t nleft;
    ssize_t nwritten;
    const char *ptr;

    ptr = vptr;
    nleft = n;
    while (nleft &gt; 0) 
    {
        if ( (nwritten = write(fd, ptr, nleft)) &lt;= 0) 
        {
            if (errno == EINTR)
                nwritten = 0; /* and call write() again */
            else
                return(-1); /* error */
        }
        if (errno == 5)
            return(-1);
        nleft -= nwritten;
        ptr += nwritten;
    }
    return(n);
}

ssize_t os_readn(int fd, void *vptr, size_t n)
{
    size_t nleft;
    ssize_t nread;
    char *ptr;

    ptr = vptr;
    nleft = n;
    while (nleft &gt; 0) 
    {
        if ( (nread = read(fd, ptr, nleft)) &lt; 0) 
        {
            if (errno == EINTR)
                nread = 0; /* and call read() again */
            else
                return(-1);
        } 
        else if (nread == 0)
        {
            break; /* EOF */
        }
        nleft -= nread;
        ptr += nread;
    }

    return(n - nleft); /* return &gt;= 0 */
}

ssize_t os_readline(int fd, void *vptr, size_t maxlen)
{
    ssize_t n, rc;
    char c, *ptr;

    ptr = vptr;
    for (n = 1; n &lt; maxlen; n++)
    {
again:
        if ((rc = read(fd, &amp;c, 1)) == 1)
        {
            *ptr++ = c;
            if (c == '\n')
                break; /* newline is stored, like fgets() */
        }
        else if (rc == 0)
        {
            *ptr = 0;
            return(n - 1); /* EOF, n-1 bytes were read */
        }
        else
        {
            if (errno == EINTR)
                goto again;
            return(-1);
        }
    }
    *ptr = 0; /* null terminate like fgets() */
    return(n);
}

char *os_strsep(char **stringp, const char *delim)
{
    char *p;

    while (1)
    {
        p = strsep(stringp, delim);
        if (p == NULL)
        {
            return NULL;
        }
        else
        {
            if (p[0] == '\0')
                continue;
            else
                break;
        }
    }
    return p;
}



int os_get_rand(int min, int max)
{
    struct timeval tv;

    gettimeofday(&amp;tv, NULL);
    srand(tv.tv_usec);
    return(min+(int) ((double)(max-min+1)*rand()/(RAND_MAX*1.0)));
}

//static pthread_mutex_t alloc_mutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
static pthread_mutex_t alloc_mutex = PTHREAD_MUTEX_INITIALIZER;
static unsigned int alloc_count    = 0;

void *os_calloc(size_t nmemb, size_t size)
{
    void *p;
    pthread_mutex_lock(&amp;alloc_mutex);
    p = calloc(nmemb, size);
    if(p != NULL){alloc_count++;};
    pthread_mutex_unlock(&amp;alloc_mutex);
    return(p);
}

void *os_malloc(size_t size)
{
    void *p;
    pthread_mutex_lock(&amp;alloc_mutex);
    p = malloc(size);
    if(p != NULL){alloc_count++;};
    pthread_mutex_unlock(&amp;alloc_mutex);
    return(p);
}

void os_free(void *ptr)
{
    pthread_mutex_lock(&amp;alloc_mutex);
    if(ptr != NULL)
    {
        free(ptr);
        alloc_count--;
    }
    pthread_mutex_unlock(&amp;alloc_mutex);
}

void *os_realloc(void *ptr, size_t size)
{
    void *p;
    pthread_mutex_lock(&amp;alloc_mutex);
    p = realloc(ptr, size);	
    if(p != NULL){alloc_count++;};
    pthread_mutex_unlock(&amp;alloc_mutex);
    return(p);
}


#define NETWORK_FILE_EXIST 0

#define COMM_ADDRSIZE   20
#define COMM_FILELINE   256
#define COMM_ETHFILE    &quot;/etc/sysconfig/network-scripts/ifcfg-eth1&quot;
#define COMM_GATEWAY    &quot;/etc/sysconfig/network&quot;
#define COMM_RESOLVCONF &quot;/etc/resolv.conf&quot;
#define PROC_ROUTE      &quot;/proc/net/route&quot;

#define ETHTOOL_GLINK   0x0000000a /* Get link status (ethtool_value) */
#define SIOCETHTOOL     0x8946

typedef unsigned long long __u64;
typedef __uint32_t __u32;
typedef __uint16_t __u16;
typedef __uint8_t __u8;

struct ethtool_cmd {
    __u32 cmd;
    __u32 supported; /* Features this interface supports */
    __u32 advertising; /* Features this interface advertises */
    __u16 speed; /* The forced speed, 10Mb, 100Mb, gigabit */
    __u8 duplex; /* Duplex, half or full */
    __u8 port; /* Which connector port */
    __u8 phy_address;
    __u8 transceiver; /* Which transceiver to use */
    __u8 autoneg; /* Enable or disable autonegotiation */
    __u32 maxtxpkt; /* Tx pkts before generating tx int */
    __u32 maxrxpkt; /* Rx pkts before generating rx int */
    __u32 reserved[4];
};

/* for passing single values */
struct ethtool_value {
    __u32 cmd;
    __u32 data;
};

static int _os_mac2int(const char *macaddr, int *p);

int os_get_if_index(const char *if_name, int *ifindex)
{
    int fd;
    /*char buffer[COMM_ADDRSIZE];*/
    struct ifreq ifr;

    if((fd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &gt;= 0) {
        ifr.ifr_addr.sa_family = AF_INET;
        ifr.ifr_name[IFNAMSIZ - 1] = '\0';
        strncpy(ifr.ifr_name, if_name, IFNAMSIZ);
        if (ioctl(fd, SIOCGIFINDEX, &amp;ifr) == 0) {
            *ifindex = ifr.ifr_ifindex;
        }
        else
        {
            close(fd);
            return -2;
        }
    }
    else
    {
        close(fd);
        return -1;
    }

    close(fd);
    return 0;
}

int os_get_mac_addr(const char *if_name, char *macaddr, size_t len)
{
    int fd;
    char buffer[COMM_ADDRSIZE];
    struct ifreq ifr;

    if ((fd = socket (AF_INET, SOCK_DGRAM, 0)) &gt;= 0)
    {
        strncpy(ifr.ifr_name, if_name, IFNAMSIZ);
        ifr.ifr_name[IFNAMSIZ - 1] = '\0';
        if (ioctl(fd, SIOCGIFHWADDR, &amp;ifr) == 0)
        {
            snprintf(buffer, COMM_ADDRSIZE, &quot;%02x:%02x:%02x:%02x:%02x:%02x&quot;,
                    (unsigned char)ifr.ifr_hwaddr.sa_data[0],
                    (unsigned char)ifr.ifr_hwaddr.sa_data[1],
                    (unsigned char)ifr.ifr_hwaddr.sa_data[2],
                    (unsigned char)ifr.ifr_hwaddr.sa_data[3],
                    (unsigned char)ifr.ifr_hwaddr.sa_data[4],
                    (unsigned char)ifr.ifr_hwaddr.sa_data[5]);
        }
        else
        {
            close(fd);
            return(-1);
        }
    }
    else
    {
        return(-1);
    }

    if (strlen(buffer) &gt; len-1)
    {
        return(-1);
    }
    strncpy(macaddr, buffer, len);
    close(fd);
    return(0);
}

int os_get_ip_addr(const char *if_name, char *ipaddr, size_t len)
{
    int fd;
    char buffer[COMM_ADDRSIZE];
    struct ifreq ifr;
    struct sockaddr_in *addr;

    if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) &gt;= 0)
    {
        strncpy(ifr.ifr_name, if_name, IFNAMSIZ);
        ifr.ifr_name[IFNAMSIZ - 1] = '\0';
        if (ioctl(fd, SIOCGIFADDR, &amp;ifr) == 0)
        {
            addr = (struct sockaddr_in *)&amp;(ifr.ifr_addr);
            inet_ntop(AF_INET, &amp;addr-&gt;sin_addr, buffer, 20);
        }
        else
        {
            close(fd);
            return(-1);
        }
    }
    else
    {
        perror(&quot;os_getIpAddr error :&quot;);
        return(-1);
    }

    if (strlen(buffer) &gt; len-1)
    {
        return(-1);
    }
    strncpy(ipaddr, buffer, len);
    close(fd);
    return(0);
}

int os_get_net_mask(const char *if_name, char *netmask, size_t len)
{
    int fd;
    char buffer[COMM_ADDRSIZE];
    struct ifreq ifr;
    struct sockaddr_in *addr;

    if ((fd = socket (AF_INET, SOCK_DGRAM, 0)) &gt;= 0)
    {
        strncpy(ifr.ifr_name, if_name, IFNAMSIZ);
        ifr.ifr_name[IFNAMSIZ - 1] = '\0';
        if (ioctl(fd, SIOCGIFNETMASK, &amp;ifr) == 0)
        {
            addr = (struct sockaddr_in *)&amp;(ifr.ifr_addr);
            inet_ntop(AF_INET, &amp;addr-&gt;sin_addr, buffer, 20);
        }
        else
        {
            close(fd);
            return(-1);
        }
    }
    else
    {
        return(-1);
    }

    if (strlen(buffer) &gt; len-1)
    {
        return(-1);
    }
    strncpy(netmask, buffer, len);

    close(fd);
    return(0);
}

int os_get_net_addr(const char *if_name, char *netaddr, size_t len)
{
    int m1, m2, m3, m4, i1, i2, i3, i4;
    char ipbuf[COMM_ADDRSIZE], maskbuf[COMM_ADDRSIZE];

    if (os_get_ip_addr(if_name, ipbuf, COMM_ADDRSIZE) &lt; 0)
        return(-1);
    if (os_get_net_mask(if_name, maskbuf, COMM_ADDRSIZE) &lt; 0)
        return(-1);

    sscanf(maskbuf, &quot;%d.%d.%d.%d&quot;, &amp;m1, &amp;m2, &amp;m3, &amp;m4);
    sscanf(ipbuf, &quot;%d.%d.%d.%d&quot;, &amp;i1, &amp;i2, &amp;i3, &amp;i4);
    snprintf(netaddr, len, &quot;%d.%d.%d.%d&quot;, m1&amp;i1, m2&amp;i2, m3&amp;i3, m4&amp;i4);

    return(0);
}

int os_get_broad_cast(const char *if_name, char *broadcast, size_t len)
{
    int fd;
    char buffer[COMM_ADDRSIZE];
    struct ifreq ifr;
    struct sockaddr_in *addr;

    if ((fd = socket (AF_INET, SOCK_DGRAM, 0)) &gt;= 0)
    {
        strncpy(ifr.ifr_name, if_name, IFNAMSIZ);
        ifr.ifr_name[IFNAMSIZ - 1] = '\0';
        if (ioctl(fd, SIOCGIFBRDADDR, &amp;ifr) == 0)
        {
            addr = (struct sockaddr_in *)&amp;(ifr.ifr_addr);
            inet_ntop(AF_INET, &amp;addr-&gt;sin_addr, buffer, 20);
        }
        else
        {
            close(fd);
            return(-1);
        }
    }
    else
    {
        return(-1);
    }

    if (strlen(buffer) &gt; len-1)
    {
        return(-1);
    }
    strncpy(broadcast, buffer, len);

    close(fd);
    return(0);
}

#define CH_TO_HEX(ch) ((ch)&lt;='9'?(ch)-48:(ch)-'A'+10)

int os_get_gateway(const char *if_name, char *gateway, size_t len)
{
#if NETWORK_FILE_EXIST
    int flag = 0; /*isn't find the GATEWAY?*/
    FILE *fp;
    char buf[COMM_FILELINE], *ptr;

    if((fp = fopen(COMM_GATEWAY, &quot;r&quot;)) == NULL)
    {
        return(-1);
    }
    while (fgets(buf, COMM_FILELINE, fp) != NULL)
    {
        if (strncmp(buf, &quot;GATEWAY&quot;, 7) == 0)
        {
            sscanf(buf, &quot;GATEWAY=%s&quot;, gateway);
            if (gateway[strlen(gateway)-1] == '\n')	
                gateway[strlen(gateway)-1] = '\0';
            flag = 1;
            break;
        }
    }

    fclose(fp);
    if (flag == 0)
    {
        return(-1);
    }
#else
    int i;
    int n[4];
    int fd;
    char name[10], dest[10], dg[10], buf[1024];

    memset(gateway, '\0', len);
    if ((fd = open(PROC_ROUTE, O_RDONLY)) &lt; 0)
    {
        perror(&quot;open route&quot;);
        return(-1);
    }
    while (os_readline(fd, buf, 1024) &gt; 0)
    {
        if (memcmp(buf, if_name, 4) != 0)
            continue;
        sscanf(buf, &quot;%4s\t%8s\t%8s\t&quot;, name, dest, dg);
        if (!strcmp(dest, &quot;00000000&quot;))
        {
            for (i = 0; i &lt; 8; i = i+2)
            {
                n[i/2] = CH_TO_HEX(dg[i])*16+CH_TO_HEX(dg[i+1]);
            }
#ifdef COMM_PPC
            snprintf(gateway, len, &quot;%d.%d.%d.%d&quot;, n[0], n[1], n[2], n[3]);
#else
            snprintf(gateway, len, &quot;%d.%d.%d.%d&quot;, n[3], n[2], n[1], n[0]);
#endif
            break;
        }
    }
    close(fd);
#endif
    if (gateway[0] == '\0')
        return(-1);

    return(0);
}

int os_get_dns(char *firstdns, char *seconddns, size_t len)
{
    int flag = 0; /*isn't find the DNS?*/
    int fd;
    char buf[COMM_FILELINE], *ptr;

    if(firstdns == NULL)
        return -1;
    if((fd = open(COMM_RESOLVCONF, O_RDONLY)) &lt; 0)
    {
        return(-1);
    }
    while (os_readline(fd, buf, COMM_FILELINE) &gt; 0)
    {//printf(&quot;buf=%s\n&quot;,buf);
        if (strncmp(buf, &quot;nameserver&quot;, 10) == 0)
        {
            ptr = buf;
            os_strsep(&amp;ptr, &quot; &quot;);
            if (flag == 0)
            {
                strncpy(firstdns, os_strsep(&amp;ptr, &quot; &quot;), len);
                if (firstdns[strlen(firstdns)-1] == '\n')
                    firstdns[strlen(firstdns)-1] = '\0';
					//printf(&quot;firstdns=%s\n&quot;,firstdns);
                flag = 1;
                if (seconddns == NULL)
                    break;
                continue;
            }
            else
            {
                if(seconddns == NULL)
                    return -1;
                strncpy(seconddns, os_strsep(&amp;ptr, &quot; &quot;), len);
                if (seconddns[strlen(seconddns)-1] == '\n')
                    seconddns[strlen(seconddns)-1] = '\0';
				//printf(&quot;seconddns=%s\n&quot;,seconddns);
                flag = 2;
                break;
            }
        }
    }

    close(fd);
    if (flag == 0)
    {
        return(-1);
    }

    return(flag);
}

int os_set_mac_addr(const char *if_name, const char *macaddr)
{
    int i = 0;
    int fd;
    int imac[6];
    struct ifreq ifr;
    short temp;
#if NETWORK_FILE_EXIST
    int flag = 0; /*COMM_ETHFILE hasn't a line of MACADDR?*/
    FILE *fp, *fp_tmp;
    char tmpfile[COMM_FILELINE], buf[COMM_FILELINE];
#endif
    if (os_check_mac_addr(macaddr) &lt; 0)
    {
        printf(&quot;check mac error!\n&quot;);
        return(-1);
    }
    if ((fd =socket(AF_INET,SOCK_DGRAM,0))&lt; 0)
    {
        return(-1);
    }
    strncpy(ifr.ifr_name,if_name,IFNAMSIZ);
    ifr.ifr_name[IFNAMSIZ - 1] = '\0';
    if (ioctl(fd, SIOCGIFFLAGS, &amp;ifr) &lt; 0)
    {
        printf(&quot;ioctl get ifr failed!\n&quot;);
        return(-1);
    }
    temp = ifr.ifr_flags;
    /*shutdown interface.*/
    ifr.ifr_flags = temp &amp; (~IFF_UP);
    if (ioctl(fd, SIOCSIFFLAGS, &amp;ifr) &lt; 0)
    {
        printf(&quot;ioctl ifr failed!\n&quot;);
        return(-1);
    }
    /*change mac address.*/
    ifr.ifr_hwaddr.sa_family = 1;
    _os_mac2int(macaddr,imac);
    for (i = 0; i &lt; 6; i++)
        ifr.ifr_hwaddr.sa_data[i] = (unsigned char)imac[i];
    if (ioctl(fd,SIOCSIFHWADDR,&amp;ifr) &lt; 0)
    {
        return(-1);
    }
    /*up interface.*/
    ifr.ifr_flags = temp|IFF_UP;
    if (ioctl(fd, SIOCSIFFLAGS, &amp;ifr) &lt; 0)
    {
        return(-1);
    }
    close(fd);
#if NETWORK_FILE_EXIST
    /*change interface file, and it will take affect when reboot.*/
    if((fp = fopen(COMM_ETHFILE, &quot;r&quot;)) == NULL)
    {
        return(-1);
    }
    snprintf(tmpfile, COMM_FILELINE, &quot;%s_%d&quot;, COMM_ETHFILE, getpid());
    if((fp_tmp = fopen(tmpfile, &quot;w&quot;)) == NULL)
    {
        return(-1);
    }
    while (fgets(buf, COMM_FILELINE, fp) != NULL)
    {
        if (strncmp(buf, &quot;MACADDR&quot;, 6) == 0)
        {
            snprintf(buf, COMM_FILELINE, &quot;%s=%s\n&quot;, &quot;MACADDR&quot;, macaddr);
            flag = 1;
        }
        fputs(buf, fp_tmp);
    }
    if (flag == 0)
    {
        snprintf(buf, COMM_FILELINE, &quot;%s=%s\n&quot;, &quot;MACADDR&quot;, macaddr);
        fputs(buf, fp_tmp);
    }
    fclose(fp);
    fclose(fp_tmp);
    if (rename(tmpfile, COMM_ETHFILE) &lt; 0)
    {
        return(-1);
    }
#endif
    return(0);
}

int os_set_mac_addr_2(const char *if_name, const char *pmac)
{  
	int ret = 0;
    char shellbuf[128]= {0}; 
	
    sprintf(shellbuf, &quot;ifconfig %s hw ether %s&quot;, if_name, pmac);
    ret = system(shellbuf);
	printf(&quot;  ret:%d, shellbuf:%s\n&quot;, ret, shellbuf);
	
	return 0;
}

int os_set_ip_addr(const char* if_name, const char *ipaddr)
{
    int fd;
    struct ifreq ifr;
    struct sockaddr_in addr;

#if NETWORK_FILE_EXIST
    FILE *fp, *fp_tmp;
    char tmpfile[COMM_FILELINE], buf[COMM_FILELINE];
#endif
    if (os_check_ip_addr(ipaddr) &lt; 0)
    {
    	printf(&quot;os_check_ip_addr error!\n&quot;);
        return(-1);
    }
    /*set ip address, and take affect instant.*/
    if ((fd = socket (AF_INET, SOCK_DGRAM, 0)) &lt; 0)
    {
        printf(&quot;socket error!\n&quot;);
        return(-1);
    }
    strncpy(ifr.ifr_name, if_name, IFNAMSIZ);
    ifr.ifr_name[IFNAMSIZ - 1] = '\0';
    bzero(&amp;addr, sizeof(struct sockaddr_in));
    if (inet_pton(AF_INET, ipaddr, &amp;addr.sin_addr) &lt; 0)
    {
        printf(&quot;inet_pton error!\n&quot;);
        return(-1);
    }
    addr.sin_family = AF_INET;
    addr.sin_port = 0;
    memcpy(&amp;ifr.ifr_addr, &amp;addr, sizeof(struct sockaddr));
    if (ioctl(fd, SIOCSIFADDR, &amp;ifr) &lt; 0)
    {
        printf(&quot;ioctl error!\n&quot;);
        return(-1);
    }
    close(fd);
	
#if NETWORK_FILE_EXIST
    /*change interface file, and it will take affect when reboot.*/
    if((fp = fopen(COMM_ETHFILE, &quot;r&quot;)) == NULL)
    {
    	printf(&quot;fopen error!\n&quot;);
        return(-1);
    }

    snprintf(tmpfile, COMM_FILELINE, &quot;%s_%d&quot;, COMM_ETHFILE, getpid());
    if((fp_tmp = fopen(tmpfile, &quot;w&quot;)) == NULL)
    {
    	printf(&quot;fopen error!\n&quot;);
        return(-1);
    }

    while (fgets(buf, COMM_FILELINE, fp) != NULL)
    {
        if (strncmp(buf, &quot;IPADDR&quot;, 6) == 0)
            snprintf(buf, COMM_FILELINE, &quot;%s=%s\n&quot;, &quot;IPADDR&quot;, ipaddr);
        fputs(buf, fp_tmp);
    }
    fclose(fp);
    fclose(fp_tmp);
    if (rename(tmpfile, COMM_ETHFILE) &lt; 0)
    {
    	printf(&quot;rename error!\n&quot;);
        return(-1);
    }
#endif

    return(0);
}

int os_set_net_mask(const char *if_name, const char *netmask)
{
    int fd;
    struct ifreq ifr;
    struct sockaddr_in addr;

#if NETWORK_FILE_EXIST
    FILE *fp, *fp_tmp;
    char tmpfile[COMM_FILELINE], buf[COMM_FILELINE];
#endif

    if (os_check_ip_addr(netmask) &lt; 0)
    {
    	printf(&quot;os_check_ip_addr error!&quot;);
        return(-1);
    }

    /*set netmask, and take affect instant.*/
    if ((fd = socket (AF_INET, SOCK_DGRAM, 0)) &lt; 0)
    {
        printf(&quot;socket error!&quot;);
        return(-1);
    }
    strncpy(ifr.ifr_name, if_name, IFNAMSIZ);
    ifr.ifr_name[IFNAMSIZ - 1] = '\0';
    bzero(&amp;addr, sizeof(struct sockaddr_in));
    if (inet_pton(AF_INET, netmask, &amp;addr.sin_addr) &lt; 0)
    {
        printf(&quot;inet_pton error!&quot;);
        return(-1);
    }
    addr.sin_family = AF_INET;
    addr.sin_port = 0;
    memcpy(&amp;ifr.ifr_addr, &amp;addr, sizeof(struct sockaddr));
    if (ioctl(fd, SIOCSIFNETMASK, &amp;ifr) &lt; 0)
    {
        printf(&quot;ioctl error!&quot;);
        return(-1);
    }
    close(fd);

#if NETWORK_FILE_EXIST
    /*change interface file, and it will take affect when reboot.*/
    if((fp = fopen(COMM_ETHFILE, &quot;r&quot;)) == NULL)
    {
        printf(&quot;fopen error!&quot;);
        return(-1);
    }

    snprintf(tmpfile, COMM_FILELINE, &quot;%s_%d&quot;, COMM_ETHFILE, getpid());
    if((fp_tmp = fopen(tmpfile, &quot;w&quot;)) == NULL)
    {
        printf(&quot;fopen error!&quot;);
        return(-1);
    }

    while (fgets(buf, COMM_FILELINE, fp) != NULL)
    {
        if (strncmp(buf, &quot;NETMASK&quot;, 6) == 0)
            snprintf(buf, COMM_FILELINE, &quot;%s=%s\n&quot;, &quot;NETMASK&quot;, netmask);
        fputs(buf, fp_tmp);
    }

    fclose(fp);
    fclose(fp_tmp);
    if (rename(tmpfile, COMM_ETHFILE) &lt; 0)
    {
        printf(&quot;rename error!&quot;);
        return(-1);
    }
#endif

    return(0);
}

int os_set_net_addr(const char *netaddr)
{
#if NETWORK_FILE_EXIST
    int flag = 0; /*COMM_ETHFILE hasn't a line of NETADDR?*/
    FILE *fp, *fp_tmp;
    char tmpfile[COMM_FILELINE], buf[COMM_FILELINE];

    if((fp = fopen(COMM_ETHFILE, &quot;r&quot;)) == NULL)
    {
        return(-1);
    }

    snprintf(tmpfile, COMM_FILELINE, &quot;%s_%d&quot;, COMM_ETHFILE, getpid());
    if((fp_tmp = fopen(tmpfile, &quot;w&quot;)) == NULL)
    {
        return(-1);
    }

    while (fgets(buf, COMM_FILELINE, fp) != NULL)
    {
        if (strncmp(buf, &quot;NETADDR&quot;, 6) == 0)
        {
            snprintf(buf, COMM_FILELINE, &quot;%s=%s\n&quot;, &quot;NETADDR&quot;, netaddr);
            flag = 1;
        }
        fputs(buf, fp_tmp);
    }

    if (flag == 0)
    {
        snprintf(buf, COMM_FILELINE, &quot;%s=%s\n&quot;, &quot;NETADDR&quot;, netaddr);
        fputs(buf, fp_tmp);
    }

    fclose(fp);
    fclose(fp_tmp);
    if (rename(tmpfile, COMM_ETHFILE) &lt; 0)
    {
        return(-1);
    }
#endif

    return(0);
}

int os_set_broad_cast(const char *if_name, const char *broadcast)
{
    int fd;
    struct ifreq ifr;
    struct sockaddr_in addr;

#if NETWORK_FILE_EXIST
    int flag = 0; /*COMM_ETHFILE hasn't a line of BROADCAST?*/
    FILE *fp, *fp_tmp;
    char tmpfile[COMM_FILELINE], buf[COMM_FILELINE];
#endif

    if (os_check_ip_addr(broadcast) &lt; 0)
    {
        return(-1);
    }

    /*set broadcast, and take affect instant.*/
    if ((fd = socket (AF_INET, SOCK_DGRAM, 0)) &lt; 0)
    {
        return(-1);
    }
    strncpy(ifr.ifr_name, if_name, IFNAMSIZ);
    ifr.ifr_name[IFNAMSIZ - 1] = '\0';
    bzero(&amp;addr, sizeof(struct sockaddr_in));
    if (inet_pton(AF_INET, broadcast, &amp;addr.sin_addr) &lt; 0)
    {
        return(-1);
    }
    addr.sin_family = AF_INET;
    addr.sin_port = 0;
    memcpy(&amp;ifr.ifr_addr, &amp;addr, sizeof(struct sockaddr));
    if (ioctl(fd, SIOCSIFBRDADDR, &amp;ifr) &lt; 0)
    {
        return(-1);
    }
    close(fd);

#if NETWORK_FILE_EXIST
    /*change interface file, and it will take affect when reboot.*/
    if((fp = fopen(COMM_ETHFILE, &quot;r&quot;)) == NULL)
    {
        return(-1);
    }

    snprintf(tmpfile, COMM_FILELINE, &quot;%s_%d&quot;, COMM_ETHFILE, getpid());
    if((fp_tmp = fopen(tmpfile, &quot;w&quot;)) == NULL)
    {
        return(-1);
    }

    while (fgets(buf, COMM_FILELINE, fp) != NULL)
    {
        if (strncmp(buf, &quot;BROADCAST&quot;, 6) == 0)
        {
            snprintf(buf, COMM_FILELINE, &quot;%s=%s\n&quot;, &quot;BROADCAST&quot;, broadcast);
            flag = 1;
        }
        fputs(buf, fp_tmp);
    }

    if (flag == 0)
    {
        snprintf(buf, COMM_FILELINE, &quot;%s=%s\n&quot;, &quot;BROADCAST&quot;, broadcast);
        fputs(buf, fp_tmp);
    }

    fclose(fp);
    fclose(fp_tmp);
    if (rename(tmpfile, COMM_ETHFILE) &lt; 0)
    {
        return(-1);
    }
#endif

    return(0);
}

int os_del_gateway(const char *gateway)
{
    char cmdbuf[COMM_FILELINE]=&quot;&quot;;
    int ret;

    snprintf(cmdbuf, COMM_FILELINE, &quot;route del default gw %s&quot;, gateway);
    ret = system(cmdbuf);

    return(0);
}

int os_set_gateway(const char *if_name, const char *gateway)
{
    int ret;
#if NETWORK_FILE_EXIST
    FILE *fp, *fp_tmp;
    char tmpfile[COMM_FILELINE], buf[COMM_FILELINE];
#endif
    char cmdbuf[COMM_FILELINE]=&quot;&quot;;
    if(gateway == NULL)
        return -1;
#if NETWORK_FILE_EXIST
    if((fp = fopen(COMM_GATEWAY, &quot;r&quot;)) == NULL)
    {
        return(-1);
    }
    snprintf(tmpfile, COMM_FILELINE, &quot;%s_%d&quot;, COMM_GATEWAY, getpid());
    if((fp_tmp = fopen(tmpfile, &quot;w&quot;)) == NULL)
    {
        return(-1);
    }
    while (fgets(buf, COMM_FILELINE, fp) != NULL)
    {
        if (strncmp(buf, &quot;GATEWAY&quot;, 7) == 0)
            snprintf(buf, COMM_FILELINE, &quot;%s=%s\n&quot;, &quot;GATEWAY&quot;, gateway);
        fputs(buf, fp_tmp);
    }
    fclose(fp);
    fclose(fp_tmp);
    if (rename(tmpfile, COMM_GATEWAY) &lt; 0)
    {
        return(-1);
    }
#endif
    snprintf(cmdbuf, COMM_FILELINE, &quot;route add default gw %s dev %s&quot;, gateway, if_name);
	ret = system(cmdbuf);	
    return(0);
}

int os_set_dns(const char *firstdns, const char *seconddns)
{
#if 1 /*NETWORK_FILE_EXIST*/
    FILE *fp;
    if(firstdns == NULL)
        return -1;
    unlink(COMM_RESOLVCONF);
    if((fp = fopen(COMM_RESOLVCONF, &quot;w&quot;)) == NULL)
    {
        return(-1);
    }
    fprintf(fp, &quot;nameserver %s\n&quot;, firstdns);
    if (seconddns != NULL)
        fprintf(fp, &quot;nameserver %s\n&quot;, seconddns);
    fclose(fp);
#endif
    return(0);
}

int os_set_auto_dns(void)
{
    unlink(COMM_RESOLVCONF);
    return 0;
}

int os_get_link_status(const char *if_name)
{
    struct ethtool_value edata;
    struct ifreq ifr;
    int fd;
    int err;

    memset(&amp;ifr, 0, sizeof(ifr));
    strcpy(ifr.ifr_name, if_name);

    /* Open control socket. */
    fd = socket(AF_INET, SOCK_DGRAM, 0);
    if (fd &lt; 0) {
        perror(&quot;Cannot get control socket&quot;);
        return 70;
    }
    edata.cmd = ETHTOOL_GLINK;
    ifr.ifr_data = (caddr_t)&amp;edata;
    err = ioctl(fd, SIOCETHTOOL, &amp;ifr);
    if (err == 0) {
        close(fd);
        return (edata.data);
    } 
    else if (errno != EOPNOTSUPP) {
        perror(&quot;Cannot get link status&quot;);
    }
    close(fd);
    return 0;
}

/*some tools function, not in the commlib.*/
int os_check_ip_addr(const char *ipaddr)
{
    int i = 0, flag = 0;
    //char buf[16];
    char buf[16] = {0};

    char *tmp, *ptr;

    if (strlen(ipaddr) &gt; 15)
    {
    	printf(&quot;ipaddr &gt; 15\n&quot;);
        return(-1);
    }
    //strncpy(buf, ipaddr, 16);
    strncpy(buf, ipaddr, strlen(ipaddr));

    while (buf[i] != '\0')
    {
        switch (buf[i])
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                break;
            case '.':
                flag++;
                break;
            default:
                return(-1);
        }
        i++;
    }
    if (flag != 3)
    {
    	printf(&quot;flag error!\n&quot;);
        return(-1);
    }

    ptr = buf;
    for (i=0; i&lt;4; i++)
    {
        tmp = os_strsep(&amp;ptr, &quot;.&quot;);
        if (tmp == NULL)
        {
        	printf(&quot; tmp == NULL\n&quot;);
            return(-1);
        }
        if (atoi(tmp)&gt;255 || strlen(tmp)&gt;3 || (tmp[0]=='0' &amp;&amp; strlen(tmp)!=1))
        {
        	printf(&quot;tmp error!\n&quot;);
            return(-1);
        }
    }

    return(0);
}

int os_check_mac_addr(const char *macaddr)
{
    int i = 0;
    int flag = 0;

    if(macaddr == NULL)
        return -1;
    if (strlen(macaddr) != 17)
        return(-1);
    while (macaddr[i] != '\0')
    {
        switch (macaddr[i])
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
                break;
            case ':':
                flag++;
                break;
            default:
                return(-1);
        }
        i++;
    }
    if (flag != 5)
        return(-1);
    if (macaddr[2] != ':' || macaddr[5] != ':' || macaddr[8] != ':' 
            || macaddr[11] != ':' || macaddr[14] != ':')
        return(-1);
    return(0);
}

static int _os_mac2int(const char *macaddr, int *p)
{
    int i = 0, j = 0;
    int n1 = 0, n2 = 0;

    for (i = 0, j = 0; i &lt; strlen(macaddr); i = i+3, j++)
    {
        if (macaddr[i] &gt;= 48 &amp;&amp; macaddr[i] &lt;= 57) /*'0' &lt;--&gt; '9'*/
            n1 = macaddr[i] - 48; /*'0' == 48*/
        else if (macaddr[i] &gt;= 65 &amp;&amp; macaddr[i] &lt;= 70) /*'A' &lt;--&gt; 'F'*/
            n1 = macaddr[i] - 55; /*'A' == 65, and in hex 'A' = 10.*/
        else if (macaddr[i] &gt;= 97) /*'a' &lt;--&gt; 'f'*/
            n1 = macaddr[i] - 87; /*'a' == 97, and in hex 'a' = 10.*/

        if (macaddr[i+1] &gt;= 48 &amp;&amp; macaddr[i+1] &lt;= 57)
            n2 = macaddr[i+1] - 48;
        else if (macaddr[i+1] &gt;= 65 &amp;&amp; macaddr[i+1] &lt;= 70)
            n2 = macaddr[i+1] - 55;
        else if (macaddr[i+1] &gt;= 97)
            n2 = macaddr[i+1] - 87;

        p[j] = n1*16 + n2;
    }

    return(0);
}


/* ------------ com port ----------------- */
static pthread_mutex_t com_serial_mutex = PTHREAD_MUTEX_INITIALIZER;
static int speed_arr[] = {B115200, B57600, B38400, B19200, B9600, B4800, B2400, B1800, B1200, B600};
static int name_arr[]  = {115200, 57600, 38400, 19200, 9600, 4800, 2400, 1800, 1200, 600};
static int setSpeed(int fd, int speed);
static int setParity(int fd, int databits, int parity, int stopbits);

int os_set_com_param(int fd, int baut, int parity, int stop, int databit)
{
    int ret = 0;	
    static int _baut; 
    static int _parity;
    static int _stop;
    static int _databit;
    pthread_mutex_lock(&amp;com_serial_mutex);
    if((_baut != baut) 
        || (_parity != parity) 
        || (_stop   != stop) 
        || (_databit!= databit))
    {
    ret = setSpeed(fd, baut);
    ret = setParity(fd, databit, parity, stop);
        _baut   = baut;
        _parity = parity;
        _stop   = stop;
        _databit= databit;
    };
    pthread_mutex_unlock(&amp;com_serial_mutex);
    
	return ret;
}

static int setSpeed(int fd, int speed)
{
	int i;
	int status;

	struct termios Opt;
	if(tcgetattr(fd, &amp;Opt)!=0)
	{
		perror(&quot;SetupSerial error&quot;);
		return -1;
	}
	for(i=0; i&lt;sizeof(speed_arr)/sizeof(int); i++)
	{
		if (speed==name_arr[i])
		{
			tcflush(fd, TCIOFLUSH);
			cfsetispeed(&amp;Opt, speed_arr[i]);
			cfsetospeed(&amp;Opt, speed_arr[i]);
			status=tcsetattr(fd, TCSANOW,&amp;Opt);
			if(0!=status)
			{
				perror(&quot;tcsetattr fd error!&quot;);
			}
			tcflush(fd, TCIOFLUSH);
		}
	}
	return 0;
}

static int setParity(int fd, int databits, int parity, int stopbits)
{
	struct termios options;

	if (tcgetattr(fd, &amp;options) != 0)
	{
		perror(&quot;Setup Serial error!&quot;);
		return -1;
	}
	options.c_cflag &amp;= ~CSIZE;
	switch (databits)
	{
	case 5:
		options.c_cflag |= CS5;
		break;
	case 6:
		options.c_cflag |= CS6;
		break;
	case 7:
		options.c_cflag |= CS7;
		break;
	case 8:
		options.c_cflag |= CS8;
		break;
	default:
		fprintf(stderr, &quot;Unsupported data size!\n&quot;);
		return -1;
	}

	switch (parity)
	{
	case 0: //无校验
		options.c_cflag &amp;= ~PARENB;
		options.c_iflag &amp;= ~INPCK;
		break;
	case 1: //奇校验
		options.c_cflag |= PARENB;
		options.c_cflag |= PARODD;
		options.c_iflag |= INPCK;
		break;
	case 2: //偶校验
		options.c_cflag |= PARENB;
		options.c_cflag &amp;= ~PARODD;
		options.c_iflag |= INPCK;
		break;
	default:
		fprintf(stderr, &quot;Unsupported parity!\n&quot;);
		return -1;
	}
	switch (stopbits)
	{
	case 1:
		options.c_cflag &amp;= ~CSTOPB;
		break;
	case 2:
		options.c_cflag |= CSTOPB;
		break;
	default:
		fprintf(stderr, &quot;Unsupported stop bits!\n&quot;);
		return -1;
	}
	options.c_lflag &amp;= ~(ECHO | ICANON | ECHOE | ISIG | IEXTEN);
	options.c_iflag &amp;= ~(IXON | IXOFF | ICRNL);
	options.c_oflag &amp;= ~OPOST;
	tcflush(fd, TCIOFLUSH);
	/* options.c_cc[VTIME]=100;*/  /*SETUP 10s timeout for read if time passed,quit read;*/
	/* options.c_cc[VMIN]=0;*/    /*SETUP min len for read if len passed,quit read;;*/
	if (tcsetattr(fd, TCSANOW, &amp;options) != 0)
	{
		perror(&quot;Setup Serial in set_parity error!&quot;);
		return -1;
	}

	return 1;
}



/* ------------ file ----------------- */


#define BUCKET_SIZE 8192

static int _os_get_dir_size(const char *pathname, long long *dirsize);
static int _get_dir_file_count(const char *pathname, int *filecount);
static int lock_reg(int fd, int cmd, int type, off_t offset, int whence, off_t len);
static int _del_file_count = 0;

/*Filesystem*/
int os_is_file_exist(const char *pathname)
{	
    int fd;
    struct stat buf;

    if ((fd = open(pathname, O_RDONLY)) &lt; 0)
    {
        return(-1);
    }
    if (fstat(fd, &amp;buf) &lt; 0)
    {
        close(fd);
        return(-1);
    }
    close(fd);

    if (S_ISREG(buf.st_mode))
        return(1);

    return(0); /*not a file, maybe dir/link/fifo etc.*/
}


int os_get_file_length(const char *pathname)
{
    int fd;
    struct stat buf;

    if ((fd = open(pathname, O_RDONLY)) &lt; 0)
    {
        return(-1);
    }
    if (fstat(fd, &amp;buf) &lt; 0)
    {
        close(fd);
        return(-1);
    }
    close(fd);

    if (S_ISREG(buf.st_mode))
        return(buf.st_size);

    return(-1);
}

int os_get_file_Name(const char *pathname, char *file, size_t len)
{
    int fd;
    struct stat buf;

    if ((fd = open(pathname, O_RDONLY)) &lt; 0)
    {
        return(-1);
    }
    if (fstat(fd, &amp;buf) &lt; 0)
    {
        close(fd);
        return(-1);
    }
    close(fd);

    if (S_ISREG(buf.st_mode))
    {
        int i, newpos = -1;

        for (i = 0; *(pathname+i) != '\0'; i++)
        {
            if (*(pathname+i) == '/')
                newpos = i;
        }
        if (newpos == -1)
        {
            if (strlen(pathname) &gt; len-1)
            {
                return(-1);
            }
            strncpy(file, pathname, len);
        }
        else
        {
            if (strlen(pathname+newpos+1) &gt; len-1)
            {
                return(-1);
            }
            strncpy(file, pathname+newpos+1, len);
        }

        return(0);
    }

    return(-1);
}

int os_get_file_path(const char *pathname, char *path, size_t len)
{
    int fd;
    struct stat buf;

    if ((fd = open(pathname, O_RDONLY)) &lt; 0)
    {
        return(-1);
    }
    if (fstat(fd, &amp;buf) &lt; 0)
    {
        close(fd);
        return(-1);
    }
    close(fd);

    if (S_ISREG(buf.st_mode))
    {
        int i;
        int pathlen;
        char tmppath[PATH_MAX];
        const char *ptr = pathname;

        pathlen = strlen(pathname);
        i = pathlen;
        while (pathname[i-1] != '/')
            i--;
        if (pathname[0] == '/')
        {
            strncpy(tmppath, pathname, i-1);
        }
        else if (pathname[0] == '.' &amp;&amp; pathname[1] != '.')
        {
            getcwd(tmppath, PATH_MAX);
            strncat(tmppath, ptr+1, i-2);
        }
        else if (pathname[0] == '.' &amp;&amp; pathname[1] == '.')
        {
            char oldpath[PATH_MAX];

            getcwd(oldpath, PATH_MAX);
            chdir(&quot;..&quot;);
            getcwd(tmppath, PATH_MAX);
            chdir(oldpath);
            strncat(tmppath, ptr+2, i-2);
        }
        else
        {
            getcwd(tmppath, PATH_MAX);
            strcat(tmppath, &quot;/&quot;);
            strncat(tmppath, pathname, i-1);
        }
        if (strlen(tmppath) &gt; len-1)
        {
            return(-1);
        }
        strncpy(path, tmppath, len);
        return(0);
    }

    return(-1);
}

time_t os_get_file_Atime(const char *pathname)
{
    int fd;
    struct stat buf;

    if ((fd = open(pathname, O_RDONLY)) &lt; 0)
    {
        return(-1);
    }
    if (fstat(fd, &amp;buf) &lt; 0)
    {
        close(fd);
        return(-1);
    }
    close(fd);

    if (S_ISREG(buf.st_mode))
        return(buf.st_atime);

    return(-1);
}

time_t os_get_file_Mtime(const char *pathname)
{
    int fd;
    struct stat buf;

    if ((fd = open(pathname, O_RDONLY)) &lt; 0)
    {
        return(-1);
    }
    if (fstat(fd, &amp;buf) &lt; 0)
    {
        close(fd);
        return(-1);
    }
    close(fd);

    if (S_ISREG(buf.st_mode))
        return(buf.st_mtime);

    return(-1);
}

int os_is_file_read(const char *pathname)
{
    int fd;
    struct stat buf;

    if ((fd = open(pathname, O_RDONLY)) &lt; 0)
    {
        return(-1);
    }
    if (fstat(fd, &amp;buf) &lt; 0)
    {
        close(fd);
        return(-1);
    }
    close(fd);

    if (S_ISREG(buf.st_mode))
    {
        if ((S_IRUSR &amp; buf.st_mode) == S_IRUSR)
            return(1);
        else
            return(0);
    }

    return(-1);
}

int os_is_file_write(const char *pathname)
{
    int fd;
    struct stat buf;

    if ((fd = open(pathname, O_RDONLY)) &lt; 0)
    {
        return(-1);
    }
    if (fstat(fd, &amp;buf) &lt; 0)
    {
        close(fd);
        return(-1);
    }
    close(fd);

    if (S_ISREG(buf.st_mode))
    {
        if ((S_IWUSR &amp; buf.st_mode) == S_IWUSR)
            return(1);
        else
            return(0);
    }

    return(-1);
}

int os_is_file_exec(const char *pathname)
{
    int fd;
    struct stat buf;

    if ((fd = open(pathname, O_RDONLY)) &lt; 0)
    {
        return(-1);
    }
    if (fstat(fd, &amp;buf) &lt; 0)
    {
        close(fd);
        return(-1);
    }
    close(fd);

    if (S_ISREG(buf.st_mode))
    {
        if ((S_IXUSR &amp; buf.st_mode) == S_IXUSR)
            return(1);
        else
            return(0);
    }

    return(-1);
}

int os_is_link_file(const char *pathname)
{
    struct stat buf;

    if (lstat(pathname, &amp;buf) &lt; 0)
    {
        return(-1);
    }

    if (S_ISLNK(buf.st_mode))
        return(1);
    else
        return(0);
}

int os_is_device_file(const char *pathname)
{
    struct stat buf;

    if (lstat(pathname, &amp;buf) &lt; 0)
    {
        return(-1);
    }

    if (S_ISCHR(buf.st_mode) || S_ISBLK(buf.st_mode))
        return(1);
    else
        return(0);
}

int os_is_regular_file(const char *pathname)
{
    struct stat buf;

    if (lstat(pathname, &amp;buf) &lt; 0)
    {
        return(-1);
    }
    if (S_ISREG(buf.st_mode))
        return(1);
    else
        return(0);
}

/*flag:0, cover; 1, not cover.*/
int os_copy_file(const char *oldpath, const char *newpath, int flag)
{
    int fdin, fdout;
    int copylen = 0, leftlen = 0;
    char buf[BUCKET_SIZE];
    struct stat oldbuf, newbuf;	

    if (flag == 1)
    {
        int oldlen, newlen;

        if (os_is_file_exist(newpath) == 1) /*file is exist.*/
        {
            oldlen = os_get_file_length(oldpath);
            newlen = os_get_file_length(newpath);
            if (oldlen &lt; 0 || newlen &lt; 0)
                return(-1);
            if (oldlen == newlen) /*length is same*/
                return(0); /*return.*/
        }
    } /*if size not same or file not exist, copy will go on.*/

    if ((fdin = open(oldpath, O_RDONLY)) &lt; 0) 
    {
        return(-1);
    }
    if (fstat(fdin, &amp;oldbuf) &lt; 0) 
    {
        close(fdin);
        return(-1);
    }
    if ((fdout = open(newpath, O_RDONLY)) &gt; 0) 
    {
        if (fstat(fdout, &amp;newbuf) == 0)
        {
            if (oldbuf.st_ino == newbuf.st_ino) /*oldbuf and newbuf is the same file.*/
            {
                close(fdin);
                close(fdout);
                return(0);
            }
        }
        close(fdout);
    }
    if ((fdout = open(newpath, O_RDWR | O_CREAT | O_TRUNC, oldbuf.st_mode)) &lt; 0) 
    {
        close(fdin);
        return(-1);
    }

    leftlen = oldbuf.st_size;
    while (1)
    {
        if (leftlen &gt; BUCKET_SIZE)
            copylen = BUCKET_SIZE;
        else
            copylen = leftlen;
        if (os_readn(fdin, buf, copylen) &lt; 0)
        {
            close(fdout);
            close(fdin);
            return(-1);
        }
        if (os_writen(fdout, buf, copylen) &lt; 0)
        {
            close(fdout);
            close(fdin);
            return(-1);
        }
        leftlen = leftlen - copylen;
        if (leftlen &lt;= 0)
            break;
    }

    close(fdin);
    close(fdout);

    return(0);		
}

int os_rm_file(const char *pathname)
{
    if (unlink(pathname) &lt; 0)
    {
        return(-1);
    }

    return(0);
}

int os_rename_file(const char *oldpath, const char *newpath)
{
    if (rename(oldpath, newpath) &lt; 0)
    {
        return(-1);
    }

    return(0);
}

int os_set_file_length(const char *pathname, int newlen)
{
    if (truncate(pathname, newlen) &lt; 0)
    {
        return(-1);
    }

    return(0);
}

int os_set_file_mode(const char *pathname, mode_t mode)
{
    if (chmod(pathname, mode) &lt; 0)
    {
        return(-1);
    }

    return(0);
}

int os_read_lock(int fd, off_t offset, int whence, off_t len)
{
    if (lock_reg(fd, F_SETLK, F_RDLCK, offset, whence, len) &lt; 0)
    {
        return(-1);
    }

    return(0);
}

int os_readW_lock(int fd, off_t offset, int whence, off_t len)
{
    if (lock_reg(fd, F_SETLKW, F_RDLCK, offset, whence, len) &lt; 0)
    {
        return(-1);
    }

    return(0);
}

int os_write_lock(int fd, off_t offset, int whence, off_t len)
{
    if (lock_reg(fd, F_SETLK, F_WRLCK, offset, whence, len) &lt; 0)
    {
        return(-1);
    }

    return(0);
}

int os_writeW_lock(int fd, off_t offset, int whence, off_t len)
{
    if (lock_reg(fd, F_SETLKW, F_WRLCK, offset, whence, len) &lt; 0)
    {
        return(-1);
    }

    return(0);
}

int os_unLock(int fd, off_t offset, int whence, off_t len)
{
    if (lock_reg(fd, F_SETLKW, F_UNLCK, offset, whence, len) &lt; 0)
    {
        return(-1);
    }

    return(0);
}

off_t os_seek(int fd, off_t offset, int whence)
{
    if (lseek(fd, offset, whence) &lt; 0)
    {
        return(-1);
    }

    return(0);
}

off_t os_seek2begin(int fd)
{
    if (lseek(fd, 0, SEEK_SET) &lt; 0)
    {
        return(-1);
    }

    return(0);
}

off_t os_seek2end(int fd)
{
    if (lseek(fd, 0, SEEK_END) &lt; 0)
    {
        return(-1);
    }

    return(0);
}

int os_set_Utime(const char *pathname, const struct utimbuf *times)
{
    if (utime(pathname, times) &lt; 0)
    {
        return(-1);
    }

    return(0);
}

int os_fsync(int fd)
{
    if (fsync(fd) &lt; 0)
    {
        return(-1);
    }

    return(0);
}

int os_fflush(FILE *stream)
{
    if (fflush(stream) &lt; 0)
    {
        return(-1);
    }

    return(0);
}

int os_is_dir_exist(const char *pathname)
{
    int fd;
    struct stat buf;

    if ((fd = open(pathname, O_RDONLY)) &lt; 0)
    {
        return(-1);
    }
    if (fstat(fd, &amp;buf) &lt; 0)
    {
        close(fd);
        return(-1);
    }
    close(fd);

    if (S_ISDIR(buf.st_mode))
        return(1);

    return(0); /*not a dir, maybe file/fifo etc.*/
}

int os_is_dir(const char *pathname)
{
    int fd;
    struct stat buf;

    if ((fd = open(pathname, O_RDONLY)) &lt; 0)
    {
        return(-1);
    }
    if (fstat(fd, &amp;buf) &lt; 0)
    {
        close(fd);
        return(-1);
    }
    close(fd);

    if (S_ISDIR(buf.st_mode))
        return(1);
    else
        return(0);
}
#if 1
int os_get_dir_name(const char *pathname, char *dirname, size_t len)
{
    return(0);
}
#endif
int os_get_absolute_dir(const char *pathname, char *dirname, size_t len)
{
    int fd;
    struct stat buf;

    if ((fd = open(pathname, O_RDONLY)) &lt; 0)
    {
        return(-1);
    }
    if (fstat(fd, &amp;buf) &lt; 0)
    {
        close(fd);
        return(-1);
    }
    close(fd);

    if (S_ISDIR(buf.st_mode))
    {
        int pathlen;
        char tmppath[PATH_MAX];
        const char *ptr = pathname;

        pathlen = strlen(pathname);
        if (pathname[0] == '/')
        {
            strncpy(tmppath, pathname, PATH_MAX);
        }
        else if (pathname[0] == '.' &amp;&amp; pathname[1] != '.')
        {
            getcwd(tmppath, PATH_MAX);
            strncat(tmppath, ptr+1, PATH_MAX);
        }
        else if (pathname[0] == '.' &amp;&amp; pathname[1] == '.')
        {
            char oldpath[PATH_MAX];

            getcwd(oldpath, PATH_MAX);
            chdir(&quot;..&quot;);
            getcwd(tmppath, PATH_MAX);
            chdir(oldpath);
            strncat(tmppath, ptr+2, PATH_MAX);
        }
        else
        {
            getcwd(tmppath, PATH_MAX);
            strcat(tmppath, &quot;/&quot;);
            strncat(tmppath, pathname, PATH_MAX);
        }
        if (strlen(tmppath) &gt; len-1)
        {
            return(-1);
        }
        strncpy(dirname, tmppath, len);
        return(0);
    }

    return(-1);
}

int os_is_dir_empty(const char *pathname)
{
    DIR *dp;
    struct dirent *dirp;
    int flag = 1;

    if ((dp = opendir(pathname)) == NULL)
    {
        return(-1);
    }
    while ((dirp = readdir(dp)) != NULL)
    {
        if (strcmp(dirp-&gt;d_name, &quot;.&quot;) == 0 || strcmp(dirp-&gt;d_name, &quot;..&quot;) == 0)
            continue;
        else
        {
            flag = 0; /*dir is not empty.*/
            break;
        }
    }
    if (closedir(dp) &lt; 0)
    {
        return(-1);
    }

    return(flag);
}

long long os_get_dir_size(const char *pathname)
{
    long long dirsize = 0;

    if (_os_get_dir_size(pathname, &amp;dirsize) &lt; 0)
        return(-1); /*comm_errno has set in _os_get_dir_size().*/

    return(dirsize);	
}

int os_get_dir_fileCount(const char *pathname)
{
    int filecount = 0;	

    if (_get_dir_file_count(pathname, &amp;filecount) &lt; 0)
        return(-1);

    return(filecount);
}

int os_mk_dir(const char *pathname, mode_t mode)
{
    if (mkdir(pathname, mode) &lt; 0)
    {
        return(-1);
    }

    return(0);
}

int os_set_dir_mode(const char *pathname, mode_t mode)
{
    if (chmod(pathname, mode) &lt; 0)
    {
        return(-1);
    }

    return(0);
}

int os_copy_dir(const char *oldpath, const char *newpath, int flag, long sleeptime)
{
    int fdold, fdnew;
    char srcbuf[PATH_MAX], dstbuf[PATH_MAX];
    DIR *dp;
    struct dirent *ep;
    struct stat oldbuf, newbuf;

    /*judge the oldpath and newpath is the same dir.*/
    if ((fdold = open(oldpath, O_RDONLY)) &lt; 0)
    {
        return(-1);
    }
    if (fstat(fdold, &amp;oldbuf) != 0) 
    {
        close(fdold);
        return(-1);
    }
    if ((fdnew = open(newpath, O_RDONLY)) &gt;= 0)
    {
        if (stat(newpath, &amp;newbuf) == 0)
        {
            if (oldbuf.st_ino == newbuf.st_ino)	
            {
                close(fdold);
                close(fdnew);
                return(0);
            }
        }
        close(fdnew);
    }
    close(fdold);

    mkdir(newpath, oldbuf.st_mode); /*if newpath exist, ignore; else create.*/
    if ((dp = opendir(oldpath)) == NULL)
    {
        return(-1);
    }
    while ((ep = readdir(dp)) != NULL) 
    {
        snprintf(srcbuf, PATH_MAX, &quot;%s/%s&quot;, oldpath, ep-&gt;d_name);
        snprintf(dstbuf, PATH_MAX, &quot;%s/%s&quot;, newpath, ep-&gt;d_name);
        if (strcmp(ep-&gt;d_name, &quot;.&quot;) == 0 || strcmp(ep-&gt;d_name, &quot;..&quot;) == 0)
            continue;
        if (lstat(srcbuf, &amp;oldbuf) != 0) 
        {
            closedir(dp);
            return(-1);
        }
        if (S_ISDIR(oldbuf.st_mode))
        {
            if (os_copy_dir(srcbuf, dstbuf, flag, sleeptime) &lt; 0)
            {
                closedir(dp);
                return(-1);
            }
        }
        else if (S_ISREG(oldbuf.st_mode)) 
        {
            if (os_copy_file(srcbuf, dstbuf, flag) &lt; 0)
            {
                closedir(dp);
                return(-1);
            }
            if (sleeptime != 0)
                usleep(sleeptime);
        }
        else if (S_ISLNK(oldbuf.st_mode)) 
        {
            char tmpbuf[PATH_MAX];
            int len;

            if ((len = readlink(srcbuf, tmpbuf, PATH_MAX)) &lt; 0)	
            {
                closedir(dp);
                return(-1);
            }	
            tmpbuf[len] = '\0';
            unlink(dstbuf); /*ignore old link is exist, unlink and relink it.*/
            if (symlink(tmpbuf, dstbuf) &lt; 0)
            {
                closedir(dp);
                return(-1);
            }
        }
        else
            ; /*others is ignored.*/
    }

    if (closedir(dp) &lt; 0)
    {
        return(-1);
    }
    return(0);
}

int os_rename_dir(const char *oldpath, const char *newpath)
{
    if (rename(oldpath, newpath))
    {
        return(-1);
    }

    return(0);
}

int os_rm_dir(const char *pathname)
{
    char dirbuf[PATH_MAX];
    DIR *dp;
    struct dirent *ep;
    struct stat buf;

    if ((dp = opendir(pathname)) == NULL)
    {
        return(-1);
    }
    while ((ep = readdir(dp)) != NULL)
    {
        snprintf(dirbuf, PATH_MAX, &quot;%s/%s&quot;, pathname, ep-&gt;d_name);
        if (strcmp(ep-&gt;d_name, &quot;.&quot;) == 0 || strcmp(ep-&gt;d_name, &quot;..&quot;) == 0)
            continue;
        if (lstat(dirbuf, &amp;buf) != 0)
        {
            closedir(dp);
            return(-1);
        }
        if (S_ISDIR(buf.st_mode))
        {
            if (os_rm_dir(dirbuf) &lt; -1)
            {
                closedir(dp);
                return(-1);
            }
        }
        else
        {
            if (unlink(dirbuf) &lt; 0)
            {
                closedir(dp);
                return(-1);
            }
            _del_file_count++;
            usleep(200*1000);
        }
    }
    if (closedir(dp) &lt; 0)
    {
        return(-1);
    }
    if (rmdir(pathname) &lt; 0)
    {
        return(-1);
    }

    return(0);
}

int os_get_delFileCount(void)
{
    return(_del_file_count);
}

int os_clear_delFileCount(void)
{
    _del_file_count = 0;
    return(0);
}

/*some tools function, not in the commlib.*/
static int lock_reg(int fd, int cmd, int type, off_t offset, int whence, off_t len)
{
    struct flock lock;

    lock.l_type = type; /* F_RDLCK, F_WRLCK, F_UNLCK */
    lock.l_start = offset; /* byte offset, relative to l_whence */
    lock.l_whence = whence; /* SEET_SET, SEEK_CUR, SEEK_END */
    lock.l_len = len; /* #bytes (0 means to EOF) */

    return(fcntl(fd, cmd, &amp;lock));
}

static int _os_get_dir_size(const char *pathname, long long *dirsize)
{
    char dirbuf[PATH_MAX];
    DIR *dp;
    struct dirent *ep;
    struct stat buf;

    if ((dp = opendir(pathname)) == NULL)
    {
        return(-1);
    }
    while ((ep = readdir(dp)) != NULL)
    {
        snprintf(dirbuf, PATH_MAX, &quot;%s/%s&quot;, pathname, ep-&gt;d_name);
        if (strcmp(ep-&gt;d_name, &quot;.&quot;) == 0 || strcmp(ep-&gt;d_name, &quot;..&quot;) == 0)
            continue;
        if (lstat(dirbuf, &amp;buf) != 0)
        {
            closedir(dp);
            return(-1);
        }
        if (S_ISDIR(buf.st_mode))
        {
            if (_os_get_dir_size(dirbuf, dirsize) &lt; 0)
            {
                closedir(dp);
                return(-1);
            }
        }
        else if (S_ISREG(buf.st_mode))
            *dirsize = *dirsize + buf.st_size;
    }
    if (closedir(dp) &lt; 0)
    {
        return(-1);
    }
    *dirsize = *dirsize + 3*4096; /*dir's size is 4KB, each dir has &quot;.&quot;, &quot;..&quot; and self, so 12KB.*/

    return(0);
}

static int _get_dir_file_count(const char *pathname, int *filecount)
{
    char dirbuf[PATH_MAX];
    DIR *dp;
    struct dirent *ep;
    struct stat buf;

    if ((dp = opendir(pathname)) == NULL)
    {
        return(-1);
    }
    while ((ep = readdir(dp)) != NULL)
    {
        snprintf(dirbuf, PATH_MAX, &quot;%s/%s&quot;, pathname, ep-&gt;d_name);
        if (strcmp(ep-&gt;d_name, &quot;.&quot;) == 0 || strcmp(ep-&gt;d_name, &quot;..&quot;) == 0)
            continue;
        if (lstat(dirbuf, &amp;buf) != 0)
        {
            closedir(dp);
            return(-1);
        }
        if (S_ISDIR(buf.st_mode))
        {
            if (_get_dir_file_count(dirbuf, filecount) &lt; 0)
            {
                closedir(dp);
                return(-1);
            }
        }
        else if (S_ISREG(buf.st_mode))
            (*filecount) = (*filecount) + 1;
    }
    if (closedir(dp) &lt; 0)
    {
        return(-1);
    }
    return(0);
}

pid_t os_gettid(void)
{
  return syscall(SYS_gettid);
}

/*****************************************************************************
 Prototype    : _atoul
 Description  : 10�����ַ���ת��Ϊ�޷������֡�
 Input  args  : char *str 10�����ַ���
                �����ܷ���
 Output args  : uint32_t* pulValue, ת���������
 Return value : 0 ת���ɹ�
                -1 ת��ʧ��
*****************************************************************************/
static int _atoul(char *str, uint32_t * pulValue)
{
    uint32_t ulResult=0;

    while (*str)
    {
        if (isdigit((int)*str))
        {
            /*���֧�ֵ�0xFFFFFFFF(4294967295), X * 10 + (*str)-48 &lt;= 4294967295 
              ���ԣ� X = 429496729 */
            if ((ulResult&lt;429496729) || ((ulResult==429496729) &amp;&amp; (*str&lt;'6')))
            {
                ulResult = ulResult*10 + (*str)-48;
            }
            else
            {
                *pulValue = ulResult;
                return -1;
            }
        }
        else
        {
            *pulValue=ulResult;
            return -1;
        }
        str++;
    }
    *pulValue=ulResult;
    return 0;
}

/*****************************************************************************
 Prototype    : _atoulx
 Description  : 16�����ַ���ת��Ϊ�޷������֡������16�����ַ���������ǰ׺0x
 Input  args  : char *str 16�����ַ���, ������ǰ׺0x. ��ABCDE
 Output args  : uint32_t* pulValue, ת���������
 Return value : 0 ת���ɹ�
                -1 ת��ʧ��

*****************************************************************************/
#define ASC2NUM(ch) (ch - '0')
#define HEXASC2NUM(ch) (ch - 'A' + 10)

static int _atoulx(char *str, uint32_t* pulValue)
{
    uint32_t ulResult=0;
    uint8_t ch;

    while (*str)
    {
        ch = toupper(*str);
        if (isdigit(ch) || ((ch &gt;= 'A') &amp;&amp; (ch &lt;= 'F' )))
        {
            if (ulResult &lt; 0x10000000)
            {
                ulResult = (ulResult &lt;&lt; 4) + ((ch&lt;='9')?(ASC2NUM(ch)):(HEXASC2NUM(ch)));
            }
            else
            {
                *pulValue=ulResult;
                return -1;
            }
        }
        else
        {
            *pulValue=ulResult;
            return -1;
        }
        str++;
    }
    
    *pulValue=ulResult;
    return 0;
}

/*****************************************************************************
 Prototype    : os_str2number
 Description  : 10/16 �����ַ���ת��Ϊ�޷������֡�
 Input  args  : char *str 
                   10�����ַ���, �����ܷ���
                   16�����ַ���, ����ǰ׺0x. ��0x12345678
                            
 Output args  : uint32_t* pulValue, ת���������
 Return value : ת���ɹ�:0
                ת��ʧ��:-1
*****************************************************************************/
int os_str2number(char *str , uint32_t* pulValue)
{
    /*�ж��Ƿ�16���Ƶ��ַ���*/
    if (*str == '0' &amp;&amp; (*(str+1) == 'x' || *(str+1) == 'X'))
    {
        if (*(str+2) == '\0')
        {
            return -1;
        }
        else
        {
            return _atoulx(str+2, pulValue);
        }
    }
    else
    {
        return _atoul(str, pulValue);
    }
}
</code></pre></div><div class=clear></div></div></div></article><div class=clear></div><p class=post-tags><span class="fa fa-tags">Tags:</span>
<a rel=tag href=../../../tags/clang>clang</a><div id=related-posts><div class=related-inner></div></div><section id=comments class=themeform></section><section id=comments class=themeform></section></div></div><div class="sidebar s1 collapsed" data-position=left data-layout=col-3cm data-sb-id=s1><a class=sidebar-toggle title="Expand Sidebar"><i class="fas icon-sidebar-toggle"></i></a><div class=sidebar-content><div class="sidebar-top group"><p>Follow:<ul class=social-links><li><a class=social-tooltip href=mailto: title=Email><i class="fa fa-envelope"></i></a><li><a class=social-tooltip href=//github.com/ title=GitHub><i class="fa fa-github"></i></a><li><a class=social-tooltip title="RSS Feed" aria-label="RSS Feed" href=../../../feed target=_blank style=color:#ffffffb2><i class="fa fa-rss"></i></a></ul></div><ul class="post-nav group"><li class=previous><a href=../../../language/clang/linux-lib-nanomsg/ rel=prev><i class="fa fa-chevron-left"></i><strong>Previous Post</strong>
<span>linux lib nanomsg</span></a></ul><div id=categories-2 class="widget widget_categories"><h3>分类</h3><ul><li class="cat-item cat-item-1"><a href=../../../categories/ai/>Ai</a>
<small>(7)</small><li class="cat-item cat-item-1"><a href=../../../categories/algorithm/>Algorithm</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../categories/android/>Android</a>
<small>(17)</small><li class="cat-item cat-item-1"><a href=../../../categories/ansible/>Ansible</a>
<small>(2)</small><li class="cat-item cat-item-1"><a href=../../../categories/beats/>Beats</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../categories/busybox/>Busybox</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../categories/caffe/>Caffe</a>
<small>(21)</small><li class="cat-item cat-item-1"><a href=../../../categories/cgo/>Cgo</a>
<small>(10)</small><li class="cat-item cat-item-1"><a href=../../../categories/clang/>Clang</a>
<small>(40)</small><li class="cat-item cat-item-1"><a href=../../../categories/cmd/>Cmd</a>
<small>(2)</small><li class="cat-item cat-item-1"><a href=../../../categories/cpp/>Cpp</a>
<small>(7)</small><li class="cat-item cat-item-1"><a href=../../../categories/cross_compile/>Cross_compile</a>
<small>(9)</small><li class="cat-item cat-item-1"><a href=../../../categories/css/>Css</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../categories/dart/>Dart</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../categories/database/>Database</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../categories/dataset/>Dataset</a>
<small>(2)</small><li class="cat-item cat-item-1"><a href=../../../categories/deeplearning/>Deeplearning</a>
<small>(2)</small><li class="cat-item cat-item-1"><a href=../../../categories/devops/>Devops</a>
<small>(70)</small><li class="cat-item cat-item-1"><a href=../../../categories/docker/>Docker</a>
<small>(18)</small><li class="cat-item cat-item-1"><a href=../../../categories/dts/>Dts</a>
<small>(5)</small><li class="cat-item cat-item-1"><a href=../../../categories/elasticsearch/>Elasticsearch</a>
<small>(9)</small><li class="cat-item cat-item-1"><a href=../../../categories/english/>English</a>
<small>(3)</small><li class="cat-item cat-item-1"><a href=../../../categories/freertos/>Freertos</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../categories/front-end/>Front-End</a>
<small>(20)</small><li class="cat-item cat-item-1"><a href=../../../categories/golang/>Golang</a>
<small>(136)</small><li class="cat-item cat-item-1"><a href=../../../categories/hacker/>Hacker</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../categories/hardware/>Hardware</a>
<small>(22)</small><li class="cat-item cat-item-1"><a href=../../../categories/hi3519a/>Hi3519a</a>
<small>(4)</small><li class="cat-item cat-item-1"><a href=../../../categories/hi3559/>Hi3559</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../categories/hisi/>Hisi</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../categories/hisilicon/>Hisilicon</a>
<small>(57)</small><li class="cat-item cat-item-1"><a href=../../../categories/jetson/>Jetson</a>
<small>(3)</small><li class="cat-item cat-item-1"><a href=../../../categories/js/>Js</a>
<small>(9)</small><li class="cat-item cat-item-1"><a href=../../../categories/jumpserver/>Jumpserver</a>
<small>(2)</small><li class="cat-item cat-item-1"><a href=../../../categories/kernel/>Kernel</a>
<small>(15)</small><li class="cat-item cat-item-1"><a href=../../../categories/libev/>Libev</a>
<small>(2)</small><li class="cat-item cat-item-1"><a href=../../../categories/linux/>Linux</a>
<small>(94)</small><li class="cat-item cat-item-1"><a href=../../../categories/linux-system/>Linux-System</a>
<small>(8)</small><li class="cat-item cat-item-1"><a href=../../../categories/linux-%E5%91%BD%E4%BB%A4/>Linux-命令</a>
<small>(120)</small><li class="cat-item cat-item-1"><a href=../../../categories/mac/>Mac</a>
<small>(2)</small><li class="cat-item cat-item-1"><a href=../../../categories/machinelearn/>Machinelearn</a>
<small>(3)</small><li class="cat-item cat-item-1"><a href=../../../categories/machinelearning/>Machinelearning</a>
<small>(11)</small><li class="cat-item cat-item-1"><a href=../../../categories/macos/>Macos</a>
<small>(12)</small><li class="cat-item cat-item-1"><a href=../../../categories/math/>Math</a>
<small>(7)</small><li class="cat-item cat-item-1"><a href=../../../categories/matplotlib/>Matplotlib</a>
<small>(3)</small><li class="cat-item cat-item-1"><a href=../../../categories/mpp/>Mpp</a>
<small>(12)</small><li class="cat-item cat-item-1"><a href=../../../categories/mysql/>Mysql</a>
<small>(10)</small><li class="cat-item cat-item-1"><a href=../../../categories/ncnn/>Ncnn</a>
<small>(3)</small><li class="cat-item cat-item-1"><a href=../../../categories/network/>Network</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../categories/nginx/>Nginx</a>
<small>(2)</small><li class="cat-item cat-item-1"><a href=../../../categories/nnie/>Nnie</a>
<small>(13)</small><li class="cat-item cat-item-1"><a href=../../../categories/node/>Node</a>
<small>(3)</small><li class="cat-item cat-item-1"><a href=../../../categories/numpy/>Numpy</a>
<small>(4)</small><li class="cat-item cat-item-1"><a href=../../../categories/opencpu/>Opencpu</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../categories/opencv/>Opencv</a>
<small>(10)</small><li class="cat-item cat-item-1"><a href=../../../categories/pandas/>Pandas</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../categories/platform/>Platform</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../categories/post/>Post</a>
<small>(3)</small><li class="cat-item cat-item-1"><a href=../../../categories/pyqt/>Pyqt</a>
<small>(8)</small><li class="cat-item cat-item-1"><a href=../../../categories/python/>Python</a>
<small>(31)</small><li class="cat-item cat-item-1"><a href=../../../categories/pytorch/>Pytorch</a>
<small>(6)</small><li class="cat-item cat-item-1"><a href=../../../categories/raspi/>Raspi</a>
<small>(4)</small><li class="cat-item cat-item-1"><a href=../../../categories/rk3288/>Rk3288</a>
<small>(23)</small><li class="cat-item cat-item-1"><a href=../../../categories/rk3399/>Rk3399</a>
<small>(9)</small><li class="cat-item cat-item-1"><a href=../../../categories/rtmp/>Rtmp</a>
<small>(2)</small><li class="cat-item cat-item-1"><a href=../../../categories/scikit/>Scikit</a>
<small>(3)</small><li class="cat-item cat-item-1"><a href=../../../categories/shell/>Shell</a>
<small>(3)</small><li class="cat-item cat-item-1"><a href=../../../categories/socket/>Socket</a>
<small>(5)</small><li class="cat-item cat-item-1"><a href=../../../categories/stm32/>Stm32</a>
<small>(6)</small><li class="cat-item cat-item-1"><a href=../../../categories/stm8/>Stm8</a>
<small>(9)</small><li class="cat-item cat-item-1"><a href=../../../categories/weixin/>Weixin</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../categories/windows/>Windows</a>
<small>(22)</small><li class="cat-item cat-item-1"><a href=../../../categories/work/>Work</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../categories/yolo/>Yolo</a>
<small>(16)</small><li class="cat-item cat-item-1"><a href=../../../categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/>前端技术</a>
<small>(3)</small><li class="cat-item cat-item-1"><a href=../../../categories/%E5%8D%8F%E8%AE%AE/>协议</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/>嵌入式</a>
<small>(23)</small><li class="cat-item cat-item-1"><a href=../../../categories/%E5%B7%A5%E5%85%B7/>工具</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../categories/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/>常用算法</a>
<small>(2)</small><li class="cat-item cat-item-1"><a href=../../../categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/>微服务</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../categories/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/>排列组合</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../categories/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a>
<small>(37)</small><li class="cat-item cat-item-1"><a href=../../../categories/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/>文本编辑</a>
<small>(30)</small><li class="cat-item cat-item-1"><a href=../../../categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/>正则表达式</a>
<small>(3)</small><li class="cat-item cat-item-1"><a href=../../../categories/%E7%94%9F%E6%B4%BB%E6%8A%80%E5%B7%A7/>生活技巧</a>
<small>(4)</small><li class="cat-item cat-item-1"><a href=../../../categories/%E7%A8%8B%E5%BA%8F%E5%91%98/>程序员</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/>网络安全</a>
<small>(40)</small><li class="cat-item cat-item-1"><a href=../../../categories/%E9%9B%86%E7%BE%A4%E7%9B%91%E6%8E%A7/>集群监控</a>
<small>(7)</small><li class="cat-item cat-item-1"><a href=../../../categories/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/>静态博客</a>
<small>(15)</small><li class="cat-item cat-item-1"><a href=../../../categories/%E9%AB%98%E6%95%B0/>高数</a>
<small>(2)</small></ul></div></div></div><div class="sidebar s2 collapsed" data-position=right data-layout=col-3cm data-sb-id=s2><a class=sidebar-toggle title="Expand Sidebar"><i class="fas icon-sidebar-toggle"></i></a><div class=sidebar-content><div class="sidebar-top group"><p>More</div><ul class="post-nav group"><li class=next><a href=../../../language/clang/clang-linux-epool-socket/ rel=next><i class="fa fa-chevron-right"></i><strong>Next post</strong>
<span>clang linux epool socket</span></a></ul><div id=tag_cloud-2 class="widget widget_tag_cloud"><h3>标签云</h3><div class="tagcloud post-tags"><a rel=tag href=../../../tags/ai/ class=tag-link-7 title="1 Posts">ai<small>(7)</small></a>
<a rel=tag href=../../../tags/ansible/ class=tag-link-19 title="1 Posts">ansible<small>(19)</small></a>
<a rel=tag href=../../../tags/awesome/ class=tag-link-3 title="1 Posts">awesome<small>(3)</small></a>
<a rel=tag href=../../../tags/bfc/ class=tag-link-2 title="1 Posts">bfc<small>(2)</small></a>
<a rel=tag href=../../../tags/c/ class=tag-link-5 title="1 Posts">c<small>(5)</small></a>
<a rel=tag href=../../../tags/caffe/ class=tag-link-21 title="1 Posts">caffe<small>(21)</small></a>
<a rel=tag href=../../../tags/centos7/ class=tag-link-2 title="1 Posts">centos7<small>(2)</small></a>
<a rel=tag href=../../../tags/cgo/ class=tag-link-10 title="1 Posts">cgo<small>(10)</small></a>
<a rel=tag href=../../../tags/clang/ class=tag-link-40 title="1 Posts">clang<small>(40)</small></a>
<a rel=tag href=../../../tags/cmd/ class=tag-link-2 title="1 Posts">cmd<small>(2)</small></a>
<a rel=tag href=../../../tags/cpp/ class=tag-link-7 title="1 Posts">cpp<small>(7)</small></a>
<a rel=tag href=../../../tags/cross_compile/ class=tag-link-9 title="1 Posts">cross_compile<small>(9)</small></a>
<a rel=tag href=../../../tags/css/ class=tag-link-20 title="1 Posts">css<small>(20)</small></a>
<a rel=tag href=../../../tags/css3/ class=tag-link-2 title="1 Posts">css3<small>(2)</small></a>
<a rel=tag href=../../../tags/curd/ class=tag-link-3 title="1 Posts">curd<small>(3)</small></a>
<a rel=tag href=../../../tags/curl/ class=tag-link-2 title="1 Posts">curl<small>(2)</small></a>
<a rel=tag href=../../../tags/dataset/ class=tag-link-2 title="1 Posts">dataset<small>(2)</small></a>
<a rel=tag href=../../../tags/devops/ class=tag-link-3 title="1 Posts">devops<small>(3)</small></a>
<a rel=tag href=../../../tags/docker/ class=tag-link-21 title="1 Posts">docker<small>(21)</small></a>
<a rel=tag href=../../../tags/drone/ class=tag-link-22 title="1 Posts">drone<small>(22)</small></a>
<a rel=tag href=../../../tags/dts/ class=tag-link-6 title="1 Posts">dts<small>(6)</small></a>
<a rel=tag href=../../../tags/elasticsearch/ class=tag-link-9 title="1 Posts">elasticsearch<small>(9)</small></a>
<a rel=tag href=../../../tags/emacs/ class=tag-link-12 title="1 Posts">emacs<small>(12)</small></a>
<a rel=tag href=../../../tags/encode/ class=tag-link-3 title="1 Posts">encode<small>(3)</small></a>
<a rel=tag href=../../../tags/english/ class=tag-link-8 title="1 Posts">english<small>(8)</small></a>
<a rel=tag href=../../../tags/es6/ class=tag-link-2 title="1 Posts">es6<small>(2)</small></a>
<a rel=tag href=../../../tags/etcd/ class=tag-link-4 title="1 Posts">etcd<small>(4)</small></a>
<a rel=tag href=../../../tags/flannel/ class=tag-link-2 title="1 Posts">flannel<small>(2)</small></a>
<a rel=tag href=../../../tags/git/ class=tag-link-6 title="1 Posts">git<small>(6)</small></a>
<a rel=tag href=../../../tags/github/ class=tag-link-2 title="1 Posts">github<small>(2)</small></a>
<a rel=tag href=../../../tags/golang/ class=tag-link-150 title="1 Posts">golang<small>(150)</small></a>
<a rel=tag href=../../../tags/gradle/ class=tag-link-3 title="1 Posts">gradle<small>(3)</small></a>
<a rel=tag href=../../../tags/haproxy/ class=tag-link-5 title="1 Posts">haproxy<small>(5)</small></a>
<a rel=tag href=../../../tags/hardware/ class=tag-link-22 title="1 Posts">hardware<small>(22)</small></a>
<a rel=tag href=../../../tags/hexo/ class=tag-link-3 title="1 Posts">hexo<small>(3)</small></a>
<a rel=tag href=../../../tags/hi3519a/ class=tag-link-4 title="1 Posts">hi3519a<small>(4)</small></a>
<a rel=tag href=../../../tags/hisilicon/ class=tag-link-57 title="1 Posts">hisilicon<small>(57)</small></a>
<a rel=tag href=../../../tags/html/ class=tag-link-2 title="1 Posts">html<small>(2)</small></a>
<a rel=tag href=../../../tags/http/ class=tag-link-6 title="1 Posts">http<small>(6)</small></a>
<a rel=tag href=../../../tags/hugo/ class=tag-link-14 title="1 Posts">hugo<small>(14)</small></a>
<a rel=tag href=../../../tags/imagemagick/ class=tag-link-2 title="1 Posts">imagemagick<small>(2)</small></a>
<a rel=tag href=../../../tags/ip/ class=tag-link-3 title="1 Posts">ip<small>(3)</small></a>
<a rel=tag href=../../../tags/iproute2/ class=tag-link-5 title="1 Posts">iproute2<small>(5)</small></a>
<a rel=tag href=../../../tags/iptables/ class=tag-link-17 title="1 Posts">iptables<small>(17)</small></a>
<a rel=tag href=../../../tags/javascript/ class=tag-link-19 title="1 Posts">javascript<small>(19)</small></a>
<a rel=tag href=../../../tags/jetson/ class=tag-link-3 title="1 Posts">jetson<small>(3)</small></a>
<a rel=tag href=../../../tags/jquery/ class=tag-link-12 title="1 Posts">jquery<small>(12)</small></a>
<a rel=tag href=../../../tags/js/ class=tag-link-10 title="1 Posts">js<small>(10)</small></a>
<a rel=tag href=../../../tags/jumpserver/ class=tag-link-2 title="1 Posts">jumpserver<small>(2)</small></a>
<a rel=tag href=../../../tags/jwt/ class=tag-link-3 title="1 Posts">jwt<small>(3)</small></a>
<a rel=tag href=../../../tags/kernel/ class=tag-link-15 title="1 Posts">kernel<small>(15)</small></a>
<a rel=tag href=../../../tags/kubernetes/ class=tag-link-11 title="1 Posts">kubernetes<small>(11)</small></a>
<a rel=tag href=../../../tags/libev/ class=tag-link-2 title="1 Posts">libev<small>(2)</small></a>
<a rel=tag href=../../../tags/linux/ class=tag-link-22 title="1 Posts">linux<small>(22)</small></a>
<a rel=tag href=../../../tags/linux-system/ class=tag-link-8 title="1 Posts">linux-system<small>(8)</small></a>
<a rel=tag href=../../../tags/lvs/ class=tag-link-8 title="1 Posts">lvs<small>(8)</small></a>
<a rel=tag href=../../../tags/machinelearn/ class=tag-link-3 title="1 Posts">machinelearn<small>(3)</small></a>
<a rel=tag href=../../../tags/machinelearning/ class=tag-link-11 title="1 Posts">machinelearning<small>(11)</small></a>
<a rel=tag href=../../../tags/macos/ class=tag-link-14 title="1 Posts">macos<small>(14)</small></a>
<a rel=tag href=../../../tags/makefile/ class=tag-link-2 title="1 Posts">makefile<small>(2)</small></a>
<a rel=tag href=../../../tags/mariadb/ class=tag-link-9 title="1 Posts">mariadb<small>(9)</small></a>
<a rel=tag href=../../../tags/math/ class=tag-link-7 title="1 Posts">math<small>(7)</small></a>
<a rel=tag href=../../../tags/matplotlib/ class=tag-link-3 title="1 Posts">matplotlib<small>(3)</small></a>
<a rel=tag href=../../../tags/maven/ class=tag-link-2 title="1 Posts">maven<small>(2)</small></a>
<a rel=tag href=../../../tags/meteor/ class=tag-link-7 title="1 Posts">meteor<small>(7)</small></a>
<a rel=tag href=../../../tags/ml/ class=tag-link-3 title="1 Posts">ml<small>(3)</small></a>
<a rel=tag href=../../../tags/mpp/ class=tag-link-12 title="1 Posts">mpp<small>(12)</small></a>
<a rel=tag href=../../../tags/mysql/ class=tag-link-61 title="1 Posts">mysql<small>(61)</small></a>
<a rel=tag href=../../../tags/ncnn/ class=tag-link-3 title="1 Posts">ncnn<small>(3)</small></a>
<a rel=tag href=../../../tags/netns/ class=tag-link-2 title="1 Posts">netns<small>(2)</small></a>
<a rel=tag href=../../../tags/network/ class=tag-link-2 title="1 Posts">network<small>(2)</small></a>
<a rel=tag href=../../../tags/nginx/ class=tag-link-28 title="1 Posts">nginx<small>(28)</small></a>
<a rel=tag href=../../../tags/nmap/ class=tag-link-2 title="1 Posts">nmap<small>(2)</small></a>
<a rel=tag href=../../../tags/nnie/ class=tag-link-13 title="1 Posts">nnie<small>(13)</small></a>
<a rel=tag href=../../../tags/node/ class=tag-link-4 title="1 Posts">node<small>(4)</small></a>
<a rel=tag href=../../../tags/nosql/ class=tag-link-8 title="1 Posts">nosql<small>(8)</small></a>
<a rel=tag href=../../../tags/npm/ class=tag-link-3 title="1 Posts">npm<small>(3)</small></a>
<a rel=tag href=../../../tags/numpy/ class=tag-link-4 title="1 Posts">numpy<small>(4)</small></a>
<a rel=tag href=../../../tags/oauth2/ class=tag-link-2 title="1 Posts">oauth2<small>(2)</small></a>
<a rel=tag href=../../../tags/opencv/ class=tag-link-10 title="1 Posts">opencv<small>(10)</small></a>
<a rel=tag href=../../../tags/openssl/ class=tag-link-3 title="1 Posts">openssl<small>(3)</small></a>
<a rel=tag href=../../../tags/pandoc/ class=tag-link-2 title="1 Posts">pandoc<small>(2)</small></a>
<a rel=tag href=../../../tags/php/ class=tag-link-4 title="1 Posts">php<small>(4)</small></a>
<a rel=tag href=../../../tags/post/ class=tag-link-4 title="1 Posts">post<small>(4)</small></a>
<a rel=tag href=../../../tags/powershell/ class=tag-link-2 title="1 Posts">powershell<small>(2)</small></a>
<a rel=tag href=../../../tags/prometheus/ class=tag-link-8 title="1 Posts">prometheus<small>(8)</small></a>
<a rel=tag href=../../../tags/pyqt/ class=tag-link-8 title="1 Posts">pyqt<small>(8)</small></a>
<a rel=tag href=../../../tags/python/ class=tag-link-33 title="1 Posts">python<small>(33)</small></a>
<a rel=tag href=../../../tags/pytorch/ class=tag-link-6 title="1 Posts">pytorch<small>(6)</small></a>
<a rel=tag href=../../../tags/raspi/ class=tag-link-4 title="1 Posts">raspi<small>(4)</small></a>
<a rel=tag href=../../../tags/redis/ class=tag-link-2 title="1 Posts">redis<small>(2)</small></a>
<a rel=tag href=../../../tags/reflect/ class=tag-link-3 title="1 Posts">reflect<small>(3)</small></a>
<a rel=tag href=../../../tags/responsive/ class=tag-link-2 title="1 Posts">responsive<small>(2)</small></a>
<a rel=tag href=../../../tags/restful/ class=tag-link-6 title="1 Posts">restful<small>(6)</small></a>
<a rel=tag href=../../../tags/rk3288/ class=tag-link-22 title="1 Posts">rk3288<small>(22)</small></a>
<a rel=tag href=../../../tags/rk3399/ class=tag-link-9 title="1 Posts">rk3399<small>(9)</small></a>
<a rel=tag href=../../../tags/route/ class=tag-link-2 title="1 Posts">route<small>(2)</small></a>
<a rel=tag href=../../../tags/rsync/ class=tag-link-2 title="1 Posts">rsync<small>(2)</small></a>
<a rel=tag href=../../../tags/rtmp/ class=tag-link-2 title="1 Posts">rtmp<small>(2)</small></a>
<a rel=tag href=../../../tags/scikit/ class=tag-link-3 title="1 Posts">scikit<small>(3)</small></a>
<a rel=tag href=../../../tags/scrapy/ class=tag-link-8 title="1 Posts">scrapy<small>(8)</small></a>
<a rel=tag href=../../../tags/scss/ class=tag-link-2 title="1 Posts">scss<small>(2)</small></a>
<a rel=tag href=../../../tags/sed/ class=tag-link-3 title="1 Posts">sed<small>(3)</small></a>
<a rel=tag href=../../../tags/seo/ class=tag-link-5 title="1 Posts">seo<small>(5)</small></a>
<a rel=tag href=../../../tags/shell/ class=tag-link-11 title="1 Posts">shell<small>(11)</small></a>
<a rel=tag href=../../../tags/socket/ class=tag-link-5 title="1 Posts">socket<small>(5)</small></a>
<a rel=tag href=../../../tags/sqlite/ class=tag-link-2 title="1 Posts">sqlite<small>(2)</small></a>
<a rel=tag href=../../../tags/ssh/ class=tag-link-3 title="1 Posts">ssh<small>(3)</small></a>
<a rel=tag href=../../../tags/stm32/ class=tag-link-11 title="1 Posts">stm32<small>(11)</small></a>
<a rel=tag href=../../../tags/stm8/ class=tag-link-9 title="1 Posts">stm8<small>(9)</small></a>
<a rel=tag href=../../../tags/swagger/ class=tag-link-2 title="1 Posts">swagger<small>(2)</small></a>
<a rel=tag href=../../../tags/swarm/ class=tag-link-2 title="1 Posts">swarm<small>(2)</small></a>
<a rel=tag href=../../../tags/sysbench/ class=tag-link-2 title="1 Posts">sysbench<small>(2)</small></a>
<a rel=tag href=../../../tags/sysctl/ class=tag-link-2 title="1 Posts">sysctl<small>(2)</small></a>
<a rel=tag href=../../../tags/systemctl/ class=tag-link-2 title="1 Posts">systemctl<small>(2)</small></a>
<a rel=tag href=../../../tags/tc/ class=tag-link-2 title="1 Posts">tc<small>(2)</small></a>
<a rel=tag href=../../../tags/tcpdump/ class=tag-link-2 title="1 Posts">tcpdump<small>(2)</small></a>
<a rel=tag href=../../../tags/timezone/ class=tag-link-2 title="1 Posts">timezone<small>(2)</small></a>
<a rel=tag href=../../../tags/tshark/ class=tag-link-2 title="1 Posts">tshark<small>(2)</small></a>
<a rel=tag href=../../../tags/ubuntu/ class=tag-link-2 title="1 Posts">ubuntu<small>(2)</small></a>
<a rel=tag href=../../../tags/ulimit/ class=tag-link-2 title="1 Posts">ulimit<small>(2)</small></a>
<a rel=tag href=../../../tags/vim/ class=tag-link-14 title="1 Posts">vim<small>(14)</small></a>
<a rel=tag href=../../../tags/webpack3/ class=tag-link-2 title="1 Posts">webpack3<small>(2)</small></a>
<a rel=tag href=../../../tags/windows/ class=tag-link-18 title="1 Posts">windows<small>(18)</small></a>
<a rel=tag href=../../../tags/wireshark/ class=tag-link-2 title="1 Posts">wireshark<small>(2)</small></a>
<a rel=tag href=../../../tags/xidel/ class=tag-link-2 title="1 Posts">xidel<small>(2)</small></a>
<a rel=tag href=../../../tags/xml/ class=tag-link-2 title="1 Posts">xml<small>(2)</small></a>
<a rel=tag href=../../../tags/yaml/ class=tag-link-2 title="1 Posts">yaml<small>(2)</small></a>
<a rel=tag href=../../../tags/yolo/ class=tag-link-16 title="1 Posts">yolo<small>(16)</small></a>
<a rel=tag href=../../../tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/ class=tag-link-2 title="1 Posts">微服务<small>(2)</small></a></div></div></div></div>`</div></div></div></div></div><script>var HUParams={"_disabled":[],"SmoothScroll":{"Enabled":true,"Options":{"touchpadSupport":false}},"centerAllImg":"1","timerOnScrollAllBrowsers":"1","extLinksStyle":"1","extLinksTargetExt":"1","extLinksSkipSelectors":{"classes":["btn","button"],"ids":[]},"imgSmartLoadEnabled":"1","imgSmartLoadOpts":{"parentSelectors":[".container .content",".container .sidebar","#footer","#header-widgets"],"opts":{"excludeImg":[".tc-holder-img"],"fadeIn_options":100}},"goldenRatio":"1.618","gridGoldenRatioLimit":"350","sbStickyUserSettings":{"desktop":true,"mobile":true},"isWPMobile":"","menuStickyUserSettings":{"desktop":"stick_up","mobile":"stick_up"},"isDevMode":"","ajaxUrl":"https:\/\/demo-hueman.presscustomizr.com\/?huajax=1","frontNonce":{"id":"HuFrontNonce","handle":"798e5956c0"},"userStarted":{"with":"before|1.0.4","on":{"date":"2017-05-22 16:30:22.000000","timezone_type":3,"timezone":"UTC"}},"isWelcomeNoteOn":"","welcomeContent":""};</script><script src=https://cdn.bootcss.com/lodash-compat/3.10.2/lodash.min.js></script><script src=https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js></script><script src=../../../front/js/scripts.js></script><footer id=footer><section class=container id=footer-bottom><div class=container-inner><a id=back-to-top href=#><i class="fa fa-angle-up"></i></a><div class="pad group"><div class="grid one-half"><div id=copyright><p>Copyright (c) 2017. All rights reserved. (版权所有) <a href=http://www.miitbeian.gov.cn/>鲁ICP备17074587号-1</a></div></div><div class="grid one-half last"><ul class=social-links><li><a class=social-tooltip title="On WeiBo" href=http://weibo.com/rinetd target=_blank><i class="fa fa-weibo"></i></a><li><a class=social-tooltip title="On Twitter" href=https://twitter.com/rinetd target=_blank><i class="fa fa-twitter"></i></a><li><a class=social-tooltip title="On GitHub" href=https://github.com/rinetd target=_blank><i class="fa fa-github"></i></a></ul></div></div></div></section></footer><div class=back-to-top id=back-to-top><i class="fa fa-angle-double-up"></i></div><script>$(".topbar-toggle-down").click(function(){$("#nav-topbar").css("overflow","visible");});</script><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5HM5XM2" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-5HM5XM2');</script>
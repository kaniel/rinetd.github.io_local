<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>时光小栈</title><link>/language/clang/</link><description>Recent content on 时光小栈</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><managingEditor>rinetd@163.com (rinetd)</managingEditor><webMaster>rinetd@163.com (rinetd)</webMaster><copyright>Copyright (c) 2017. All rights reserved. (版权所有) &lt;a href=&#39;http://www.miitbeian.gov.cn/&#39;&gt;鲁ICP备17074587号-1&lt;/a&gt;</copyright><lastBuildDate>Tue, 20 Oct 2020 17:02:49 +0800</lastBuildDate><atom:link href="/language/clang/feed.xml" rel="self" type="application/rss+xml"/><item><title>linux_c__attribute__pragma_pack</title><link>/language/clang/linux_c__attribute__pragma_pack/</link><pubDate>Tue, 20 Oct 2020 17:02:49 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux_c__attribute__pragma_pack/</guid><description>【区别】 pragma作用于结构内的成员变量；attribute ((aligned(n)))作用于结构体分配地址的对齐方式 和 结构体的大小。 typedef struct</description></item><item><title>libev_io_socket</title><link>/language/clang/libev/libev_io_socket/</link><pubDate>Mon, 19 Oct 2020 17:50:02 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/libev/libev_io_socket/</guid><description>/* * @author : * @date : 2014-09-04 * @desc : tiny socket server implemented by libev * to use this, you should install libev at first. * * server: just run the program * client: telnet localhost 8080 * * @refer : 1). http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod * 2). http://blog.csdn.net/lengzijian/article/details/8315133 * */ #include &amp;lt;ev.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;netinet/in.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #define PORT 8080 #define BUFFER_SIZE 1024 #define MAX_CONNECTIONS 10 struct ev_io *libevlist[MAX_CONNECTIONS] = {NULL}; void socket_accept_callback(struct ev_loop *loop, struct ev_io *watcher, int revents); void socket_read_callback(struct ev_loop *loop, struct ev_io *watcher, int revents); /* Server Client socket socket | | v v bind connect | | v v listen write | | v v accept read | | v v read close | v write | v close */ int main() { struct ev_loop *loop = ev_default_loop(0); /* socket start */ int sd; struct sockaddr_in addr; int addr_len = sizeof(addr); struct ev_io *socket_watcher = (struct ev_io*)malloc(sizeof(struct ev_io)); struct ev_timer *timeout_watcher = (struct ev_timer*)malloc(sizeof(struct ev_timer)); // socket sd = socket(PF_INET, SOCK_STREAM, 0); if (sd &amp;lt; 0) { printf(&amp;quot;socket error\n&amp;quot;); return -1; } bzero(&amp;amp;addr, sizeof(addr)); addr.</description></item><item><title>libev</title><link>/language/clang/libev/libev/</link><pubDate>Mon, 19 Oct 2020 16:01:15 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/libev/libev/</guid><description>libev教程一：libev简单入门_把握自己。-CSDN博客 libev是个非常优秀的基于事件的循环库，很多开源软件，比如nodejs就是使</description></item><item><title>linux socket keepalive</title><link>/language/clang/socket/linux-socket-keepalive/</link><pubDate>Fri, 09 Oct 2020 15:03:47 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/socket/linux-socket-keepalive/</guid><description>// int keepalive = 1; // 开启keepalive属性 // int keepidle = 60; // 如该连接在60秒内没有任何数据往来,则进行探测 // int keepinterval = 5; // 探测时发包的时间间隔为5 秒 // int keepcount</description></item><item><title>linux clib gear lib</title><link>/language/clang/linux-clib-gear-lib/</link><pubDate>Wed, 07 Oct 2020 15:57:45 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-clib-gear-lib/</guid><description>Macos 下的交叉编译 修改 build的目录下的 修改Makefile # ARCH ?= linux CROSS_PREFIX ?=arm-none-linux-gnueabi- ###</description></item><item><title>linux clock_settime</title><link>/language/clang/linux-clock_settime/</link><pubDate>Sun, 27 Sep 2020 17:40:07 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-clock_settime/</guid><description>#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;time.h&amp;gt; int main () { // 获取时间戳 time_t seconds = time(NULL); //The function time(NULL) returns the time since the Epoch (00:00:00 UTC, January 1, 1970), measured in seconds. sprintf(timestamp, &amp;quot;%-llu&amp;quot;, (unsigned long long int)seconds); time_t start_t, end_t; double diff_t; printf(&amp;quot;程序启动...\n&amp;q</description></item><item><title>linux hlist_head</title><link>/language/clang/linux-hlist_head/</link><pubDate>Fri, 25 Sep 2020 22:11:14 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-hlist_head/</guid><description>CC = gcc CFLAGXX := -Wall -g3 CFLAGXX += -fPIC INCDIR := . -I ../inc BINDIR := ../bin LIBDIR := ../lib LIB := libhlist.so TARGET = hlist_demo all: $(TARGET) SOURCE := $(wildcard *.c) $(wildcard *.cpp) OBJS := $(patsubst %.c, %.o, $(patsubst %.cpp, %.o, $(SOURCE))) LIBOBJS = $(filter-out rbtreedemo.o, $(OBJS)) %.o: %.c $(CC) $(CFLAGXX) -I $(INCDIR) -c $^ -o $@ %.o: %.cpp $(CC) $(CFLAGXX) -I $(INCDIR) -c $^ -o $@ $(TARGET): $(OBJS) @mkdir -p $(BINDIR) $(CC) $^ -o $(shell pwd)/$(BINDIR)/$(TARGET) # $(CC) -fPIC -shared $(LIBOBJS) -L $(LIBDIR) -lrbtree -o $(shell pwd)/$(LIBDIR)/$(LIB) .</description></item><item><title>linux list_head</title><link>/language/clang/linux-list_head/</link><pubDate>Fri, 25 Sep 2020 20:23:58 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-list_head/</guid><description>一起分析内核最重要的链表list_head 一、链表结构 struct list_head { struct list_head *next, *prev; }; 二、链表初始化函数 list_head 链表的初始化只是把 *next, *prev连个指针指向链表头，</description></item><item><title>linux cross libuv</title><link>/language/clang/linux-cross-libuv/</link><pubDate>Mon, 21 Sep 2020 18:01:09 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-cross-libuv/</guid><description>交叉编译 git clone https://github.com/libuv/libuv sh autogen.sh $ ./configure --prefix=/tmp/libuv_prefix --host=arm-none-linux-gnueabi CC=arm-none-linux-gnueabi-gcc $ make $ make check $ make install 2.交叉编译libuv ./autogen.sh CC=/opt/embedded/tools/bin/arm-linux-gnueabihf-gcc CFLAGS=-I/opt/embedded/platform/usr/include LDFLAGS=-L/opt/embedded/platform/usr/lib LIBS=-ludev ./configure --prefix=/opt/embedded/platform/usr/ --host=arm-linux make install</description></item><item><title>linux c string</title><link>/language/clang/linux-c-string/</link><pubDate>Mon, 07 Sep 2020 17:43:15 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-c-string/</guid><description>C语言字符串操作 · ZMonster&#39;s Blog 目录 string.h 字符串拷贝(strcpy, strncpy) strcpy strncpy 字符串比较(strcmp, strncmp, strcasecmp, strncasecmp) strcmp strncmp strcasecmp strncasecmp 字符串连接(strcat, strncat) strcat strncat 字符查找</description></item><item><title>clang mongoose</title><link>/language/clang/clang-mongoose/</link><pubDate>Mon, 20 Jul 2020 09:10:32 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/clang-mongoose/</guid><description>static void* ws_task(void* parm); int http_open(int port) { signal(SIGPIPE, SIG_IGN); system(&amp;quot;ifconfig lo 127.0.0.1&amp;quot;); s_received_signal = 0; if(pthread_create(&amp;amp;gpid, NULL, ws_task, (void*)port) != 0) { printf(&amp;quot;create ws_task error%d(%s)\n&amp;quot;,errno, strerror(errno)); return -1; } return 0; } /* * Copyright (c) 2014 Cesanta Software Limited * All rights reserved */ #include &amp;quot;mongoose.h&amp;quot; static const char *s_http_port = &amp;quot;8000&amp;quot;; static struct mg_serve_http_opts s_http_server_opts; static void handle_sum_call(struct mg_connection *nc, struct http_message *hm) { char n1[100], n2[100];</description></item><item><title>c语言位操作黑科技bithacker</title><link>/language/clang/c-bithacker/</link><pubDate>Thu, 16 Jul 2020 10:53:15 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/c-bithacker/</guid><description>http://graphics.stanford.edu/~seander/bithacks.html 1 检测两个数是否异号: int x,y; bool f= ((x^ y) &amp;lt;0); 2 取最大/小值 int x; // we want to find the minimum of x and y int y; int r; // the result goes here r = y ^ ((x ^ y) &amp;amp; -(x &amp;lt; y)); // min(x, y) r = x ^ ((x ^ y) &amp;amp;</description></item><item><title>clang linux kfifo ringbuffer</title><link>/language/clang/clang-linux-kfifo-ringbuffer/</link><pubDate>Wed, 15 Jul 2020 19:06:10 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/clang-linux-kfifo-ringbuffer/</guid><description>git@github.com:dennis-musk/ringbuffer.git Description: 环形缓冲区的实现 Others: 1.min的妙用，(验证剩余有效空间和要求要读出或者写入空间 取最小值) 2.利用unsigned int 的回环,in 和 out一</description></item><item><title>Linux网络编程--epoll模型ET触发模式之epolloneshot事件</title><link>/language/clang/socket/linux-socket-epolloneshot/</link><pubDate>Wed, 24 Jun 2020 10:16:16 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/socket/linux-socket-epolloneshot/</guid><description>Linux网络编程--epoll模型ET触发模式之epolloneshot事件 epoll模型的ET模式一般来说只触发一次，然而在并发程序中有</description></item><item><title>clang gcc</title><link>/language/clang/clang-gcc/</link><pubDate>Tue, 23 Jun 2020 19:09:22 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/clang-gcc/</guid><description>源文件经过预处理器，完成预编译，生成预编译.i文件 gcc -o hello.i -E hello.c 预编译文件经过编译器，完成编译，生成汇编.s文件 gcc -o hello.s -S hello.i 汇编文件进过汇编器，生</description></item><item><title>Epoll&#43;Timerfd实现定时器</title><link>/language/clang/socket/linux-clang-epoll-timerfd/</link><pubDate>Wed, 17 Jun 2020 19:34:29 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/socket/linux-clang-epoll-timerfd/</guid><description>timerfd的使用方法 - 简书 linux新API---timerfd的使用方法 timerfd是Linux为用户程序提供的一个定时器接口。这个</description></item><item><title>linux time elapsed</title><link>/language/clang/linux-time-elapsed/</link><pubDate>Fri, 05 Jun 2020 15:58:23 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-time-elapsed/</guid><description>long elapsed(START_TIME_TYPE start_time) { struct timeval now, res; gettimeofday(&amp;amp;now, NULL); timersub(&amp;amp;now, &amp;amp;start_time, &amp;amp;res); return (res.tv_sec)*1000 + (res.tv_usec)/1000; }</description></item><item><title>linux socket ifreq 设置IP地址</title><link>/language/clang/socket/linux-socket-ifreq/</link><pubDate>Thu, 04 Jun 2020 19:27:59 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/socket/linux-socket-ifreq/</guid><description>Linux网络接口操作之ioctl-1_接口参数 - 反刍动物 - SegmentFault 思否 strace ./ifconfig socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 5 ioctl(5, SIOCSIFADDR, {ifr_name=&amp;quot;eth0:8&amp;quot;, ifr_addr={AF_INET, inet_addr(&amp;quot;192.168.1.202&amp;quot;)}}) = 0 ioctl(5, SIOCGIFFLAGS, {ifr_name=&amp;quot;eth0:8&amp;quot;, ifr_flags=IFF_UP|IFF_BROADCAST|IFF_RUNNING|IFF_MULTICAST}) = 0 ioctl(5, SIOCSIFFLAGS, {ifr_name=&amp;quot;eth0:8&amp;quot;, ifr_flags=IFF_UP|IFF_BROADCAST|IFF_RUNNING|IFF_MULTICAST}) = 0 close(5) = 0 Complete source code: #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include</description></item><item><title>linux socket hton innet_pton</title><link>/language/clang/socket/linux-socket-hton-innet_pton/</link><pubDate>Thu, 04 Jun 2020 18:51:49 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/socket/linux-socket-hton-innet_pton/</guid><description>(1条消息)sockaddr_in与sockaddr的区别，以及对网络字节序和主机字节序的理解和转换函数_ZWE7616175的博客-CSD</description></item><item><title>linux socket udp</title><link>/language/clang/socket/linux-socket-udp/</link><pubDate>Thu, 04 Jun 2020 17:22:32 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/socket/linux-socket-udp/</guid><description>int udp_send_resp(int fd, char *ip, uint16_t port, char *in, int in_len, char *out, int *out_len) { // int sockfd; // if ((sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1) // { // perror(&amp;quot;Socket &amp;quot;); // exit(1); // } struct sockaddr_in local_addr, remote_addr; socklen_t slen = sizeof(remote_addr); remote_addr.sin_family = AF_INET; remote_addr.sin_port = htons(port); //htons(atoi(port)); remote_addr.sin_addr.s_addr = inet_addr(ip); memset(remote_addr.sin_zero, &#39;\0&#39;, sizeof(remote_addr.sin_zero)); // recvfrom 超时时间 struct timeval timeout; timeout.tv_sec = 3;</description></item><item><title>clang linux epool socket</title><link>/language/clang/clang-linux-epool-socket/</link><pubDate>Thu, 04 Jun 2020 13:39:23 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/clang-linux-epool-socket/</guid><description>第一篇 TCP server 守护进程daemonize的源码可以借鉴redis的： void daemonize(void) { //come from /redis/server.c/daemonize() int fd; if (fork() != 0) exit(0); /* parent exits */ setsid(); /* create a new session */ /* Every output goes to /dev/null. If Redis is daemonized but * the &#39;logfile&#39;</description></item><item><title>linux clang warpper utils</title><link>/language/clang/linux-clang-warpper-utils/</link><pubDate>Fri, 29 May 2020 19:05:35 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-clang-warpper-utils/</guid><description>/* * ===================================================================================== * * Filename: wrapper.h * * Description: wrapper * * Version: * Created: * Revision: none * Compiler: gcc * * Author: * Company: * Modify: * * ===================================================================================== */ #ifndef __WRAPPER_H__ #define __WRAPPER_H__ #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;errno.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;sys/stat.h&amp;gt; #include &amp;lt;time.h&amp;gt; #include &amp;lt;utime.h&amp;gt; #include &amp;lt;pthread.h&amp;gt; #include &amp;lt;semaphore.h&amp;gt; #include &amp;lt;assert.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;dirent.h&amp;gt; #include &amp;lt;sys/mman.h&amp;gt; #include &amp;lt;sys/time.h&amp;gt; #include</description></item><item><title>linux lib nanomsg</title><link>/language/clang/linux-lib-nanomsg/</link><pubDate>Mon, 25 May 2020 08:30:56 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-lib-nanomsg/</guid><description>海思移植nanomsg 修改 CMakeLists.txt 增加海思支持 ```makefile set cross-compiled system type, it&#39;s better not use the type which cmake cannot recognized. SET ( CMAKE_SYSTEM_NAME Linux ) SET ( CMAKE_SYSTEM_PROCESSOR arm ) when hislicon SDK was installed, toolchain was installed in the path as below: SET ( CMAKE_C_COMPILER /opt/hisi-linux/x86-arm/arm-himix200-linux/bin/arm-himix200-linux-gcc ) SET ( CMAKE_CXX_COMPILER /opt/hisi-linux/x86-arm/arm-himix200-linux/bin/arm-himix200-linux-g++ ) SET (</description></item><item><title>clang mini xml</title><link>/language/clang/clang-mini-xml/</link><pubDate>Tue, 12 May 2020 16:39:52 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/clang-mini-xml/</guid><description>昨天简单写了在VxWorks平台应用mini-XML库解析xml文件，以及怎样用。 https://blog.csdn.net/jianzhao6205/article/details/81638197 今天将根据函数手册写一个例程，主要功能为：使用库函数生成</description></item><item><title>clang jpeg</title><link>/language/clang/clang-jpeg/</link><pubDate>Thu, 30 Apr 2020 16:53:39 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/clang-jpeg/</guid><description>/* 这是read_picture.c 文件的代码 ，主要是对输入的图片的文件（BMP和JPEG类型）进行解码，转换成在LCD中显示的数据； 使用该程</description></item><item><title>linux mqtt</title><link>/language/clang/linux-mqtt/</link><pubDate>Tue, 14 Apr 2020 17:36:59 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-mqtt/</guid><description>将paho.mqtt.c-master.zip复制到/opt下解压 unzip paho.mqtt.c-master.zip 交叉编译： l cmake . -DPAHO_BUILD_STATIC=TRUE -DCMAKE_C_COMPILER=/opt/gcc-cross-arm/FriendlyARM/toolschain/4.4.3/bin/arm-none-linux-gnueabi-gcc -DCMAKE_CXX_COMPILER=/opt/gcc-cross-arm/FriendlyARM/toolschain/4.4.3/bin/arm-none-linux-gnueabi-g++ 其中指定是静态编译、指定交叉编译器 若开启SSL加</description></item><item><title>linux 线程自动使用资源 pthread_detach(pthread_self())</title><link>/language/clang/linux-c-pthread_detach/</link><pubDate>Mon, 06 Apr 2020 17:18:52 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-c-pthread_detach/</guid><description>// 方式1: 子线程自动释放 void* reboot_thread_func() { pthread_detach(pthread_self()); usleep(3000000);/*sleep 3s*/ system(&amp;quot;reboot&amp;quot;); pthread_exit((void *)NULL); } // 方式2: 在主线程中释放 void start_pthread(void *(*func)(void *), void *arg, int count) { int err; pthread_t tid; pthread_attr_t attr; pthread_attr_init(&amp;amp;attr); pthread_attr_setdetachstate(&amp;amp;attr, PTHREAD_CREATE_DETACHED); for (int i = 0; i &amp;lt; count; i++) { err = pthread_create(&amp;amp;tid, &amp;amp;attr, func, arg); if (err)</description></item><item><title>clang setbit clearbit</title><link>/language/clang/clang-setbit-clearbit/</link><pubDate>Tue, 17 Mar 2020 14:31:44 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/clang-setbit-clearbit/</guid><description>/include/linux/bitops.h
#define SET_BIT(x, n) (x |= (1 &amp;lt;&amp;lt; n)) #define CLR_BIT(x, n) (x &amp;amp;= ~(1 &amp;lt;&amp;lt; n)) #define GET_BIT(x, n) ((x &amp;gt;&amp;gt; n) &amp;amp; 0x01) #define set_bit(register_8, bit) (register_8 |= (1 &amp;lt;&amp;lt; bit)) #define clear_bit(register_8, bit) (register_8 &amp;amp;= ~(1 &amp;lt;&amp;lt; bit)) #define toggle_bit(register_8, bit) (register_8 ^= (1 &amp;lt;&amp;lt; bit)) #define set_bit(reg,bit) reg|=(1&amp;lt;&amp;lt;bit) //pondra en 1 el bit elegido de la variable elegida. #define clr_bit(reg,bit) reg&amp;amp;=~(1&amp;lt;&amp;lt;bit) //pondra en 0 el bit elegido de la variable elegida.</description></item><item><title>glibc printf</title><link>/language/clang/glibc-printf/</link><pubDate>Sat, 22 Feb 2020 11:25:31 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/glibc-printf/</guid><description>printf 打印指定长度字符串 转载rusty_knife 最后发布于2018-05-15 11:36:44 阅读数 4682 收藏 展开 1.原样输出字符串: printf(&amp;quot;%s&amp;quot;, str); 输出指定长度的字符串,</description></item><item><title>Linux驱动中的 wait_event_interruptible 与 wake_up_interruptible 深度理解</title><link>/language/clang/linux-wait_event_interruptible/</link><pubDate>Tue, 11 Feb 2020 11:44:43 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-wait_event_interruptible/</guid><description>linux字符驱动之中断按键_lwj103862095的专栏-CSDN博客 等待队列： 在 Linux 驱动程序设计中，可以使用等待队列来实现进程的阻塞. 等</description></item><item><title>linux c crypto</title><link>/language/clang/linux-c-crypto/</link><pubDate>Wed, 05 Feb 2020 19:14:22 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-c-crypto/</guid><description>https://gist.github.com/neikeq/d6d00bd24db606dd0b86
#ifndef _DEFINE_H_ #define _DEFINE_H_ #define OK 0 #define NOK -1 #define YES 1 #define NO 0 #define MAX_SERVER 50 #define MAX_PLAYER 500 #define MAX_ROOM 150 #define MAX_TEAM 150 #define MAX_VIEWER 4 #define MAX_ATHLETE 10 #define MAX_ITEM 70 #define MAX_LEVEL 50 #define MAX_LEVEL_SECTION (MAX_LEVEL/5)+1 #define MAX_TIP 50 #define MAX_MISSION 46 #define MAX_HOLIDAY 50 #define MAX_CARDSKILL 3 #define MAX_CARDRANK 4 #define MAX_BUDDY 30 #define MAX_BLACKLIST 30 #define EMBLEM_TYPE_GOLD 604101101 #define EMBLEM_TYPE_SILVER 604101102 #define MAX_PATH 255 #define GAME_PLAY_TIME 300 #define ID_NAME_SIZE (15 * 2) + 1 #define PLAYER_NAME_SIZE (7 * 2) + 1 #define OBJECT_NAME_SIZE (20 * 2) + 1 #define SERVER_NAME_SIZE (15 * 2) + 1 #define TITLE_NAME_SIZE (23 * 2) + 1 #define CLUB_NAME_SIZE (10 * 2) + 1 #define PLAYER_MENT_SIZE (22 * 2) + 1 #define MESSAGE_SIZE (40 * 2) + 1 #define PASS_SIZE (10 * 2) + 1 #define LOGIN_PASS_SIZE (32 * 2) + 1 #define TIP_SIZE (60 * 2) + 1 #define MISSTION_TEXT_SIZE (60 * 2) + 1 #define MAX_MUSIC_COUNT 3 #define MAX_EQUIP 17 #define MAX_FACULTY 130 #define MAX_CHARACTER 3 #define MAX_INVEN 80 #define MAX_SKILL 50 #define MAX_CEREMONY 5 #define MAX_CARD 100 #define MAX_SCHEDULE_LIST 10 #define MAX_BUDDY_LIST 10 #define MAX_ITEM_LIST 10 #define MAX_ITEM_LIST 10 #define MAX_TRAINING_LIST 10 #define MAX_CEREMONEY_LIST 5 #define MAX_SKILL_LIST 50 #define MAX_QUEST_LIST 10 #define MAX_CARD_LIST 30 #define PACKET_SIZE 2048 #define HEAD_SIZE (int)sizeof(Header) #define IP_SIZE 20 #define TEAM_SIZE 6 #define ITEM_OPTION_SIZE 5 #define SLOT_SIZE 4 #define BASE_CHARACTER_SIZE 1 #define BASE_INVEN_SIZE 20 #define BASE_SKILL_SIZE 8 #define ITEM1_MIX_SIZE 5 #define ITEM2_MIX_SIZE 5 #define CARD_MIX_SIZE 12 #define LIST5_SIZE 5 #define LIST6_SIZE 6 #define LIST8_SIZE 8 #define LIST10_SIZE 10 #define TEAM_SIZE 6 #define SHOP_BIT_EXIST 0 #define SHOP_BIT_NONE 1 #define ITEM_FACE 100 #define ITEM_HAIR 101 #define ITEM_SHIRTS 102 #define ITEM_PANTS 103 #define ITEM_GLOVE 104 #define ITEM_SHOES 105 #define ITEM_DIGIT 1000000 #define OPTION_DIGIT 100000 #define POSITION_NONE 0 #define POSITION_ALL 1 #define POSITION_FW 10 #define POSITION_ST 11 #define POSITION_CF 12 #define POSITION_WF 13 #define POSITION_SS 14 #define POSITION_FW_RANGE 4 #define POSITION_MF 20 #define POSITION_AM 21 #define POSITION_CM 22 #define POSITION_SM 23 #define POSITION_DM 24 #define POSITION_MF_RANGE 4 #define POSITION_DF 30 #define POSITION_SW 31 #define POSITION_CB 32 #define POSITION_SB 33 #define POSITION_DF_RANGE 3 #define POSITION_GK 40 #define POSITION_BG 50 #define AUTO_FACULTY_LEVEL1 10 #define AUTO_FACULTY_LEVEL2 20 #define MAX_AI_COSTUME 61 #define PC_EXIT01 1 #define PC_EXIT02 2 #define PC_EXIT03 3 #define PC_EXIT04 4 #define PC_EXIT11 11 #define PC_EXIT12 12 #define PC_EXIT20 20 #define PC_EXIT21 21 #define PC_EXIT22 22 #define PC_EXIT30 30 #define PC_EXIT31 31 #define PC_EXIT32 32 #define PC_EXIT33 33 #define PC_EXIT90 90 #define ROOT2 1.</description></item><item><title>pthread 使用入门</title><link>/language/clang/linux-c-pthread/</link><pubDate>Wed, 05 Feb 2020 17:15:38 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-c-pthread/</guid><description>POSIX 线程（POSIX threads），简称 Pthreads，是线程的 POSIX 标准。该标准定义了创建和操纵线程的一整套 API。在类 Unix 操作系统（Unix</description></item><item><title>linux fopen open</title><link>/language/clang/linux-fdopen-fileno/</link><pubDate>Thu, 19 Dec 2019 14:17:10 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-fdopen-fileno/</guid><description>每天进步一点点——Linux中的文件描述符与打开文件之间的关系_linux,文件描述符_Cynric 的博客-CSDN博客 1. 来源 从来源的角度看</description></item><item><title>linux mmap</title><link>/language/clang/linux-mmap/</link><pubDate>Thu, 19 Dec 2019 13:41:04 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-mmap/</guid><description>由于在应用层没法用writel，所以参考himm.c写了一个设置，代码如下： void uart1_rtsn_high(void) { void * pMem = NULL; pMem = memmap(0x201d0010, DEFAULT_MD_LEN); (U32)pMem = 0xff; } 文件名是rs485.c —————</description></item><item><title>linux fopen fwrite fflush fsync</title><link>/language/clang/linux-fopen-fwrite-fflush-fsync/</link><pubDate>Thu, 19 Dec 2019 11:28:34 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-fopen-fwrite-fflush-fsync/</guid><description>int readFileList(char *path) { DIR *dir = NULL; struct dirent *ptr = NULL; if ((dir = opendir(path)) == NULL) { fprintf(stderr, &amp;quot;Open dir error...\n&amp;quot;); return 1; } while ((ptr = readdir(dir)) != NULL) { if (ptr-&amp;gt;d_name[0] == &#39;.&#39;) // . .. .svn { continue; } else if (ptr-&amp;gt;d_type == DT_REG) // file { filter_elf(path, ptr-&amp;gt;d_name); } else if (ptr-&amp;gt;d_type == DT_LNK) // link file { //printf(&amp;quot;DT_LNK:%s/%s\n&amp;quot;, path, ptr-&amp;gt;d_name); } else</description></item><item><title>Linux下头文件以及库 编译链接运行时的搜寻路径顺序</title><link>/language/clang/make-gcc-include-order/</link><pubDate>Wed, 11 Dec 2019 11:17:08 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/make-gcc-include-order/</guid><description>Linux下头文件以及库 编译链接运行时的搜寻路径顺序 - ltshan139的专栏 LIBRARY_PATH 环境变量用于在程序编译期间查找动态链接库时指定查找共享库的路</description></item><item><title>clang define extern c</title><link>/language/clang/clang-define-extern-c/</link><pubDate>Wed, 11 Dec 2019 10:23:02 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/clang-define-extern-c/</guid><description>extern &amp;quot;C&amp;quot; 在C/C++中的用法 无论是C++调用C api 还是C调用C++ API， 必须先在API所对应得头文件对API进行 extern &amp;quot;C&amp;quot;声明</description></item><item><title>clang 3维数组的初始化</title><link>/language/clang/clang-array/</link><pubDate>Wed, 11 Dec 2019 10:20:42 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/clang-array/</guid><description>int a[2][3][4] = { {{1,2,3,4},{1,2,3,4},{1,2,3,4}}, {{5,6,7,8},{5,6,7,8},{5,6,7,8}} }; 注意初始化要先从最外围开始。</description></item><item><title>linux string strnicmp</title><link>/language/clang/linux-string-strnicmp/</link><pubDate>Thu, 28 Nov 2019 15:06:06 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-string-strnicmp/</guid><description>char pDescr[100] strcpy(pDescr, &amp;quot;v=0\r\n&amp;quot;); strcat(pDescr, &amp;quot;o=-&amp;quot;); strcat(pDescr, pSdpId); #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; void main() { char *input=&amp;quot;I am OldWolf&amp;quot;; char *str=&amp;quot;I am Oldwolf&amp;quot;; int cmp; printf(&amp;quot;原字符串分别为：\n%s\n%s\n\n&amp;quot;,str1,</description></item><item><title>linux string strsep</title><link>/language/clang/linux-string-strsep/</link><pubDate>Thu, 28 Nov 2019 14:40:23 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-string-strsep/</guid><description>C语言的 strtok 和 strsep 函数的使用 strsep()相比strtok()来说，它是可重入(reentrant)的（更安全），且速度更快。 /* lib/string.c */ strse</description></item><item><title>c http post file</title><link>/language/clang/c-http-post-file/</link><pubDate>Fri, 15 Nov 2019 17:20:47 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/c-http-post-file/</guid><description>基于C语言实现HTTP POST 表单形式上传文件 - fangye945a的博客 - CSDN博客 all: gcc -pthread -I. http_post.c clean: rm -f a.out POST /Server/interface_picture_upload.action?appid=wmj_BZ2WeU7K1iP&amp;amp;appsecret=MXkMcT43JsIgAwBwVJ30EbA2ovIcpfCQ&amp;amp;sn=0 HTTP/1.1 Host: test.inteink.com User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:59.0) Gecko/20100101 Firefox/59.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip,</description></item><item><title>gcc</title><link>/language/clang/gcc/</link><pubDate>Thu, 23 May 2019 10:58:04 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/gcc/</guid><description>linux ldconfig命令,环境变量文件配置详解 - winycg的博客 - CSDN博客 --start-group和--end-group 解决 ld 链接 error</description></item><item><title>c void</title><link>/language/clang/c-void/</link><pubDate>Wed, 22 May 2019 19:17:38 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/c-void/</guid><description>C语言中void和NULL - ascend的专栏 - CSDN博客 #define NULL ((void *)0) void的作用 a. 对函数参数的限定：当不需要传入参数时，即 function (void); b. 对函数返回</description></item><item><title>Linux内核中的offsetof和container_of</title><link>/language/clang/c-container_of/</link><pubDate>Sat, 20 Apr 2019 09:26:47 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/c-container_of/</guid><description>关于list_for_each_entry相关函数 - 简书 链表是内核最经典的数据结构之一，说到链表就不得不提及内核最经典 (没有之一) 的宏con</description></item><item><title>c位操作</title><link>/language/clang/c-bit-operate/</link><pubDate>Fri, 19 Apr 2019 16:29:17 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/c-bit-operate/</guid><description>bitops.h 位运算技巧 记得iOS总有一道面试题在不使用第三个变量的情况下交换两个变量的值，这里用到异或的上面加解密中的特性。我有x、y两个个变量，做如</description></item><item><title>c语言define的使用方法总结</title><link>/language/clang/c-define/</link><pubDate>Fri, 19 Apr 2019 11:13:07 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/c-define/</guid><description>#和##有什么区别？ 他们都不会将参数进行展开 1. # 的作用是将宏定义中的参数转换成“字符串” #define STR(x) #x =&amp;gt; a=1; STR(a) &amp;quot;a&amp;quot; 2. ##的作用是将宏定义中的参数变成字符</description></item><item><title>C语言中的指针</title><link>/language/clang/c-point/</link><pubDate>Sat, 13 Apr 2019 10:15:58 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/c-point/</guid><description>二级指针传参数 - 简书 说透一级指针和二级指以及(void)&amp;amp;在双链表中的应用 注意char*是字符串指针，需要改变其对应的变量必须用地址</description></item><item><title>C语言的奇技淫巧</title><link>/language/clang/c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/</link><pubDate>Tue, 29 Mar 2016 21:25:45 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/</guid><description>位运算技巧 求结构体成员的偏移 #define OFFSET(structure, member) ((int) &amp;amp;((structure *)0)-&amp;gt;member) c语言 x[n] 相当于 *((x)+(n)) 所以 x[n] 和 n[x] 结果一样 编译期类型检查: (void)(&amp;amp;a == &amp;amp;b)检测a和b是不是同一类型，不是同</description></item><item><title/><link>/language/clang/libev/libev_io/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/libev/libev_io/</guid><description>ev_io ev_io用于句柄可读写的检测，如果你有如下需求，你就可能需要用到它。
在网络对端发送的数据已到达本机时，及时读取socket中的数据
管道中已经写满数据，在管道可写时及时写入数据
可用函数如下:
ev_io_init (ev_io *, callback, int fd, int events); ev_io_set (ev_io *, int fd, int events); void ev_io_start(EV_P_ ev_io *w) EV_THROW; void ev_io_stop(EV_P_ ev_io *w) EV_THROW; 符号定义:
#if EV_MINPRI == EV_MAXPRI # define EV_DECL_PRIORITY #elif !defined (EV_DECL_PRIORITY) # define EV_DECL_PRIORITY int priority; #endif #ifndef EV_COMMON # define EV_COMMON void *data; #endif #ifndef EV_CB_DECLARE # define EV_CB_DECLARE(type) void (*cb)(EV_P_ struct type *w, int revents); #endif #define EV_WATCHER(type) \ int active; /* private */ \ int pending; /* private */ \ EV_DECL_PRIORITY /* private */ \ EV_COMMON /* rw */ \ EV_CB_DECLARE (type) /* private */ typedef struct ev_watcher_list { EV_WATCHER_LIST (ev_watcher_list) } ev_watcher_list; #define EV_WATCHER_LIST(type) \ EV_WATCHER (type) \ struct ev_watcher_list *next; /* private */ typedef struct ev_io { EV_WATCHER_LIST (ev_io) int fd; /* ro */ int events; /* ro */ } ev_io; 上面符号定义有点多，gcc -E xxx.</description></item><item><title/><link>/language/clang/libev/libev_periodic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/libev/libev_periodic/</guid><description>ev_periodic Libev源码分析05：Libev中的绝对时间定时器 - gqtc - 博客园
ev_periodic和ev_timer也是一种定时器，有时它们是可以通用的，有时也是有区别的。ev_timer不适用于长时间的超时，比如一周后、一个月后，它在一定程度上有延时的风险，回调的超时越大，这个时间就越不准。其实从命名上也能看出区别，ev_periodic适用于周期性的回调，比如每天早上5点需要清理冗余的数据。ev_periodic它是根据时刻来回调的，也就是说，只有本地时钟刚好走到了那个点才会触发回调。
考虑一下特殊情况，如果设置了10分钟后的回调，再把本地时钟调到去年，那么这个回调就要等1年的时间了。如果把时钟往后调呢？这个回调就会立即触发。
可使用的函数如下:
ev_periodic_init(ev_periodic *, callback, ev_tstamp offset, ev_tstamp interval, reschedule_cb) ev_periodic_set(ev_periodic *, ev_tstamp offset, ev_tstamp interval, reschedule_cb) ev_periodic_again(loop, ev_periodic *) ev_tstamp ev_periodic_at(ev_periodic *) 符号定义:
typedef double ev_tstamp; #if EV_MINPRI == EV_MAXPRI # define EV_DECL_PRIORITY #elif !defined (EV_DECL_PRIORITY) # define EV_DECL_PRIORITY int priority; #endif #ifndef EV_COMMON # define EV_COMMON void *data; #endif #ifndef EV_CB_DECLARE # define EV_CB_DECLARE(type) void (*cb)(EV_P_ struct type *w, int revents); #endif #define EV_WATCHER(type) \ int active; /* private */ \ int pending; /* private */ \ EV_DECL_PRIORITY /* private */ \ EV_COMMON /* rw */ \ EV_CB_DECLARE (type) /* private */ #define EV_WATCHER_TIME(type) \ EV_WATCHER (type) \ ev_tstamp at; /* private */ #ifdef __cplusplus # define EV_CPP(x) x # if __cplusplus &amp;gt;= 201103L # define EV_THROW noexcept # else # define EV_THROW throw () # endif #else # define EV_CPP(x) # define EV_THROW #endif typedef struct ev_periodic { EV_WATCHER_TIME (ev_periodic) ev_tstamp offset; /* rw */ ev_tstamp interval; /* rw */ ev_tstamp (*reschedule_cb)(struct ev_periodic *w, ev_tstamp now) EV_THROW; /* rw */ } ev_periodic; #sample1</description></item><item><title/><link>/language/clang/libev/libev_signal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/libev/libev_signal/</guid><description>ev_signal ev_signal就是信号的管理器，作用同signal()或sigaction()函数差不多，就是在接收到信号的时候执行注册的回调。
可使用的函数:
ev_signal_init (ev_signal *, callback, int signum) ev_signal_set (ev_signal *, int signum) 符号定义:
#define EV_WATCHER(type) \ int active; /* private */ \ int pending; /* private */ \ EV_DECL_PRIORITY /* private */ \ EV_COMMON /* rw */ \ EV_CB_DECLARE (type) /* private */ #define EV_WATCHER_LIST(type) \ EV_WATCHER (type) \ struct ev_watcher_list *next; typedef struct ev_signal { EV_WATCHER_LIST (ev_signal) int signum; /* ro */ } ev_signal; sample1 先了解一下基本的使用方法。下面的例子，每次收到信号SIGUSR1就会调用sigint_cb函数(可以用kill -SIGUSR1 pid来发信号)，进程在收到信号之后不会终止，处理完回调仍然在运行。</description></item><item><title/><link>/language/clang/libev/libev_timer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/libev/libev_timer/</guid><description>ev_timer ev_timer就是定时器，如果你有如下需求，你就可能需要用到它。
n秒之后需要调用某个函数(如:tcp连接超时断开连接)
每隔y秒就调用某个函数(如:定时清理资源)
可使用的函数如下:
ev_timer_init (timer, callback, 60., 0.); ev_timer_start (loop, timer); ev_timer_stop (loop, timer); ev_timer_set (timer, 60., 0.); ev_timer_start (loop, timer); ev_timer_remaining (loop, ev_timer *) 符号定义:
typedef double ev_tstamp; #if EV_MINPRI == EV_MAXPRI # define EV_DECL_PRIORITY #elif !defined (EV_DECL_PRIORITY) # define EV_DECL_PRIORITY int priority; #endif #ifndef EV_COMMON # define EV_COMMON void *data; #endif #ifndef EV_CB_DECLARE # define EV_CB_DECLARE(type) void (*cb)(EV_P_ struct type *w, int revents); #endif #define EV_WATCHER(type) \ int active; /* private */ \ int pending; /* private */ \ EV_DECL_PRIORITY /* private */ \ EV_COMMON /* rw */ \ EV_CB_DECLARE (type) /* private */ #define EV_WATCHER_TIME(type) \ EV_WATCHER (type) \ ev_tstamp at; /* private */ typedef struct ev_timer { EV_WATCHER_TIME (ev_timer) ev_tstamp repeat; /* rw */ } ev_timer; sample1 这个例子有一个循环loop，等待了2.</description></item><item><title>C语言深度解剖 (一)</title><link>/language/clang/c-sizeofsignedunsignedvoid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/c-sizeofsignedunsignedvoid/</guid><description>前言 C语言的水深不见底，好在一些前辈们已经将很多雷区探了一遍 这里分享一下我在学习 《C语言深度解剖》 过程中的一些笔记和心得 概要 TOC {:toc} sizeof sizeo</description></item><item><title>C语言深度解剖 (三)</title><link>/language/clang/c-typedef/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/c-typedef/</guid><description>前言 C语言的水深不见底，好在一些前辈们已经将很多雷区探了一遍 这里分享一下我在学习 《C语言深度解剖》 过程中的一些笔记和心得 概要 TOC {:toc} typedef typedef 从字面上</description></item><item><title>C语言深度解剖 (二)</title><link>/language/clang/c-constvolatileunionenum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/c-constvolatileunionenum/</guid><description>前言 C语言的水深不见底，好在一些前辈们已经将很多雷区探了一遍 这里分享一下我在学习 《C语言深度解剖》 过程中的一些笔记和心得 概要 TOC {:toc} const 准确来说 const</description></item><item><title>C语言深度解剖 (五)</title><link>/language/clang/-c%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%89%96-%E4%BA%94/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/-c%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%89%96-%E4%BA%94/</guid><description>前言 C语言的水深不见底，好在一些前辈们已经将很多雷区探了一遍 这里分享一下我在学习 《C语言深度解剖》 过程中的一些笔记和心得 概要 TOC {:toc} 数组参数与指</description></item><item><title>C语言深度解剖 (四)</title><link>/language/clang/-c%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%89%96-%E5%9B%9B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/-c%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%89%96-%E5%9B%9B/</guid><description>前言 C语言的水深不见底，好在一些前辈们已经将很多雷区探了一遍 这里分享一下我在学习 《C语言深度解剖》 过程中的一些笔记和心得 概要 TOC {:toc} 指针与数组 #include</description></item></channel></rss>
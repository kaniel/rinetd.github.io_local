<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>时光小栈</title><link>/hardware/kernel/</link><description>Recent content on 时光小栈</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><managingEditor>rinetd@163.com (rinetd)</managingEditor><webMaster>rinetd@163.com (rinetd)</webMaster><copyright>Copyright (c) 2017. All rights reserved. (版权所有) &lt;a href=&#39;http://www.miitbeian.gov.cn/&#39;&gt;鲁ICP备17074587号-1&lt;/a&gt;</copyright><lastBuildDate>Tue, 24 Nov 2020 15:03:00 +0800</lastBuildDate><atom:link href="/hardware/kernel/feed.xml" rel="self" type="application/rss+xml"/><item><title>linux kernel timer</title><link>/hardware/kernel/linux-kernel-timer/</link><pubDate>Tue, 24 Nov 2020 15:03:00 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/kernel/linux-kernel-timer/</guid><description>linux驱动之定时器的使用 被文章摘自一下几位网友。非常感谢他们。 http://blog.sina.com.cn/s/blog_57330c3401011cq3.html Linux的内核中定义了一个定时器的结构： #include struct timer_list { struct list_head list; unsigned long expires; //定时器</description></item><item><title>linux kernel usb suspended</title><link>/hardware/kernel/linux-kernel-usb-suspended/</link><pubDate>Sat, 01 Aug 2020 10:51:16 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/kernel/linux-kernel-usb-suspended/</guid><description>Suspend USB devices (turn the power off) EC20 USB 1-1 注意。这个答案中的信息与旧的内核相关（最多2.6.32）。有关新内核的信息，请参阅tlwhitec。 disable external wake-up; do this only once echo disabled &amp;gt;</description></item><item><title>启用linux内核对usb摄像头的支持</title><link>/hardware/kernel/linux-kernel-uvc-usb-camera/</link><pubDate>Sat, 29 Feb 2020 20:02:14 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/kernel/linux-kernel-uvc-usb-camera/</guid><description>1、配置内核；允许如下命令配置linux内核 make menuconfig 2、启用摄像头支持，最后一步时根据自己需要进行选择摄像头配置。 Device Drivers ---&amp;gt; &amp;lt;&amp;gt; Multimedia support ---&amp;gt; [] Video capture adapters ---&amp;gt; [] V4L USB</description></item><item><title>linux driver power sleep</title><link>/hardware/kernel/linux-driver-power-sleep/</link><pubDate>Sat, 22 Feb 2020 10:27:04 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/kernel/linux-driver-power-sleep/</guid><description>wakeup events framework Linux 设备驱动 device wakeup 功能 &amp;amp; wake_lock电源锁 pm_stay_awake()和pm_relax()的意义_移动开发_chizhang78</description></item><item><title>Linux RTC驱动模型分析之rtc-sysfs.c</title><link>/hardware/kernel/linux-kernel-rtc-sysfs/</link><pubDate>Sat, 22 Feb 2020 10:21:58 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/kernel/linux-kernel-rtc-sysfs/</guid><description>Linux RTC驱动模型分析之rtc-sysfs.c - 嵌入式Linux中文站 linux RTC 驱动模型分析 RTC(real time clock)实时时钟，主要作用是给Linux系统提供</description></item><item><title>Linux驱动：module_platform_driver</title><link>/hardware/kernel/linux-platform-module_platform_driver/</link><pubDate>Mon, 09 Dec 2019 19:45:38 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/kernel/linux-platform-module_platform_driver/</guid><description>该宏是用来定义驱动的入口函数 module_platform_driver(hibvt_i2c_driver); static SIMPLE_DEV_PM_OPS(hibvt_i2c_dev_pm, hibvt_i2c_suspend, hibvt_i2c_resume); static const struct of_device_id hibvt_i2c_match[] = { { .compatible = &amp;quot;hisilicon,hibvt-i2c&amp;quot;}, { .compatible = &amp;quot;hisilicon,hi3516cv300-i2c&amp;quot;}, { .compatible = &amp;quot;hisilicon,hi3536dv100-i2c&amp;quot;}, {}, }; MODULE_DEVICE_TABLE(of, hibvt_i2c_match); static struct platform_driver hibvt_i2c_driver = { .driver = { .name = &amp;quot;hibvt-i2c&amp;quot;, .of_match_table = hibvt_i2c_match, .pm = &amp;amp;hibvt_i2c_dev_pm, }, .probe = hibvt_i2c_probe, .remove = hibvt_i2c_remove, }; module_platform_driver(hibvt_i2c_driver); /*</description></item><item><title>linux i2c</title><link>/hardware/kernel/linux-i2c/</link><pubDate>Sat, 23 Nov 2019 16:17:55 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/kernel/linux-i2c/</guid><description>Linux驱动之I2C设备驱动完全解析 - 夜黯竹亭风的博客 - CSDN博客 如何生成 /dev/i2c-0 i2c-dev.c /********************************************************************** /dev/i2c-*不见了 说明： 能在他的系统中没找到/d</description></item><item><title>Linux 驱动头文件说明</title><link>/hardware/kernel/linux-include/</link><pubDate>Sat, 23 Nov 2019 12:00:12 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/kernel/linux-include/</guid><description>#include &amp;lt;fcntl.h&amp;gt; // fcntl() #include &amp;lt;unistd.h&amp;gt; // read() / write() #include &amp;lt;sys/stat.h&amp;gt; // mkfifo() #include &amp;lt;string.h&amp;gt; // strncpy() / strlen() #include &amp;lt;stdlib.h&amp;gt; // malloc() / free() #include &amp;lt;sys/socket.h&amp;gt; // socket() / bind() / listen() / connect() / send() #include &amp;lt;sys/un.h&amp;gt; // sockaddr_un #include &amp;lt;netinet/in.h&amp;gt; /* For htonl and ntohl */ #include &amp;lt;errno.h&amp;gt; // errno #include &amp;lt;linux/***.h&amp;gt; //是在linux-2.6.</description></item><item><title>linux readl writel</title><link>/hardware/kernel/linux-readl-writel/</link><pubDate>Sat, 23 Nov 2019 11:49:50 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/kernel/linux-readl-writel/</guid><description>#include &amp;lt;linux/io.h&amp;gt; // #include &amp;lt;asm/io.h&amp;gt; void writel (unsigned char data , unsigned short addr ) unsigned char readl (unsigned int addr ) //从内存映射的 I/O 空间读取数据,readl 从 I/O 读取 32 位数据 ( 4 字节 )。 内核里面writel(re</description></item><item><title>linux bitops</title><link>/hardware/kernel/linux-bitops/</link><pubDate>Sat, 23 Nov 2019 11:34:11 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/kernel/linux-bitops/</guid><description>bitops.h GENMASK_ULL 和GENMASK，产生high和low之间全是1的值 GENMASK_ULL(39, 21) 这行执行后的值等于0x000000ffffe00000， 简单说就是将39和21 之</description></item><item><title>linux iio</title><link>/linux/kernel/linux-iio/</link><pubDate>Sat, 12 Oct 2019 17:16:40 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/kernel/linux-iio/</guid><description>直接读取sys 以下方式使用软件写入start的方式，每次触发一次采样 cat /sys/bus/iio/devices/iio:device0/xxx_raw 通过外部硬件trigger读取 这种方式下，每次ADC的触发都需要AD</description></item><item><title>linux adc</title><link>/linux/kernel/linux-adc/</link><pubDate>Sat, 12 Oct 2019 16:01:03 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/kernel/linux-adc/</guid><description>linux adc读取应用 - 简书 linux adc读取应用 1原理图 image.png 2设备节点 image.png 3控制代码 #include &amp;lt;stdio.h&amp;gt; //文件操作函数头文件 #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;sys/stat.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; int main(int argv,char *argc[]) { char *adc_path=&amp;quot;/dev/adc&amp;quot;; int fd,len; char</description></item><item><title>linux device</title><link>/linux/kernel/linux-device/</link><pubDate>Fri, 11 Oct 2019 17:50:45 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/kernel/linux-device/</guid><description>(8条消息)linux设备模型六（device细节） - To_run_away的博客 - CSDN博客 总线驱动设备 - 简书</description></item><item><title>linux jiffies</title><link>/linux/kernel/linux-jiffies/</link><pubDate>Fri, 11 Oct 2019 16:13:27 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/kernel/linux-jiffies/</guid><description>linux内核中jiffies的回绕问题_网络_yuanlulu的博客 深度学习开发者-CSDN博客 static inline presstype buttons_getpresstype(uint16_t downtime) { uint16_t now = buttons_gettime(); uint16_t timedown; // 解决uint16</description></item><item><title>rtc wakeup</title><link>/hardware/rk3399/rtc-wakeup/</link><pubDate>Thu, 10 Oct 2019 18:35:41 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/rk3399/rtc-wakeup/</guid><description>Linux RTC驱动模型分析之rtc-sysfs.c - 嵌入式Linux中文站 rtcwake: /dev/rtc0 not enabled for wakeup events - Raspberry Pi Forums (8条消息)Linux时间系统之RTC时间 - u01</description></item><item><title>Linux电源管理-Linux Regulator Framework代码分析</title><link>/linux/kernel/linux-kernel-regulator/</link><pubDate>Fri, 30 Aug 2019 15:29:55 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/kernel/linux-kernel-regulator/</guid><description>Linux 内核 regulator 机制 Linux电源管理-Linux Regulator Framework代码分析 本文链接：https://blog.csdn.net/longwang</description></item><item><title>devm_xxx机制</title><link>/linux/kernel/devm_xxx/</link><pubDate>Mon, 26 Aug 2019 21:56:34 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/kernel/devm_xxx/</guid><description>前言 devm是内核提供的基础机制，用于方便驱动开发者所分配资源的自动回收。参考内核文档devres.txt。总的来说，就是驱动开发者只需要调</description></item><item><title>Linux I-O Scheduler 调度器优化系统性能</title><link>/hardware/kernel/scheduler/</link><pubDate>Sat, 14 Apr 2018 14:35:28 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/kernel/scheduler/</guid><description>本文转自：调整 Linux I/O 调度器优化系统性能 ###背景 查看RocketMQ文档的过程中，提到了通过修改IO调度算法来提高RocketMQ的性能。网上</description></item><item><title>linux零拷贝原理</title><link>/hardware/kernel/zero-copy/</link><pubDate>Sat, 14 Apr 2018 11:25:30 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/kernel/zero-copy/</guid><description>linux零拷贝原理 本文翻译自:http://www.linuxjournal.com/article/6345 本文解释了Linux的零拷贝</description></item><item><title>Linux 堆栈ebp esp详解</title><link>/hardware/kernel/linux-ebp-esp/</link><pubDate>Wed, 14 Mar 2018 13:18:19 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/kernel/linux-ebp-esp/</guid><description>栈帧%ebp,%esp详解 首先应该明白，栈是从高地址向低地址延伸的。每个函数的每次调用，都有它自己独立的一个栈帧，这个栈帧中维持着所需要的各</description></item><item><title>Linux命令 strace</title><link>/hardware/kernel/linux-strace/</link><pubDate>Fri, 19 Jan 2018 16:46:14 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/kernel/linux-strace/</guid><description>strace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文</description></item><item><title>gdb使用笔记</title><link>/hardware/kernel/gdb-notes/</link><pubDate>Tue, 12 Jan 2016 15:30:01 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/kernel/gdb-notes/</guid><description>gdb的基本使用 用gdb调试程序要确保调试的程序带有调试信息，这要求在链接程序的时候加上&amp;quot;-G&amp;quot;的参数。用gdb exec</description></item></channel></rss>
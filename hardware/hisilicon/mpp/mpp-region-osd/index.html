<!doctype html><html lang=zh-cn class=no-js><title>mpp region osd</title><meta charset=utf-8><meta name=robots content=index,nofollow><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta http-equiv=x-dns-prefetch-control content=on><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content=origin-when-cross-origin><meta name=description content="海思3516A区域管理操作汇总及位图填充示例_海思,OSD,点阵传位图_mill_li的博客-CSDN博客 【已解决】关于Hi3516A做OS"><meta name=author content=rinetd><meta name=google-site-verification content=ifeWsnNpU7w8vP3ii_Cjq-P9LKw3ngVitnMWv4XmJqk><link rel=canonical href=../../../../hardware/hisilicon/mpp/mpp-region-osd/><link rel=icon href=../../../../public/favicon.ico><link rel="shortcut icon" href=../../../../public/favicon.ico><link rel=stylesheet href=../../../../front/css/main.min.css><link href=https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css rel=stylesheet><link rel=stylesheet href=//cdn.bootcss.com/video.js/6.2.8/alt/video-js-cdn.min.css><body class="single single-post single-format-standard col-3cm full-width topbar-enabled chrome"><div id=wrapper><header id=header class="top-menu-mobile-on one-mobile-menu top_menu header-ads-desktop  topbar-transparent"><nav class="nav-container group mobile-menu mobile-sticky" id=nav-mobile data-menu-id=header-1><div class=mobile-title-logo-in-header><p class=site-title><a class=custom-logo-link href rel=home title="Pytool | Home">Pytool</a></div><div class="ham__navbar-toggler-two collapsed" title=Menu aria-expanded=false><div class=ham__navbar-span-wrapper><span class="line line-1"></span><span class="line line-2"></span><span class="line line-3"></span></div></div><div class=nav-text>mpp region osd</div><div class="nav-wrap container"><ul class="nav container-inner group mobile-search"><li><form class="searchform themeform" action=https://demo-hueman.presscustomizr.com/><div><input class=search name=s onblur="if(this.value=='')this.value='To search type and hit enter';" onfocus="if(this.value=='To search type and hit enter')this.value='';" value="To search type and hit enter"></div></form></ul><ul id=menu-topbar-menu class="nav container-inner group"><li class="menu-item menu-item-type-custom menu-item-object-custom current-menu-item current_page_item menu-item-home"><a href>Home</a><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children"><a href=../../../../hardware/>Hardware</a><ul class=sub-menu><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../hardware/kernel/>Kernel</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../hardware/hisilicon/>Hisilicon</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../hardware/rtmp/>Rtmp</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../hardware/rk3399/>Rk3399</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../hardware/dts/>Dts</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../hardware/rk3288/>Rk3288</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../hardware/%E8%BD%A6%E8%81%94%E7%BD%91/>车联网</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../hardware/android-%E5%BA%95%E5%B1%82/>Android-底层</a></ul><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children"><a href=../../../../language/>Language</a><ul class=sub-menu><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../language/clang/>Clang</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../language/golang/>Golang</a><ul class=sub-menu><li class="menu-item menu-item-type-custom menu-item-object-custom"><a href=../../../../language/golang/cgo/>Cgo</a><li class="menu-item menu-item-type-custom menu-item-object-custom"><a href=../../../../language/golang/hugo/>Hugo</a><li class="menu-item menu-item-type-custom menu-item-object-custom"><a href=../../../../language/golang/sys/>Sys</a><li class="menu-item menu-item-type-custom menu-item-object-custom"><a href=../../../../language/golang/goher/>Goher</a></ul><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../language/cpp/>Cpp</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../language/python/>Python</a><ul class=sub-menu><li class="menu-item menu-item-type-custom menu-item-object-custom"><a href=../../../../language/python/scrapy/>Scrapy</a></ul><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../language/java/>Java</a><ul class=sub-menu><li class="menu-item menu-item-type-custom menu-item-object-custom"><a href=../../../../language/java/hadoop/>Hadoop</a></ul><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../language/awesome/>Awesome</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../language/php/>Php</a><ul class=sub-menu><li class="menu-item menu-item-type-custom menu-item-object-custom"><a href=../../../../language/php/magento/>Magento</a></ul><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../language/android/>Android</a></ul><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children"><a href=../../../../linux/>Linux</a><ul class=sub-menu><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../linux/shell/>Shell</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../linux/cmd/>Cmd</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../linux/nginx/>Nginx</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../linux/ip/>Ip</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../linux/git/>Git</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../linux/haproxy/>Haproxy</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../linux/lvs/>Lvs</a></ul><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children"><a href=../../../../macos/>Macos</a><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children"><a href=../../../../ai/>Ai</a><ul class=sub-menu><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../ai/yolo/>Yolo</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../ai/caffe/>Caffe</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../ai/math/>Math</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../ai/ncnn/>Ncnn</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../ai/dataset/>Dataset</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../ai/pytorch/>Pytorch</a></ul><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children"><a href=../../../../frontend/>Frontend</a><ul class=sub-menu><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../frontend/css/>Css</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../frontend/vue/>Vue</a></ul><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children"><a href=../../../../devops/>Devops</a><ul class=sub-menu><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../devops/docker/>Docker</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../devops/elk/>Elk</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../devops/ansible/>Ansible</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../devops/prometheus/>Prometheus</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../devops/drone/>Drone</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../devops/kubernetes/>Kubernetes</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../devops/oauth2/>OAuth2</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../devops/etcd/>Etcd</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../devops/apidoc/>Apidoc</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../devops/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7/>系统监控</a></ul><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children"><a href=../../../../database/>Database</a><ul class=sub-menu><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../database/mysql/>Mysql</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../database/mongo/>Mongo</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../database/redis/>Redis</a></ul><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children"><a href=../../../../windows/>Windows</a><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children"><a href=../../../../hacker/>Hacker</a><ul class=sub-menu><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../hacker/01_%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/>01_端口扫描</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../hacker/00_%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E9%9A%A7%E9%81%93/>00_端口转发(隧道)</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../hacker/01-info-gather/>01-Info-Gather</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../hacker/02-spoof/>02-Spoof</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../hacker/shells/>Shells</a></ul><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children"><a href=../../../../work/>Work</a><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children"><a href=../../../../weixin/>Weixin</a><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children"><a href=../../../../edit/>Edit</a><li class=item><a class=text href=../../../../series/>series</a><li class=item><a class=text href=../../../../categories/>categories</a><li class=item><a class=text href=../../../../tags/>tags</a><li class=item><a class=text href=../../../../me/>about</a></ul></div></nav><nav class="nav-container group desktop-menu desktop-sticky" id=nav-topbar data-menu-id=header-2><div class=nav-text>mpp region osd</div><div class=topbar-toggle-down><i class="fas fa-angle-double-down" aria-hidden=true data-toggle=down title="Expand menu"></i><i class="fas fa-angle-double-up" aria-hidden=true data-toggle=up title="Collapse menu"></i></div><div class="nav-wrap container"><ul id=menu-topbar-menu-1 class="nav container-inner group"><li class="menu-item menu-item-type-custom menu-item-object-custom current-menu-item current_page_item menu-item-home"><a href=../../../../>Home</a><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../../hardware/>Hardware</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../hardware/kernel/>Kernel</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../hardware/hisilicon/>Hisilicon</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../hardware/rtmp/>Rtmp</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../hardware/rk3399/>Rk3399</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../hardware/dts/>Dts</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../hardware/rk3288/>Rk3288</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../hardware/%E8%BD%A6%E8%81%94%E7%BD%91/>车联网</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../hardware/android-%E5%BA%95%E5%B1%82/>Android-底层</a></ul><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../../language/>Language</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../language/clang/>Clang</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../language/golang/>Golang</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../language/cpp/>Cpp</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../language/python/>Python</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../language/java/>Java</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../language/awesome/>Awesome</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../language/php/>Php</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../language/android/>Android</a></ul><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../../linux/>Linux</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../linux/shell/>Shell</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../linux/cmd/>Cmd</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../linux/nginx/>Nginx</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../linux/ip/>Ip</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../linux/git/>Git</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../linux/haproxy/>Haproxy</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../linux/lvs/>Lvs</a></ul><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../../macos/>Macos</a><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../../post/>Post</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../post/english/>English</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../post/seo/>Seo</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../post/life/>Life</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../post/wiki/>Wiki</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../post/software/>Software</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../post/basic/>Basic</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../post/reship/>Reship</a></ul><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../../ai/>Ai</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../ai/yolo/>Yolo</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../ai/caffe/>Caffe</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../ai/math/>Math</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../ai/ncnn/>Ncnn</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../ai/dataset/>Dataset</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../ai/pytorch/>Pytorch</a></ul><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../../frontend/>Frontend</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../frontend/css/>Css</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../frontend/vue/>Vue</a></ul><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../../devops/>Devops</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../devops/docker/>Docker</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../devops/elk/>Elk</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../devops/ansible/>Ansible</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../devops/prometheus/>Prometheus</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../devops/drone/>Drone</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../devops/kubernetes/>Kubernetes</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../devops/oauth2/>OAuth2</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../devops/etcd/>Etcd</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../devops/apidoc/>Apidoc</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../devops/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7/>系统监控</a></ul><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../../database/>Database</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../database/mysql/>Mysql</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../database/mongo/>Mongo</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../database/redis/>Redis</a></ul><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../../windows/>Windows</a><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../../hacker/>Hacker</a><ul class=sub-menu><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../hacker/01_%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/>01_端口扫描</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../hacker/00_%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E9%9A%A7%E9%81%93/>00_端口转发(隧道)</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../hacker/01-info-gather/>01-Info-Gather</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../hacker/02-spoof/>02-Spoof</a><li class="menu-item menu-item-type-taxonomy menu-item-object-post_tag"><a href=../../../../hacker/shells/>Shells</a></ul><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../../work/>Work</a><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../../weixin/>Weixin</a><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children"><a href=../../../../edit/>Edit</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../series/>series</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../categories/>categories</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../tags/>tags</a><li class="menu-item menu-item-type-post_type menu-item-object-page"><a href=../../../../me/>about</a></ul></div></nav></header><div class=container id=page><div class=container-inner><div class=main><div class="main-inner group"><div class=content><div class="pad group page-title"><ul class="meta-single group"><li><span class="fa fa-folder-open"></span><li class=category><a href=../../../../categories/mpp/ rel="category tag">mpp</a></ul></div><div class="pad group"><article class="post type-post status-publish format-standard has-post-thumbnail hentry category-lifestyle tag-classical-grid tag-masonry-grid tag-standard-list"><div class="post-inner group"><h1 class=post-title>mpp region osd</h1><p class=post-byline>by · 2020年03月02日 · 9378 Words ·
~19min reading time |
<a href=https://gitlab.com/rinetd/blog/edit/master/hardware/hisilicon/mpp/mpp-region-osd.md target=_blank>Improve on <i class="fa fa-gitlab"></i></a><div class=clear></div><div class="entry themeform"><div class=entry-inner></br>原文链接：<a target=_blank href=../../../../hardware/hisilicon/mpp/mpp-region-osd/> mpp region osd</a><p><a href=https://blog.csdn.net/mill_li/article/details/90262607 target=_blank>海思3516A区域管理操作汇总及位图填充示例_海思,OSD,点阵传位图_mill_li的博客-CSDN博客</a><br><a href=http://bbs.ebaina.com/thread-10385-1-1.html target=_blank>【已解决】关于Hi3516A做OSD的问题 - 海思平台开放论坛 - 易百纳论坛 - Powered by Discuz!</a><br><a href=https://caibiao-lee.blog.csdn.net/article/details/105025111 target=_blank>(9条消息)海思多媒体(MPP)开发(5)——区域管理(REGION&amp;OSD字符显示)_mpp,OSD,水印_Biao-CSDN博客</a><p><a href=https://github.com/LiuyunlongLorin/HI3559v200/blob/32079ae65ff6a1a683383a6eea73ffb1a153a857/reference/common/hiosd/server/hi_osd.c target=_blank>HI3559v200/hi_osd.c at 32079ae65ff6a1a683383a6eea73ffb1a153a857 · LiuyunlongLorin/HI3559v200</a><p> 频叠加就是将图片和文字信息叠加到视频信号中，如电视台的LOGO，电影的字幕，电视机的菜单，都是通过视频叠加的形式显示在视频图像中的。区别于用于专业影视编辑行业的字幕叠加器，字符叠加器这一名称现在更加习惯用于各类监控系统中使用的价格相对低廉的具备基本的视频字幕叠加能力的电子设备。 <p> 字符叠加器按照功能分型可分为动态字符叠加器和静态字符叠加器 <br>       动态字符叠加器指与微机或其他智能设备配合，可显示随现场情况变化的字符信息，字符信息与现场视频信号相结合，为监控者提供更为详尽准确的信息。 <br>    静态字符叠加器指只在视频信号上显示相对固定字符信息的设备，主要用于在视频信号上叠加摄像头位置信息。价格低廉是此类静态字符叠加器的特点之一。<p>    接下来给大家介绍我在hi3516的平台实现的OSD叠加，我选择在VI通道进行osd叠加，具体的初始化操作和通道的配置会在下一篇文件会介绍，本文给大家介绍的是通过自己设置一个汉字模或者ASSIC模，然后通过二进制表示，最后读取字模并绘制在相应的图像区域，经过编码后即可显示叠加的内容。<p>区位码是与汉字一一对应的编码，用四位数字表示，<br>前两位从01 到94称区码，后两位从01到94称位码。 一个汉字的前一半是 ASCⅡ码为“160＋区码”的字符，<br>后一半是ASCⅡ码为“160＋ 位码”的字符。'例如：“刘”的区位码是 3385，<br>其意为区码33位码85，它是由ASCⅡ码为160＋33=193和160＋85=245的两个字符组成。<p> 先来了解一下字库的表示格式  <br>一般我们使用16*16的点阵宋体字库，所谓16*16，是每一个汉字在纵、横各16点的区域内显示的。<br>不过后来又有了HZK12、HZK24，HZK32和HZK48字库及黑体、楷体和隶书字库。虽然汉字库种类繁多，但都是按照<strong>区位</strong>的顺序排列的。<br>前一个字节为该汉字的区号，后一个字节为该字的位号。每一个区记录94个汉字，位号则为该字在该区中的位置。<br>   因此，汉字在汉字库中的具体位置计算公式为：94<em>(区号-1)+位号-1。减1是因为数组是以0为开始而区号位号是以1为开始的。这仅为以汉字为单位该汉字在汉字库中的位置，那么，如何得到以字节为单位得到该汉字在汉字库中的位置呢？只需乘上一个汉字字模占用的字节数即可，即：(94</em>(区号-1)+位号-1)*一个汉字字模占用字节数，而按每种汉字库的汉字大小不同又会得到不同的结果。<p>以16<em>16点阵字库为例，<br>计算公式则为：(94</em>(区号-1)+(位号-1))*32。汉字库文该从该位置起的32字节信息即记录了该字的字模信息。<br>以32<em>32点阵字库为例，<br>计算公式则为：(94</em>(区号-1)+(位号-1))*128。汉字库文该从该位置起的128字节信息即记录了该字的字模信息。<br>————————————————<br>版权声明：本文为CSDN博主「简单同学」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=https://blog.csdn.net/l471094842/article/details/95171397 target=_blank>https://blog.csdn.net/l471094842/article/details/95171397</a><p>1.创建RGN(overlay)<br>HI_MPI_RGN_Create()<ol><li>attach到编码通道(设置OSD的位置大小透明特性)<br>HI_MPI_RGN_AttachToChn()<br><li>制作OSD内容<br>把需要显示的内容做成第一,二步要求的格式放在一块内存里<br>4.HI_MPI_RGN_SetBitMap()<br><br></ol><h3 id=argb1555>ARGB1555</h3><p>0x8000 == 0x0 黑色<br>0x7FFF == 0xFFFF 白色<p>结论：<br>A. 如果想让背景色透明：<pre><code>1. stChnAttr.unChnAttr.stOverlayExChn.u32BgAlpha   = 0; // 设置背景色的透明度为0
2. stRegion.unAttr.stOverlay.u32BgColor = 0xxxx &amp; 0x7FFF ;    // 把图像像素点的 Alpha 位清0
</code></pre><p>B. 如果想让前景色半透明：<pre><code>1. stChnAttr.unChnAttr.stOverlayExChn.u32FgAlpha   = 64; 设置前景色透明度为 50%
2. 像素点的alpha位设为1 【argb1555 | 0x8000】
</code></pre><h4 id=图像像素点的-alpha-位为1-控制前景色透明度>图像像素点的 Alpha 位为1 控制前景色透明度</h4><p>stRegion.unAttr.stOverlay.u32BgColor = 0xFFFF; //背景白色 alpha位为1，那么这个颜色的透明度受u32FgAlpha控制，<pre><code>如果u32FgAlpha=64则背景就是50%的透明度。
如果u32FgAlpha=128则背景就是不透明度。
</code></pre><p>注： 这种情况下，背景色和前景色的透明度始终保持一致，也就是说bmp图片转换为 argb1555 时 alpha位始终为1的<h4 id=图像像素点的-alpha-位为0-控制背景色透明度>图像像素点的 Alpha 位为0 控制背景色透明度</h4><p>stRegion.unAttr.stOverlay.u32BgColor = 0x7FFF; //背景白色 alpha位为0，那么这个颜色的透明度收u32BgAlpha控制，<pre><code>如果u32BgAlpha=0则背景就是全透明。
如果u32BgAlpha=128则背景就是不透明。
</code></pre><p>stChnAttr.unChnAttr.stOverlayExChn.u32BgAlpha = 0;//【argb1555 &amp; 0x8000 == 0】 alpha位 为0的像素点透明度，也称背景透明度<br>stChnAttr.unChnAttr.stOverlayExChn.u32FgAlpha = 10;//【argb1555 &amp; 0x8000 == 0x8000】alpha为1的像素点透明度，也称前景透明度<h3 id=如何设置透明度>如何设置透明度 ？</h3><p>mpp/sample/common/sample_comm_region.c<p>HI_S32 SAMPLE_COMM_REGION_AttachToChn(HI_S32 HandleNum,RGN_TYPE_E enType, MPP_CHN_S *pstMppChn)<br>{<pre><code>        stChnAttr.unChnAttr.stOverlayChn.u32BgAlpha = 128;
        stChnAttr.unChnAttr.stOverlayChn.u32FgAlpha = 128;
</code></pre><p>}<h3 id=如何设置overlay-背景色和尺寸>如何设置OVERLAY 背景色和尺寸？</h3><p>HI_S32 SAMPLE_REGION_CreateOverLay(HI_S32 HandleNum)<br>{<pre><code>HI_S32 s32Ret;
HI_S32 i;
RGN_ATTR_S stRegion;

stRegion.enType = OVERLAY_RGN;
stRegion.unAttr.stOverlay.enPixelFmt = PIXEL_FORMAT_ARGB_1555;
stRegion.unAttr.stOverlay.stSize.u32Height = 200;
</code></pre><p>269 stRegion.unAttr.stOverlay.stSize.u32Width = 200;<br>270 stRegion.unAttr.stOverlay.u32BgColor = 0x00ff00ff;<pre><code>...
return s32Ret;
</code></pre><p>}<h3 id=和图像格式搭配>和图像格式搭配</h3><p>u32BgAlpha + 图像 Alpha 位为0 的像素点的透明度。也称背景Alpha。<br>u32FgAlpha + 图像 Alpha 位为1 的像素点的透明度。也称前景Alpha。<p>举例说明:<br>比如 u32FgAlpha = 128;u32BgAlpha = 0; 假定0表示透明, 128表示不透明<p>在ARGB1555格式下, 像素A的值是0x7fff, 像素B的值是0x8000<br>可以看到像素A的 Alpha 位为0, 那么像素B的 Alpha 位为1<p>那么<br>u32FgAlpha对于像素A没有作用, u32BgAlpha有作用, 作用效果就是被透明了<br>u32FgAlpha对于像素B有作用, u32BgAlpha没有作用, 作用效果就是显示了像素B<p>所以OSD中的像素点的alpha也很重要, 意思就是用alpha区分前景和背景, 比如前景的alpha = 1, 背景的alpha = 0,然后配合u32FgAlpha和u32FgAlpha就能做到了<p>u32FgAlpha Alpha 位为1 的像素点的透明度。也称前景Alpha。<p>尴尬了，<br>我的像素描点值：<br>前景黑色0x8000,<br>背景白色是0x7fff；<p>rgn_attr.unAttr.stOverlay.u32BgColor = 0x7FFF;<p>stChnAttr.unChnAttr.stOverlayChn.u32BgAlpha = 0;<br>stChnAttr.unChnAttr.stOverlayChn.u32FgAlpha = 128;<p>现象是：屏幕上没osd了；把u32BgAlpha=128，能显示，但是背景是蓝色，很奇怪。<p>rgn_attr.unAttr.stOverlay.u32BgColor = 0x7FFF;<h3 id=1-黑白正常显示>1. 黑白正常显示</h3><p>stChnAttr.unChnAttr.stOverlayChn.u32BgAlpha = 128; //背景的透明度<br>stChnAttr.unChnAttr.stOverlayChn.u32FgAlpha = 128;<h3 id=2-背景白色显示透明>2. 背景白色显示透明</h3><p>stRegion.unAttr.stOverlay.u32BgColor = 0x7FFF; //背景白色<br>stChnAttr.unChnAttr.stOverlayChn.u32BgAlpha = 0; //背景透明<br>stChnAttr.unChnAttr.stOverlayChn.u32FgAlpha = 50;<h3 id=2-背景黑色-alpha显示黑色>2. 背景黑色 Alpha显示黑色</h3><p>stRegion.unAttr.stOverlay.u32BgColor = 0x8000; //背景黑色<br>stChnAttr.unChnAttr.stOverlayChn.u32BgAlpha = 0; //背景透明<br>stChnAttr.unChnAttr.stOverlayChn.u32FgAlpha = 128;<h4 id=直接根据字体转换为argb1555>直接根据字体转换为ARGB1555</h4><p>如果是用HI_MPI_RGN_SetBitMap, 都有点阵了还要什么bmp呀, 直接把点阵转换成ARGB1555(region中通用的格式)的buffer即可<p>比如楼主的&quot;0&quot;, 13x23, 点阵共46bytes, 每行两个bytes共23行, 每个bit代表一个像素, 1表示有前景, 0表示背景<p>简单的转换代码:<pre><code class=language-cpp>int height, width, i, bytes, bits;
unsigned char *src, *dst;

for ( height = 0; height &lt; 23; height++ )
{
        src = data[0] + height * 2;
        dst = buffer + height * stride;
        for ( width = 0; width &lt; 13 ; width++ )
        {
                bytes = width / 8;
                bits = width % 8;
                if ( !(src[bytes] &amp; (1 &lt;&lt; bits)) )
                {
                        *dst = 0;
                }
                else
                {
                        *dst = 0x7fff;
                }
                dst++;
        }
}
</code></pre><p>没有测试过, 只是简单意思一下<br>其中, data[0]表示字符0, buffer表示输出用于region的buffer, 格式是ARGB1555(0x7fff表示黑色, 当然还要和region的alpha配合)<br>stride是输出buffer的, 意味着可以把多个字符放到同一个buffer中(当然buffer的起始坐标要修改)<h4 id=直接修改位图数据>直接修改位图数据</h4><p><a href="https://github.com/search?q=stCanvasInfo.u32VirtAddr&amp;type=Code" target=_blank>Search · stCanvasInfo.u32VirtAddr</a><pre><code>    stBitmap.pData   = (HI_VOID*)stCanvasInfo.u32VirtAddr;  //位图数据。
    stSize.u32Width  = stCanvasInfo.stSize.u32Width;                          //位图宽度。
    stSize.u32Height = stCanvasInfo.stSize.u32Height;  
    s32Ret = SAMPLE_RGN_UpdateCanvas(&quot;sys_time.bmp&quot;, &amp;stBitmap, HI_FALSE, 0, &amp;stSize, stCanvasInfo.u32Stride,stRgnAttrSet.unAttr.stOverlayEx.enPixelFmt);
</code></pre><p>在这一步遇到困难，有什么办法可以不保存成位图直接通过SDL得到的buff丢给画图吗？这样就省了保存成位图再加载位图的步骤<p>目前用SDL生成了BMP图像，然后给到Hi3516A的Vpss通道，实现了如下图的效果，但是还有两个问题，希望大家能够帮忙看一下<br>1、生成的BMP图像的背景颜色如何变成透明的呢，现在有背景颜色不太好看<br>2、如何显示两行字符，即在目前显示的时间下面，再显示一行别的信息，这个需要怎么去做，有没有办法让生成的BMP图像有两行或者多行数据呢<p>第一个问题可以利用overlay的alpha来处理,当然BMP图像要处理成有alpha的<br>第二个问题就是把几个BMP合成一个BMP而已<hr><p>还搞得这么麻烦，我直接用freetype2就在上面画汉字字母了，还是实现了时间显示，根本就不用什么SDL<hr><p>当Alpha 位为1时，芯片使用u32FgAlpha 进行透明度叠加；<br>当Alpha 位为0时，芯片使用u32BgAlpha 进行透明度叠加。<br>0 表示全透明；128表示不透明。<p>而你的BMP的每个象素都是一种alpha的当然就只能一起变了,把要透明的像素的alpha和不要透明的像素的alpha设成不一样的<br>注意:这里讨论的实BMP图,而不是RGN的设定<br>举例:<br>比如你的BMP有两个像素(假设是16bits, RGN设为ARGB1555格式) ,假设BMP的buffer为[0x0000, 0x0123], 可以看出前一个点为黑色,后一个点为有色点,如果要黑点透明,那么要把黑点的值改为<br>0x8000, 同时u32FgAlpha=0, u32BgAlpha=128<br>这样一来有色点就留下了,黑点就透明了被下面的视频代替了<p>关于BMP合并,如果格式相同,就是简单的内存搬移了,很简单<p>可以分配一个大的内存,用SDL生成两个BMP内存,然后搬到大的内存就好了,只要注意下起始地址,高,宽和stride就可以了<br>然后把大的内存做为osd送给海思就能显示多行了<p>s32Ret = SAMPLE_RGN_UpdateCanvas(&quot;sys_time.bmp&quot;, &amp;stBitmap, HI_FALSE, 0, &amp;stSize, stCanvasInfo.u32Stride, stRgnAttrSet.unAttr.stOverlayEx.enPixelFmt);<p>请注意第三第四个参数, 这两个可以控制透明, 第三个设为HI_TRUE, 第四个设为BMP中需要透明的背景像素的值(你可以用打印的方法得到)<p>也可以做个测试,第四个参数设为0x8000(从代码和贴出OSD的实际图猜的), 应该会看到osd中的字(黑色的部分, 希望值是0x8000,祈祷中...)透明了<h3 id=求助-时间osd闪烁>[求助] 时间osd闪烁</h3><p>你每隔500ms，或者1s 刷新一下画布HI_MPI_RGN_UpdateCanvas就可以了啊，没有必要HI_MPI_RGN_DetachFromChn，和销毁HI_MPI_RGN_Destroy啊<p>SOC_CHECK(HI_MPI_RGN_GetCanvasInfo(Handle, &amp;stCanvasInfo));<p>if(NULL == overlay || (NULL != overlay)&amp;&amp;(NULL == overlay-&gt;canvas)){<pre><code>SOC_CHECK(HI_MPI_RGN_UpdateCanvas(Handle));
handle_num ++ ;             
pthread_mutex_unlock(&amp;_sdk_enc.attr.overlayex_mutex);
continue ;
</code></pre><p>}else{<pre><code>memcpy(stCanvasInfo.u32VirtAddr,overlay-&gt;canvas-&gt;pixels,
overlay-&gt;canvas-&gt;width * overlay-&gt;canvas-&gt;height * sizeof(uint16_t));
stCanvasInfo.stSize.u32Height = overlay-&gt;canvas-&gt;height;
stCanvasInfo.stSize.u32Width  = overlay-&gt;canvas-&gt;width;
</code></pre><p>}<pre><code class=language-cpp>



void DrawPixel (BMP *bmp, int x, int y, int color) {
    int bpp;
    Uint8 *p;

    // Get clip
    if(
        x &lt; bmp-&gt;clip_rect.x ||
        x &gt; bmp-&gt;clip_rect.x + bmp-&gt;clip_rect.w ||
        y &lt; bmp-&gt;clip_rect.y ||
        y &gt;= bmp-&gt;clip_rect.y + bmp-&gt;clip_rect.h
    )
  return;

    bpp = bmp-&gt;format-&gt;BytesPerPixel;

    // Here p is the address to the pixel we want to set
    p = (Uint8 *)bmp-&gt;pixels + y * bmp-&gt;pitch + x * bpp;

    if (bpp==2) { *(Uint16 *)p = color; return; }
    if (bpp==4) *(Uint32 *)p = color;

}// DrawPixel()

void DrawHline (BMP *bmp, int x1, int y, int x2, int color) {
    int i; // counter
    Uint8 *p; // pixel

    if ( y &lt; bmp-&gt;clip_rect.y || y &gt; bmp-&gt;clip_rect.y + bmp-&gt;clip_rect.h-1)
        return;

    // Set cliping
    if (x1 &lt; bmp-&gt;clip_rect.x) x1 = bmp-&gt;clip_rect.x;
    if (x2 &gt; bmp-&gt;clip_rect.x + bmp-&gt;clip_rect.w-1) x2 = bmp-&gt;clip_rect.x + bmp-&gt;clip_rect.w-1;

    int bpp = bmp-&gt;format-&gt;BytesPerPixel;

    //Here p is the address to the pixel we want to set
    p = (Uint8 *)bmp-&gt;pixels + y * bmp-&gt;pitch + x1 * bpp;

    switch (bpp) {
    case 2:
        for (i = x1; i &lt;= x2; i++) {
            *(Uint16 *)p = color; // Set color
            p += bpp;             // Increment
        }
        break;
    case 4:
        for (i = x1; i &lt;= x2; i++) {
            *(Uint32 *)p = color; // Set color
            p += bpp;             // Increment
        }
        break;
    }
}// hline ();

void DrawVline (BMP *bmp, int x, int y1, int y2, int color) {
    const int bpp = bmp-&gt;format-&gt;BytesPerPixel;
    int i;
    Uint8 *p; // pixel

    if ( x &lt; bmp-&gt;clip_rect.x || x &gt; bmp-&gt;clip_rect.x + bmp-&gt;clip_rect.w-1 )
        return;

    // Set cliping
    if ( y1 &lt; bmp-&gt;clip_rect.y ) y1 = bmp-&gt;clip_rect.y;
    if ( y2 &gt; bmp-&gt;clip_rect.y + bmp-&gt;clip_rect.h-1 ) y2 = bmp-&gt;clip_rect.y + bmp-&gt;clip_rect.h-1;

    //Here p is the address to the pixel we want to set
    p = (Uint8 *)bmp-&gt;pixels + y1 * bmp-&gt;pitch + x * bpp;

    switch (bpp) {
    case 2:
        for (i = y1; i &lt;= y2; i++) {
            *(Uint16 *)p = color; // Set color
            p += bmp-&gt;pitch;      // Increment
        }
        break;


    case 4:
        for (i = y1; i &lt;= y2; i++) {
            *(Uint32 *)p = color; // Set color
            p += bmp-&gt;pitch;      // Increment
        }
        break;
    }
}// vline ();

void DrawRect (BMP *bmp, int x, int y, int w, int h, int color) {
    DrawHline(bmp, x, y, x+w, color);
    DrawHline(bmp, x, y+h, x+w, color);
    DrawVline(bmp, x, y, y+h, color);
    DrawVline(bmp, x+w, y, y+h, color);
}
void DrawRectR (BMP *bmp, int x, int y, int w, int h, int color) {
    DrawHline(bmp, x+2, y, x+w-3, color);
    DrawHline(bmp, x+2, y+h-1, x+w-3, color);
    DrawVline(bmp, x, y+2, y+h-3, color);
    DrawVline(bmp, x+w-1, y+2, y+h-3, color);

    DrawPixel(bmp, x+1, y+1, color);
    DrawPixel(bmp, x+w-2, y+1, color);
    DrawPixel(bmp, x+1, y+h-2, color);
    DrawPixel(bmp, x+w-2, y+h-2, color);
}
/*
void draw_rectr (BMP *bmp, int x1, int y1, int x2, int y2, int color) {
    short ponto[] = {
      x1+1, y1+1,
      x2-1, y1+1,
      x2-1, y2-1,
      x1+1, y2-1
    };
    draw_hline( bmp, x1+2, y1, x2-2, color ); // top
    draw_vline( bmp, x2, y1+2, y2-2, color ); // right &gt;
    draw_hline( bmp, x1+2, y2, x2-2, color ); // button
    draw_vline( bmp, x1, y1+2, y2-2, color ); // left &lt;

    draw_point (bmp, 8, ponto, color);
}
*/
</code></pre><pre><code class=language-cpp>#define FB_BK_COLOR 0xfc00//0x7c00

int GetOSDLayerInfo(int Handle,int * layer_width, int * layer_height,int * enPixelFmt)
{
	int iRet = 0;
	int iRetNo = MSA_SUCCESS;
	int tmp;
	RGN_CANVAS_INFO_S stCanvasInfo;
	iRet = HI_MPI_RGN_GetCanvasInfo(Handle, &amp;stCanvasInfo);
	if(HI_SUCCESS != iRet)
	{
	    printf(&quot;HI_MPI_RGN_GetCanvasInfo failed! s32Ret: 0x%x.\n&quot;, iRet);
	    return -1;
	}

	iRet = HI_MPI_RGN_UpdateCanvas(Handle);
	if(HI_SUCCESS != iRet)
	{
	    printf(&quot;HI_MPI_RGN_UpdateCanvas failed! s32Ret: 0x%x.\n&quot;, iRet);
	     return -1;
	}

	*layer_width =  stCanvasInfo.stSize.u32Width;
	*layer_height = stCanvasInfo.stSize.u32Height;
	*enPixelFmt = stCanvasInfo.enPixelFmt;
	return 1;
}  

int OSDLayerDrawClear(int Handle)  {
  	int x,y;
	short * screen_buf;
	int iRet;  	RGN_CANVAS_INFO_S stCanvasInfo;
	iRet = HI_MPI_RGN_GetCanvasInfo(Handle, &amp;stCanvasInfo);
	if(HI_SUCCESS != iRet)
	{
	    printf(&quot;HI_MPI_RGN_GetCanvasInfo failed! s32Ret: 0x%x.\n&quot;, iRet);
	    return -1;
	}
    
    memset(stCanvasInfo.u32VirtAddr,FB_BK_COLOR,stCanvasInfo.u32Stride*stCanvasInfo.stSize.u32Height );	
    
    iRet = HI_MPI_RGN_UpdateCanvas(Handle);    	
    if (HI_SUCCESS != iRet)    	{
        DPRINTK(&quot;HI_MPI_RGN_UpdateCanvas fail! s32Ret: 0x%x.\n&quot;, iRet);        	
        return -1;    	
    }	
    return 1;  
    }




int OSDLayerDrawPicUseCoordinate(int Handle,int start_x,int start_y,int pic_x,int pic_y,int pic_show_w,int pic_show_h,int pic_width,int pic_height,char * pic_data)
{
	int x,y;
	short * screen_buf;
	int iRet;
	RGN_CANVAS_INFO_S stCanvasInfo;
	iRet = HI_MPI_RGN_GetCanvasInfo(Handle, &amp;stCanvasInfo);
	if(HI_SUCCESS != iRet)
	{
	    printf(&quot;HI_MPI_RGN_GetCanvasInfo failed! s32Ret: 0x%x.\n&quot;, iRet);
	    return -1;
	}
	if( (start_x + pic_show_w)  &gt; stCanvasInfo.stSize.u32Width  ||
		(start_y + pic_show_h) &gt;  stCanvasInfo.stSize.u32Height  )
	{
		DPRINTK(&quot;[%d] screen(%d,%d,%d,%d) &gt; (%d,%d) error!\n&quot;,Handle,pic_x,pic_y,
			pic_show_w, pic_show_h,stCanvasInfo.stSize.u32Width,stCanvasInfo.stSize.u32Height );
		return -1;
	}		//memset(stCanvasInfo.u32VirtAddr,FB_BK_COLOR,stCanvasInfo.u32Stride*stCanvasInfo.stSize.u32Height );
	{
		short * pic_buf;
		int pic_line = 0;
		screen_buf = (short *)stCanvasInfo.u32VirtAddr;
		pic_buf = (short *)pic_data;
		pic_line = pic_y;		//printf(&quot;first pixel is %x\n&quot;,pic_buf[0]);
		for( y = start_y; y &lt; start_y + pic_show_h; y++ )
		{
			memcpy(&amp;screen_buf[y* stCanvasInfo.u32Stride /2 + start_x],
				&amp;pic_buf[pic_line*pic_width + pic_x],pic_show_w*2);
			pic_line++;
		}
	}
	//DPRINTK(&quot;HI_MPI_RGN_UpdateCanvas 1\n&quot;);	iRet = HI_MPI_RGN_UpdateCanvas(Handle);    	if (HI_SUCCESS != iRet)    	{        	DPRINTK(&quot;HI_MPI_RGN_UpdateCanvas fail! s32Ret: 0x%x.\n&quot;, iRet);        	return -1;    	}	//DPRINTK(&quot;HI_MPI_RGN_UpdateCanvas 2\n&quot;);
	return 1;

}



int MSA_OSDLayerDrawPic(MSA_HANDLE hHandle, MSA_DRAW_OSD_PIC_ST stDrawOsd)
{
	int iRet = 0;
	int iRetNo = MSA_SUCCESS;
	int tmp;
	MSA_CHANNEL_ST tmpChan; 	
	MSA_CHANNEL_INFO_ST * pChan = (MSA_CHANNEL_INFO_ST *)hHandle;

	if( gMsaCtrl.isInit == 0 )	
		return MSA_ERR_NOT_INIT;

	MSA_OpLock();

	if( hHandle == NULL )
	{
		iRetNo = MSA_ERR_NULL_PTR;
		goto err;
	}	

	if( pChan-&gt;iOsdIsClear == 0 )
	{
		OSDLayerDrawClear(pChan-&gt;iOsdLayerChan);
		pChan-&gt;iOsdIsClear = 1;
	}

	iRet = OSDLayerDrawPicUseCoordinate(pChan-&gt;iOsdLayerChan,stDrawOsd.screen_x,stDrawOsd.screen_y,\
		stDrawOsd.pic_show_offset_x,stDrawOsd.pic_show_offset_y,stDrawOsd.pic_show_w,stDrawOsd.pic_show_h,\
		stDrawOsd.pic_width,stDrawOsd.pic_height,stDrawOsd.pic_data_ptr);
	if (iRet &lt; 0)
	 {
	     	DPRINTK(&quot;OSDLayerDrawPicUseCoordinate failed! s32Ret: 0x%x.\n&quot;, iRet);
	  	iRetNo = MSA_FAILED;
		goto err;
	 }

	
	MSA_OpUnLock();
	return iRetNo;
err:	
	MSA_OpUnLock();
	return iRetNo;
}




HI_S32 RegionCtr::SAMPLE_RGN_SetOverlayPosToVpss(RGN_HANDLE Handle,VPSS_GRP VpssGrp,POINT_S &amp;Point)
{
    MPP_CHN_S stChn;
    HI_S32 s32Ret = HI_SUCCESS;
    RGN_CHN_ATTR_S stChnAttr;

    stChn.enModId = HI_ID_VPSS;
    stChn.s32DevId = VpssGrp;
    stChn.s32ChnId = 0;

    s32Ret = HI_MPI_RGN_GetDisplayAttr(Handle,&amp;stChn,&amp;stChnAttr);
    if(s32Ret != HI_SUCCESS){
        qDebug(&quot;HI_MPI_RGN_GetDisplayAttr failed with %#x!&quot;,s32Ret);
        return s32Ret;
    }
//    qDebug()&lt;&lt;&quot;back setRgnPoint:&quot;&lt;&lt;Point.s32X&lt;&lt;&quot;:&quot;&lt;&lt;Point.s32Y;

    if(stChnAttr.unChnAttr.stOverlayChn.stPoint.s32X &lt; 0)
        stChnAttr.unChnAttr.stOverlayChn.stPoint.s32X = 0;
    if(stChnAttr.unChnAttr.stOverlayChn.stPoint.s32Y &lt; 0)
        stChnAttr.unChnAttr.stOverlayChn.stPoint.s32Y = 0;

    stChnAttr.unChnAttr.stOverlayChn.stPoint.s32X = ALIGN_UP(Point.s32X,2);
    stChnAttr.unChnAttr.stOverlayChn.stPoint.s32Y = ALIGN_UP(Point.s32Y,2);

//    qDebug()&lt;&lt;&quot;back setRgnPoint:&quot;&lt;&lt;stChnAttr.unChnAttr.stOverlayChn.stPoint.s32X&lt;&lt;&quot;:&quot;&lt;&lt;stChnAttr.unChnAttr.stOverlayChn.stPoint.s32Y;

    s32Ret = HI_MPI_RGN_SetDisplayAttr(Handle,&amp;stChn,&amp;stChnAttr);
    if(s32Ret != HI_SUCCESS){
        qDebug(&quot;HI_MPI_RGN_SetDisplayAttr failed with %#x!&quot;,s32Ret);

    }

    return s32Ret;

}

HI_S32 RegionCtr::SAMPLE_RGN_SetOverlayMovePos(RGN_HANDLE Handle, VPSS_GRP VpssGrp, POINT_S &amp;Point)
{
    MPP_CHN_S stChn;
    HI_S32 s32Ret = HI_SUCCESS;
    RGN_CHN_ATTR_S stChnAttr;

    stChn.enModId = HI_ID_VPSS;
    stChn.s32DevId = VpssGrp;
    stChn.s32ChnId = 0;

    s32Ret = HI_MPI_RGN_GetDisplayAttr(Handle,&amp;stChn,&amp;stChnAttr);
    if(s32Ret != HI_SUCCESS){
        qDebug(&quot;HI_MPI_RGN_GetDisplayAttr failed with %#x!&quot;,s32Ret);
        return s32Ret;
    }

    stChnAttr.unChnAttr.stOverlayChn.stPoint.s32X = ALIGN_UP(stChnAttr.unChnAttr.stOverlayChn.stPoint.s32X+Point.s32X+Point.s32X,2);
    stChnAttr.unChnAttr.stOverlayChn.stPoint.s32Y = ALIGN_UP(stChnAttr.unChnAttr.stOverlayChn.stPoint.s32Y+Point.s32Y+Point.s32Y,2);

    if(stChnAttr.unChnAttr.stOverlayChn.stPoint.s32X &lt; 0)
        stChnAttr.unChnAttr.stOverlayChn.stPoint.s32X = 0;
    if(stChnAttr.unChnAttr.stOverlayChn.stPoint.s32Y &lt; 0)
        stChnAttr.unChnAttr.stOverlayChn.stPoint.s32Y = 0;

    s32Ret = HI_MPI_RGN_SetDisplayAttr(Handle,&amp;stChn,&amp;stChnAttr);
    if(s32Ret != HI_SUCCESS){
        qDebug(&quot;HI_MPI_RGN_SetDisplayAttr failed with %#x!&quot;,s32Ret);

    }

    return s32Ret;

}

HI_S32 RegionCtr::SAMPLE_RGN_ShowOverlay(RGN_HANDLE Handle, VPSS_GRP VpssGrp, HI_BOOL enable)
{
    MPP_CHN_S stChn;
    HI_S32 s32Ret = HI_SUCCESS;
    RGN_CHN_ATTR_S stChnAttr;

    stChn.enModId = HI_ID_VPSS;
    stChn.s32DevId = VpssGrp;
    stChn.s32ChnId = 0;

    s32Ret = HI_MPI_RGN_GetDisplayAttr(Handle,&amp;stChn,&amp;stChnAttr);
    if(s32Ret != HI_SUCCESS){
        qDebug(&quot;HI_MPI_RGN_GetDisplayAttr failed with %#x!&quot;,s32Ret);
        return s32Ret;
    }

    stChnAttr.bShow  = enable;
    s32Ret = HI_MPI_RGN_SetDisplayAttr(Handle,&amp;stChn,&amp;stChnAttr);
    if(s32Ret != HI_SUCCESS){
        qDebug(&quot;HI_MPI_RGN_GetDisplayAttr failed with %#x!&quot;,s32Ret);

    }

    return s32Ret;

}
</code></pre><pre><code class=language-cpp>static inline uint16_t overlay_pixel_argb4444(stSDK_ENC_VIDEO_OVERLAY_PIXEL pixel)
{
	return ((pixel.alpha&gt;&gt;4)&lt;&lt;12)|((pixel.red&gt;&gt;4)&lt;&lt;8)|((pixel.green&gt;&gt;4)&lt;&lt;4)|((pixel.blue&gt;&gt;4)&lt;&lt;0);
}

static inline stSDK_ENC_VIDEO_OVERLAY_PIXEL overlay_pixel_argb8888(uint16_t pixel)
{
	stSDK_ENC_VIDEO_OVERLAY_PIXEL pixel_8888;
	pixel_8888.alpha = ((pixel&gt;&gt;12)&lt;&lt;4) &amp; 0xff;
	pixel_8888.red = ((pixel&gt;&gt;8)&lt;&lt;4) &amp; 0xff;
	pixel_8888.green = ((pixel&gt;&gt;4)&lt;&lt;4) &amp; 0xff;
	pixel_8888.blue = ((pixel&gt;&gt;0)&lt;&lt;4) &amp; 0xff;
	return pixel_8888;
}


static int overlay_canvas_put_pixel(LP_SDK_ENC_VIDEO_OVERLAY_CANVAS canvas, int x, int y, stSDK_ENC_VIDEO_OVERLAY_PIXEL pixel)
{
	if(canvas){
		if(x &lt; canvas-&gt;width &amp;&amp; y &lt; canvas-&gt;height){
			if(NULL != canvas-&gt;pixels){
				uint16_t *const pixels = (uint16_t*)canvas-&gt;pixels;
				*(pixels + y * canvas-&gt;width + x) = overlay_pixel_argb4444(pixel);
				return 0;
			}
		}
	}
	return -1;
}

static int overlay_canvas_get_pixel(LP_SDK_ENC_VIDEO_OVERLAY_CANVAS canvas, int x, int y, stSDK_ENC_VIDEO_OVERLAY_PIXEL* ret_pixel)
{
	if(canvas){
		if(x &lt; canvas-&gt;width &amp;&amp; y &lt; canvas-&gt;height){
			if(NULL != canvas-&gt;pixels){
				uint16_t *const pixels = (uint16_t*)canvas-&gt;pixels;
				if(ret_pixel){
					*ret_pixel = overlay_pixel_argb8888(*(pixels + y * canvas-&gt;width + x));
					return 0;
				}
			}
		}
	}
	return -1;
}

static bool overlay_canvas_match_pixel(LP_SDK_ENC_VIDEO_OVERLAY_CANVAS canvas, stSDK_ENC_VIDEO_OVERLAY_PIXEL pixel1, stSDK_ENC_VIDEO_OVERLAY_PIXEL pixel2)
{
	return overlay_pixel_argb4444(pixel1) == overlay_pixel_argb4444(pixel2);
}

static int overlay_canvas_put_rect(LP_SDK_ENC_VIDEO_OVERLAY_CANVAS canvas, int x, int y, size_t width, size_t height,stSDK_ENC_VIDEO_OVERLAY_PIXEL pixel)
{
	if(canvas){
		if(x &lt; canvas-&gt;width &amp;&amp; y &lt; canvas-&gt;height){
			if(NULL != canvas-&gt;pixels){
				int i, ii;
				uint16_t *const pixels = (uint16_t*)(canvas-&gt;pixels);
				uint16_t const pixel_4444 = overlay_pixel_argb4444(pixel);
				
				if(x + width &gt;= canvas-&gt;width){
					width = canvas-&gt;width - x;
				}
				if(y + height &gt;= canvas-&gt;height){
					height = canvas-&gt;height - y;
				}
				
				for(i = 0; i &lt; height; ++i){
					uint16_t* pixel_pos = pixels + i * canvas-&gt;width;
					if(0 == i || height - 1 == i){
						// put one line
						for(ii = 0; ii &lt; width; ++ii){
							*pixel_pos++ = pixel_4444;
						}
					}else{
						// put 2 dots
						pixel_pos[0] = pixel_pos[width - 1] = pixel_4444;
					}
				}
				return 0;
			}
		}
	}
	return -1;
}

static int overlay_canvas_fill_rect(LP_SDK_ENC_VIDEO_OVERLAY_CANVAS canvas, int x, int y, size_t width, size_t height, stSDK_ENC_VIDEO_OVERLAY_PIXEL pixel)
{
	if(canvas){
		if(!width){
			width = canvas-&gt;width;
		}
		if(!height){
			height = canvas-&gt;height;
		}
		
		if(x &lt; canvas-&gt;width &amp;&amp; y &lt; canvas-&gt;height){
			if(NULL != canvas-&gt;pixels){	
				int i, ii;
				uint16_t *const pixels = (uint16_t*)(canvas-&gt;pixels);
				uint16_t const pixel_4444 = overlay_pixel_argb4444(pixel);
				
				if(x + width &gt;= canvas-&gt;width){
					width = canvas-&gt;width - x;
				}
				if(y + height &gt;= canvas-&gt;height){
					height = canvas-&gt;height - y;
				}
				
				for(i = 0; i &lt; height; ++i){
					uint16_t* pixel_pos = pixels + i * canvas-&gt;width;
					for(ii = 0; ii &lt; width; ++ii){
						*pixel_pos++ = pixel_4444;
					}
				}
				return 0;
			}
		}
	}
	return -1;
}

static int overlay_canvas_erase_rect(LP_SDK_ENC_VIDEO_OVERLAY_CANVAS canvas, int x, int y, size_t width, size_t height)
{
	stSDK_ENC_VIDEO_OVERLAY_PIXEL erase_pixel;
	erase_pixel.alpha = 0;
	erase_pixel.red = 0;
	erase_pixel.green = 0;
	erase_pixel.blue = 0;
	return canvas-&gt;fill_rect(canvas, x, y, width, height, erase_pixel);
}


static LP_SDK_ENC_VIDEO_OVERLAY_CANVAS enc_create_overlay_canvas(size_t width, size_t height)
{
	int i = 0;
	if(width &gt; 0 &amp;&amp; height &gt; 0){
		LP_SDK_ENC_VIDEO_OVERLAY_CANVAS const canvas_stock = _sdk_enc.attr.canvas_stock;
		for(i = 0; i &lt; HI_VENC_OVERLAY_CANVAS_STOCK_REF; ++i){
			LP_SDK_ENC_VIDEO_OVERLAY_CANVAS const canvas = canvas_stock + i;
			if(!canvas-&gt;pixels){
				// has not been allocated
				LP_SDK_ENC_VIDEO_OVERLAY_CANVAS const canvas = &amp;canvas_stock[i];

				canvas-&gt;width = SDK_ALIGNED_BIG_ENDIAN(width, 2); // aligned to 2 pixel
				canvas-&gt;height = SDK_ALIGNED_BIG_ENDIAN(height, 2);
				// hisilicon use argb444 format
				canvas-&gt;pixel_format.rmask = 0x0f00;
				canvas-&gt;pixel_format.gmask = 0x00f0;
				canvas-&gt;pixel_format.bmask = 0x000f;
				canvas-&gt;pixel_format.amask = 0xf000;
				// frame buffer
		//  		canvas-&gt;pixels = calloc(canvas-&gt;width * canvas-&gt;height * sizeof(uint16_t), 1);
				HI_MPI_SYS_MmzAlloc(&amp;canvas-&gt;phy_addr, (void**)(&amp;canvas-&gt;pixels),
					NULL, NULL,canvas-&gt;width * canvas-&gt;height * sizeof(uint16_t));
				// interfaces
				canvas-&gt;put_pixel = overlay_canvas_put_pixel;
				canvas-&gt;get_pixel = overlay_canvas_get_pixel;
				canvas-&gt;match_pixel = overlay_canvas_match_pixel;
				canvas-&gt;put_rect = overlay_canvas_put_rect;
				canvas-&gt;fill_rect = overlay_canvas_fill_rect;
				canvas-&gt;erase_rect = overlay_canvas_erase_rect;
				return canvas;
			}
		}
	}
	return NULL;
}

static LP_SDK_ENC_VIDEO_OVERLAY_CANVAS enc_load_overlay_canvas(const char *bmp24_path)
{
	int i = 0, ii = 0;
	int ret = 0;
	typedef struct BIT_MAP_FILE_HEADER	{
		char type[2]; // &quot;BM&quot; (0x4d42)
	    uint32_t file_size;
	    uint32_t reserved_zero;
	    uint32_t off_bits; // data area offset to the file set (unit. byte)
		uint32_t info_size;
		uint32_t width;
		uint32_t height;
		uint16_t planes; // 0 - 1
		uint16_t bit_count; // 0 - 1
		uint32_t compression; // 0 - 1
		uint32_t size_image; // 0 - 1
		uint32_t xpels_per_meter;
		uint32_t ypels_per_meter;
		uint32_t clr_used;
		uint32_t clr_important;
	}__attribute__((packed)) BIT_MAP_FILE_HEADER_t; //
	
	FILE *bmp_fid = NULL;

	bmp_fid = fopen(bmp24_path, &quot;rb&quot;);
	if(NULL != bmp_fid){
		BIT_MAP_FILE_HEADER_t bmp_hdr;
		ret = fread(&amp;bmp_hdr, 1, sizeof(bmp_hdr), bmp_fid);

		if(sizeof(bmp_hdr) == ret){
			if('B' == bmp_hdr.type[0]
				&amp;&amp; 'M' == bmp_hdr.type[1]
				&amp;&amp; 24 == bmp_hdr.bit_count){
				
				int const bmp_width = bmp_hdr.width;
				int const bmp_height = bmp_hdr.height;
				char *canvas_cache = calloc(bmp_hdr.size_image, 1);
				
				LP_SDK_ENC_VIDEO_OVERLAY_CANVAS canvas = NULL;
				stSDK_ENC_VIDEO_OVERLAY_PIXEL canvas_pixel;

				SOC_INFO(&quot;IMAGE %dx%d size=%d offset=%d info=%d&quot;, bmp_width, bmp_height, bmp_hdr.size_image, bmp_hdr.off_bits, bmp_hdr.info_size);


				// load image to buf
				if(0 == fseek(bmp_fid, bmp_hdr.off_bits, SEEK_SET)){
					ret = fread(canvas_cache, 1, bmp_hdr.size_image, bmp_fid);
				}
				fclose(bmp_fid);
				bmp_fid = NULL;

				// load to canvas
				//canvas_pixel.argb8888 = 0xffffffff;
				canvas = sdk_enc-&gt;create_overlay_canvas(bmp_width, bmp_height);
				for(i = 0; i &lt; bmp_height; ++i){
					char *const line_offset = canvas_cache + SDK_ALIGNED_BIG_ENDIAN(3 * bmp_width, 4) * (bmp_height - 1 - i) + 2;
					for(ii = 0; ii &lt; bmp_width; ++ii){
						char *const column_offset = line_offset + 3 * ii;

						canvas_pixel.alpha = 0xff;
						canvas_pixel.red = column_offset[0];
						canvas_pixel.green = column_offset[1];
						canvas_pixel.blue = column_offset[2];

						canvas-&gt;put_pixel(canvas, ii, i, canvas_pixel);
					}
				}
				
				//canvas-&gt;fill_rect(canvas, 0, 0, bmp_width, bmp_height, canvas_pixel);

				// free the canvas cache
				free(canvas_cache);
				canvas_cache = NULL;

				return canvas;
			}
		}

		fclose(bmp_fid);
		bmp_fid = NULL;
	}
	return NULL;
	
}


static void enc_release_overlay_canvas(LP_SDK_ENC_VIDEO_OVERLAY_CANVAS canvas)
{
	if(canvas){
		canvas-&gt;width = 0;
		canvas-&gt;height = 0;
		if(canvas-&gt;pixels){
		//	free(canvas-&gt;pixels);		
			SOC_CHECK(HI_MPI_SYS_MmzFree(canvas-&gt;phy_addr,canvas-&gt;pixels));
			canvas-&gt;pixels = NULL; // very important			
		}
		// baccaus the canvas is created from the stock
		// so it's needless to be free
	}
}



static lpSDK_ENC_VIDEO_OVERLAY_ATTR enc_lookup_overlay_byname(int vin, int stream, const char* name)
{
	int i = 0;
	if(vin &lt; HI_VENC_CH_BACKLOG_REF
		&amp;&amp; stream &lt; HI_VENC_STREAM_BACKLOG_REF){
		lpSDK_ENC_VIDEO_OVERLAY_ATTR_SET const overlay_set = &amp;_sdk_enc.attr.video_overlay_set[vin][stream];
		// check name override
		for(i = 0; i &lt; HI_VENC_OVERLAY_BACKLOG_REF; ++i){
			lpSDK_ENC_VIDEO_OVERLAY_ATTR const overlay = &amp;overlay_set-&gt;attr[i];
			//SOC_DEBUG(&quot;Looking up \&quot;%s\&quot;/\&quot;%s\&quot;&quot;, name, overlay-&gt;name);
			if(overlay-&gt;canvas &amp;&amp; 0 == strcmp(overlay-&gt;name, name)){
				// what's my target
				return overlay;
			}
		}
	}
	return NULL;
}

HI_S32 enc_rgn_add_reverse_color_task(TDE_HANDLE handle, 
    TDE2_SURFACE_S *pstForeGround, TDE2_RECT_S *pstForeGroundRect, 
    TDE2_SURFACE_S *pstBackGround, TDE2_RECT_S *pstBackGroundRect)
{
    HI_S32 s32Ret;
    TDE2_OPT_S stOpt = {0};
    
    HI_ASSERT(NULL != pstForeGround);
    HI_ASSERT(NULL != pstForeGroundRect);
    HI_ASSERT(NULL != pstBackGround);
    HI_ASSERT(NULL != pstBackGroundRect);

    stOpt.enAluCmd        = TDE2_ALUCMD_ROP;
    stOpt.enRopCode_Alpha = TDE2_ROP_COPYPEN;
    stOpt.enRopCode_Color = TDE2_ROP_NOT;
    
    s32Ret =  HI_TDE2_Bitblit(handle, pstBackGround, pstBackGroundRect, pstForeGround, 
          pstForeGroundRect, pstBackGround, pstBackGroundRect, &amp;stOpt);
    if (HI_SUCCESS != s32Ret)
    {
        printf(&quot;HI_TDE2_Bitblit fail! s32Ret: 0x%x.\n&quot;, s32Ret);
        return s32Ret;
    }

    return HI_SUCCESS;
    
}


   
HI_S32 enc_rgn_reverse_osd_color_tde(TDE2_SURFACE_S *pstSrcSurface, TDE2_SURFACE_S *pstDstSurface, 
		const VPSS_REGION_INFO_S *pstRgnInfo)

{
	HI_S32 i;
	HI_S32 s32Ret;
	TDE_HANDLE handle;
	TDE2_RECT_S stRect;


	HI_ASSERT(NULL != pstSrcSurface);
	HI_ASSERT(NULL != pstDstSurface);
	HI_ASSERT(NULL != pstRgnInfo);

	s32Ret = HI_TDE2_Open();
	if (HI_SUCCESS != s32Ret)
	{
		printf(&quot;HI_TDE2_Open fail! s32Ret: 0x%x.\n&quot;, s32Ret);
		return s32Ret;
	}

	handle = HI_TDE2_BeginJob();
	if (handle &lt; 0)
	{
		printf(&quot;HI_TDE2_BeginJob fail!\n&quot;);
		return HI_FAILURE;
	}

	stRect.s32Xpos = 0;
	stRect.s32Ypos = 0;
	stRect.u32Width  = pstSrcSurface-&gt;u32Width;
	stRect.u32Height = pstSrcSurface-&gt;u32Height;
	s32Ret = HI_TDE2_QuickCopy(handle, pstSrcSurface, &amp;stRect, pstDstSurface, &amp;stRect);
	if (HI_SUCCESS != s32Ret)
	{
		printf(&quot;HI_TDE2_QuickCopy fail! s32Ret: 0x%x.\n&quot;, s32Ret);
		HI_TDE2_CancelJob(handle);
		return s32Ret;
	}

	for (i = 0; i &lt; pstRgnInfo-&gt;u32RegionNum; ++i)
	{
		stRect.s32Xpos	 = pstRgnInfo-&gt;pstRegion[i].s32X;
		stRect.s32Ypos	 = pstRgnInfo-&gt;pstRegion[i].s32Y;
		stRect.u32Width  = pstRgnInfo-&gt;pstRegion[i].u32Width;
		stRect.u32Height = pstRgnInfo-&gt;pstRegion[i].u32Height;

		s32Ret = enc_rgn_add_reverse_color_task(handle, pstSrcSurface, &amp;stRect, pstDstSurface, &amp;stRect);
		if (HI_SUCCESS != s32Ret)
		{
			printf(&quot;enc_rgn_add_reverse_color_task fail! s32Ret: 0x%x.\n&quot;, s32Ret);
			HI_TDE2_CancelJob(handle);
			return s32Ret;
		}
	}

	s32Ret = HI_TDE2_EndJob(handle, HI_FALSE, HI_FALSE, 5);
	if (HI_SUCCESS != s32Ret)
	{
		printf(&quot;HI_TDE2_EndJob fail! s32Ret: 0x%x.\n&quot;, s32Ret);
		HI_TDE2_CancelJob(handle);
		return s32Ret;
	}

	s32Ret = HI_TDE2_WaitForDone(handle);
	if (HI_SUCCESS != s32Ret)
	{
		printf(&quot;HI_TDE2_WaitForDone fail! s32Ret: 0x%x.\n&quot;, s32Ret);
		return s32Ret;
	}

	return HI_SUCCESS;
}


HI_S32 enc_rgn_conv_osd_cavas_to_tde_surface(TDE2_SURFACE_S *pstSurface, const RGN_CANVAS_INFO_S *pstCanvasInfo)
	
{
    HI_ASSERT((NULL != pstSurface) &amp;&amp; (NULL != pstCanvasInfo));
    
    switch (pstCanvasInfo-&gt;enPixelFmt)
    {
        case PIXEL_FORMAT_RGB_4444:
        {
            pstSurface-&gt;enColorFmt = TDE2_COLOR_FMT_ARGB4444;
            break ;
        }
        case PIXEL_FORMAT_RGB_1555:
        {
            pstSurface-&gt;enColorFmt = TDE2_COLOR_FMT_ARGB1555;
            break ;
        }
        case PIXEL_FORMAT_RGB_8888:
        {
            pstSurface-&gt;enColorFmt = TDE2_COLOR_FMT_ARGB8888;
            break ;
        }
        default :
        {
            printf(&quot;[Func]:%s [Line]:%d [Info]:invalid Osd pixel format(%d)\n&quot;, 
                __FUNCTION__, __LINE__, pstCanvasInfo-&gt;enPixelFmt);
            return HI_FAILURE;
        }
    }

    pstSurface-&gt;bAlphaExt1555 = HI_FALSE;
    pstSurface-&gt;bAlphaMax255  = HI_TRUE;
    pstSurface-&gt;u32PhyAddr    = pstCanvasInfo-&gt;u32PhyAddr;
    pstSurface-&gt;u32Width      = pstCanvasInfo-&gt;stSize.u32Width;
    pstSurface-&gt;u32Height     = pstCanvasInfo-&gt;stSize.u32Height;
    pstSurface-&gt;u32Stride     = pstCanvasInfo-&gt;u32Stride;

    return HI_SUCCESS;
}

HI_VOID *enc_rgn_vpss_osd_reverse_thread()
{	
	pthread_detach(pthread_self());
	
	usleep(1000*1000);
	int handle_num = 0;
	
	while (HI_FALSE == bExitOverlayLoop){		
		while((handle_num &lt; _sdk_enc.attr.overlay_handle_num) &amp;&amp; (HI_FALSE == bExitOverlayRelease) ){			
			if(NULL == _sdk_enc.attr.overlay[handle_num] ){
					handle_num ++ ;				
					continue ;			
			}else{	
				if(0 == strcmp(&quot;clock&quot;,_sdk_enc.attr.overlay[handle_num]-&gt;name)){				
					handle_num ++ ;
					continue;
				}
			}
			RGN_ATTR_S stRgnAttrSet;
			RGN_CHN_ATTR_S stChnAttr;
			HI_S32 i,VpssChn,VpssChn_sub;
			HI_S32 k = 0, j = 0;

			RGN_HANDLE Handle;
			RGN_HANDLE Handle_sub;

			HI_U32 u32OsdRectCnt;
			SIZE_S stSize;
			RGN_OSD_REVERSE_INFO_S stOsdReverseInfo;    

			RECT_S astOsdLumaRect[64];	 
			RECT_S astOsdRevRect[OSD_REVERSE_RGN_MAXCNT];
			HI_U32 au32LumaData[OSD_REVERSE_RGN_MAXCNT];			
			HI_S32 s32Ret = HI_SUCCESS;
					
			TDE2_SURFACE_S stRgnOrignSurface = {0};
			TDE2_SURFACE_S stRgnSurface = {0};
			RGN_CANVAS_INFO_S stCanvasInfo;
			VPSS_REGION_INFO_S stReverseRgnInfo;
			
			MPP_CHN_S stChn;
			MPP_CHN_S stMppChn =  {0};			
			RGN_CHN_ATTR_S stOsdChnAttr = {0};
			lpSDK_ENC_VIDEO_OVERLAY_ATTR  overlay;
		
			int width_max;			
			VPSS_CHN_MODE_S stVpssMode;
			VPSS_CROP_INFO_S stCropInfo;
			int stream_width;
			HI_U32 per_width;
			
			memset(&amp;stOsdReverseInfo, 0, sizeof(stOsdReverseInfo));
		
			Handle                                   = _sdk_enc.attr.overlay_handle[handle_num];
			VpssChn                                  = _sdk_enc.attr.vpss_chn[handle_num];			
			u32OsdRectCnt							 = 16;//32
			stOsdReverseInfo.Handle 				 = Handle;
			stOsdReverseInfo.VpssGrp				 = 0;
			stOsdReverseInfo.VpssChn				 = 2;//VpssChn;
			stOsdReverseInfo.u8PerPixelLumaThrd 	 = 128;
			stOsdReverseInfo.stLumaRgnInfo.u32RegionNum   = u32OsdRectCnt;
			stOsdReverseInfo.stLumaRgnInfo.pstRegion = astOsdLumaRect;


			if(1 == VpssChn){//main stream
				VpssChn_sub = VpssChn + 1;
				Handle_sub = _sdk_enc.attr.overlay_handle[handle_num + 1];
			}else if (2 == VpssChn){//sub stream  
				VpssChn_sub = VpssChn;
				Handle_sub = Handle;
			}
			if(0 == Handle_sub){
				return -1;
			}
			pthread_mutex_lock(&amp;_sdk_enc.attr.overlayex_mutex);
			SOC_CHECK(HI_MPI_RGN_GetAttr(Handle_sub, &amp;stRgnAttrSet));
			stSize.u32Width  = stRgnAttrSet.unAttr.stOverlay.stSize.u32Width;
			stSize.u32Height = stRgnAttrSet.unAttr.stOverlay.stSize.u32Height;

			stChn.enModId  = HI_ID_VENC;
			stChn.s32DevId = 0;
			stChn.s32ChnId = _hi3518_venc_ch_map[VpssChn_sub]; // 1
			SOC_CHECK(HI_MPI_RGN_GetDisplayAttr(Handle_sub, &amp;stChn, &amp;stChnAttr));
			
			SOC_CHECK(HI_MPI_VPSS_GetChnCrop(0,VpssChn_sub,&amp;stCropInfo));
			SOC_CHECK(HI_MPI_VPSS_GetChnMode(0,VpssChn_sub,&amp;stVpssMode));

			if(stCropInfo.bEnable == 1 ){
				stream_width = stCropInfo.stCropRect.u32Width;				
			}else{
				stream_width = stVpssMode.u32Width ;
			}
			
			per_width = stSize.u32Height;
			u32OsdRectCnt = stSize.u32Width / per_width;
			stOsdReverseInfo.stLumaRgnInfo.u32RegionNum   = u32OsdRectCnt;	
			
			for (i=0;i &lt; u32OsdRectCnt; i++)
			{			  
				width_max = (per_width * (i+1)) + stChnAttr.unChnAttr.stOverlayChn.stPoint.s32X;
			    if( width_max &gt; stream_width){		
			   		stOsdReverseInfo.stLumaRgnInfo.u32RegionNum = i;
					break;			   	
			   	}
				
				astOsdLumaRect[i].s32X = (per_width * i) + stChnAttr.unChnAttr.stOverlayChn.stPoint.s32X;
				astOsdLumaRect[i].s32Y = stChnAttr.unChnAttr.stOverlayChn.stPoint.s32Y;
				astOsdLumaRect[i].u32Width  = per_width;
				astOsdLumaRect[i].u32Height = stSize.u32Height;
			}
			
			overlay = _sdk_enc.attr.overlay[handle_num];
			

			SOC_CHECK(HI_MPI_RGN_GetCanvasInfo(Handle, &amp;stCanvasInfo));
						
			if(NULL == overlay || (NULL != overlay)&amp;&amp;(NULL == overlay-&gt;canvas)){
				SOC_CHECK(HI_MPI_RGN_UpdateCanvas(Handle));
				handle_num ++ ;
				pthread_mutex_unlock(&amp;_sdk_enc.attr.overlayex_mutex);
				continue ;

			}else{
				memcpy(stCanvasInfo.u32VirtAddr,overlay-&gt;canvas-&gt;pixels,
				overlay-&gt;canvas-&gt;width * overlay-&gt;canvas-&gt;height * sizeof(uint16_t));
				stCanvasInfo.stSize.u32Height = overlay-&gt;canvas-&gt;height;
				stCanvasInfo.stSize.u32Width  = overlay-&gt;canvas-&gt;width;
			}

			SOC_CHECK(enc_rgn_conv_osd_cavas_to_tde_surface(&amp;stRgnSurface, &amp;stCanvasInfo));
		    
			stRgnOrignSurface.enColorFmt = TDE2_COLOR_FMT_ARGB4444;
		    stRgnOrignSurface.bAlphaExt1555 = HI_FALSE;
		    stRgnOrignSurface.bAlphaMax255  = HI_TRUE;
		    stRgnOrignSurface.u32PhyAddr    = overlay-&gt;canvas-&gt;phy_addr;
		    stRgnOrignSurface.u32Width      = stCanvasInfo.stSize.u32Width;
		    stRgnOrignSurface.u32Height     = stCanvasInfo.stSize.u32Height;
		    stRgnOrignSurface.u32Stride     = stCanvasInfo.u32Stride;

			/* 3.get the  display attribute of OSD attached to vpss*/

			stMppChn.enModId  = HI_ID_VENC;
			stMppChn.s32DevId = 0;
			stMppChn.s32ChnId = _hi3518_venc_ch_map[VpssChn];//1;

			s32Ret = HI_MPI_RGN_GetDisplayAttr(Handle, &amp;stMppChn, &amp;stOsdChnAttr);

			stReverseRgnInfo.pstRegion = (RECT_S *)astOsdRevRect;	
	
			HI_U32 interval_size;

			/* 4.get the sum of luma of a region specified by user*/
			s32Ret = HI_MPI_VPSS_GetRegionLuma(stOsdReverseInfo.VpssGrp, stOsdReverseInfo.VpssChn, &amp;(stOsdReverseInfo.stLumaRgnInfo), au32LumaData, -1);
	        if (HI_SUCCESS != s32Ret)
		    {
				printf(&quot;[Func]:%s [Line]:%d [Info]:HI_MPI_VPSS_GetRegionLuma VpssGrp=%d failed, s32Ret: 0x%x,overlay name:%s.\n&quot;,
					   __FUNCTION__, __LINE__, stOsdReverseInfo.VpssGrp, s32Ret,_sdk_enc.attr.overlay[handle_num]-&gt;name);
			}	
			/* 5.decide which region to be reverse color according to the sum of the region*/
			for (k = 0, j = 0; k &lt; stOsdReverseInfo.stLumaRgnInfo.u32RegionNum; ++k)
			{	
		
				if (au32LumaData[k] &gt; (stOsdReverseInfo.u8PerPixelLumaThrd * 
					stOsdReverseInfo.stLumaRgnInfo.pstRegion[k].u32Width * 
					stOsdReverseInfo.stLumaRgnInfo.pstRegion[k].u32Height))
				{
					/* 6.get the regions to be reverse color */					
					if(1 == VpssChn){		
						SOC_CHECK(HI_MPI_RGN_GetAttr(Handle, &amp;stRgnAttrSet));
						stSize.u32Width  = stRgnAttrSet.unAttr.stOverlay.stSize.u32Width;
						stSize.u32Height = stRgnAttrSet.unAttr.stOverlay.stSize.u32Height;
						interval_size = stSize.u32Height ;
				
						stReverseRgnInfo.pstRegion[j].s32X = interval_size *k;
						stReverseRgnInfo.pstRegion[j].s32Y = 0;
						stReverseRgnInfo.pstRegion[j].u32Width = interval_size; 	
						stReverseRgnInfo.pstRegion[j].u32Height = stSize.u32Height; 
			//			printf(&quot;main s32X=%d s32Y=%d u32Width=%d u32Height=%d\n&quot;,stReverseRgnInfo.pstRegion[j].s32X,
			//				stReverseRgnInfo.pstRegion[j].s32Y,stReverseRgnInfo.pstRegion[j].u32Width,
			//				stReverseRgnInfo.pstRegion[j].u32Height);
						++j;
					}else if (2 == VpssChn){
						stReverseRgnInfo.pstRegion[j].s32X = stOsdReverseInfo.stLumaRgnInfo.pstRegion[k].s32X 
							- stOsdChnAttr.unChnAttr.stOverlayChn.stPoint.s32X;
						stReverseRgnInfo.pstRegion[j].s32Y = stOsdReverseInfo.stLumaRgnInfo.pstRegion[k].s32Y 
							- stOsdChnAttr.unChnAttr.stOverlayChn.stPoint.s32Y;
						stReverseRgnInfo.pstRegion[j].u32Width = stOsdReverseInfo.stLumaRgnInfo.pstRegion[k].u32Width;
						stReverseRgnInfo.pstRegion[j].u32Height = stOsdReverseInfo.stLumaRgnInfo.pstRegion[k].u32Height;	
			//			printf(&quot;sub s32X=%d s32Y=%d u32Width=%d u32Height=%d\n&quot;,stReverseRgnInfo.pstRegion[j].s32X,
			//				stReverseRgnInfo.pstRegion[j].s32Y,stReverseRgnInfo.pstRegion[j].u32Width,
			//				stReverseRgnInfo.pstRegion[j].u32Height);
						++j;
					}

				}
			}
			
			stReverseRgnInfo.u32RegionNum = j;
			if(NULL == overlay || (NULL != overlay)&amp;&amp;(NULL == overlay-&gt;canvas)){
				SOC_CHECK(HI_MPI_RGN_UpdateCanvas(Handle));
				handle_num ++ ;
				pthread_mutex_unlock(&amp;_sdk_enc.attr.overlayex_mutex);
				continue ;
			}else{
				/* 8.reverse color */
#if 0				
				enc_rgn_reverse_osd_color_tde(&amp;stRgnOrignSurface, &amp;stRgnSurface, &amp;stReverseRgnInfo);
#endif
			}
			// 9.update OSD 	
			SOC_CHECK(HI_MPI_RGN_UpdateCanvas(Handle));
			pthread_mutex_unlock(&amp;_sdk_enc.attr.overlayex_mutex);
			handle_num++;
		}
		handle_num = 0;		
		usleep(500*1000);
	}
	pthread_exit(NULL);
	return 0;
}

static int enc_rgn_vpss_osd_reverse(int handle_num_id)
{	

	int handle_num = handle_num_id;
	RGN_ATTR_S stRgnAttrSet;
	RGN_CHN_ATTR_S stChnAttr;
	HI_S32 i,VpssChn,VpssChn_sub;
	HI_S32 k = 0, j = 0;

	RGN_HANDLE Handle;
	RGN_HANDLE Handle_sub;
	
	HI_U32 u32OsdRectCnt;
	SIZE_S stSize;
	RGN_OSD_REVERSE_INFO_S stOsdReverseInfo;	

	RECT_S astOsdLumaRect[64];	 
	RECT_S astOsdRevRect[OSD_REVERSE_RGN_MAXCNT];
	HI_U32 au32LumaData[OSD_REVERSE_RGN_MAXCNT];			
	HI_S32 s32Ret = HI_SUCCESS;
			
	TDE2_SURFACE_S stRgnOrignSurface = {0};
	TDE2_SURFACE_S stRgnSurface = {0};
	RGN_CANVAS_INFO_S stCanvasInfo;
	VPSS_REGION_INFO_S stReverseRgnInfo;

	MPP_CHN_S stChn;
	MPP_CHN_S stMppChn =  {0};			
	RGN_CHN_ATTR_S stOsdChnAttr = {0};
	lpSDK_ENC_VIDEO_OVERLAY_ATTR  overlay;

	int width_max;			
	VPSS_CHN_MODE_S stVpssMode;
	VPSS_CROP_INFO_S stCropInfo;
	int stream_width;
	HI_U32 per_width;

	if(NULL == _sdk_enc.attr.overlay[handle_num]){
		return -1 ;			
	}else{			
		overlay = _sdk_enc.attr.overlay[handle_num];
	}
	
	memset(&amp;stOsdReverseInfo, 0, sizeof(stOsdReverseInfo));

	Handle									 = _sdk_enc.attr.overlay_handle[handle_num];
	VpssChn 								 = _sdk_enc.attr.vpss_chn[handle_num];			
	u32OsdRectCnt							 = 16;//32;
	stOsdReverseInfo.Handle 				 = Handle;
	stOsdReverseInfo.VpssGrp				 = 0;
	stOsdReverseInfo.VpssChn				 = 2;
	stOsdReverseInfo.u8PerPixelLumaThrd 	 = 128;
	stOsdReverseInfo.stLumaRgnInfo.u32RegionNum   = u32OsdRectCnt;
	stOsdReverseInfo.stLumaRgnInfo.pstRegion = astOsdLumaRect;
	
	if(1 == VpssChn){//main stream
		VpssChn_sub = VpssChn + 1;
		Handle_sub = _sdk_enc.attr.overlay_handle[handle_num + 1];
	}else if (2 == VpssChn){//sub stream  
		VpssChn_sub = VpssChn;
		Handle_sub = Handle;
	}
	if(0 == Handle_sub){
		return -1;
	}
	
	
	pthread_mutex_lock(&amp;_sdk_enc.attr.overlayex_mutex);
	SOC_CHECK(HI_MPI_RGN_GetAttr(Handle_sub, &amp;stRgnAttrSet));
	stSize.u32Width  = stRgnAttrSet.unAttr.stOverlay.stSize.u32Width;
	stSize.u32Height = stRgnAttrSet.unAttr.stOverlay.stSize.u32Height;

	stChn.enModId  = HI_ID_VENC;
	stChn.s32DevId = 0;
	stChn.s32ChnId = _hi3518_venc_ch_map[VpssChn_sub]; // 1
	SOC_CHECK(HI_MPI_RGN_GetDisplayAttr(Handle_sub, &amp;stChn, &amp;stChnAttr));

	SOC_CHECK(HI_MPI_VPSS_GetChnCrop(0,VpssChn_sub,&amp;stCropInfo));
	SOC_CHECK(HI_MPI_VPSS_GetChnMode(0,VpssChn_sub,&amp;stVpssMode));

	if(stCropInfo.bEnable == 1 ){
		stream_width = stCropInfo.stCropRect.u32Width;				
	}else{
		stream_width = stVpssMode.u32Width ;
	}
	
	per_width = stSize.u32Height;
	u32OsdRectCnt = stSize.u32Width / per_width;
	stOsdReverseInfo.stLumaRgnInfo.u32RegionNum   = u32OsdRectCnt;
						
	for (i=0;i &lt; u32OsdRectCnt; i++)
	{			  
		width_max = (per_width * (i+1)) + stChnAttr.unChnAttr.stOverlayChn.stPoint.s32X;
		if( width_max &gt; stream_width){		
			stOsdReverseInfo.stLumaRgnInfo.u32RegionNum = i;
			break;				
		}
		astOsdLumaRect[i].s32X = (per_width * i) + stChnAttr.unChnAttr.stOverlayChn.stPoint.s32X;
		astOsdLumaRect[i].s32Y = stChnAttr.unChnAttr.stOverlayChn.stPoint.s32Y;
		astOsdLumaRect[i].u32Width	= per_width;
		astOsdLumaRect[i].u32Height = stSize.u32Height;
	//	printf(&quot;[%d] s32X=%d ,s32Y=%d ,u32Width=%d,u32Height=%d \n&quot;,i,astOsdLumaRect[i].s32X,astOsdLumaRect[i].s32Y,
	//		astOsdLumaRect[i].u32Width,astOsdLumaRect[i].u32Height);
	}

	SOC_CHECK(HI_MPI_RGN_GetCanvasInfo(Handle, &amp;stCanvasInfo));
				
	if(NULL == overlay || (NULL != overlay)&amp;&amp;(NULL == overlay-&gt;canvas)){
		SOC_CHECK(HI_MPI_RGN_UpdateCanvas(Handle));	
		pthread_mutex_unlock(&amp;_sdk_enc.attr.overlayex_mutex);
		return -1 ;
	}else{
		memcpy(stCanvasInfo.u32VirtAddr,overlay-&gt;canvas-&gt;pixels,
		overlay-&gt;canvas-&gt;width * overlay-&gt;canvas-&gt;height * sizeof(uint16_t));
		stCanvasInfo.stSize.u32Height = overlay-&gt;canvas-&gt;height;
		stCanvasInfo.stSize.u32Width  = overlay-&gt;canvas-&gt;width;
	}

	SOC_CHECK(enc_rgn_conv_osd_cavas_to_tde_surface(&amp;stRgnSurface, &amp;stCanvasInfo));

	stRgnOrignSurface.enColorFmt = TDE2_COLOR_FMT_ARGB4444;
	stRgnOrignSurface.bAlphaExt1555 = HI_FALSE;
	stRgnOrignSurface.bAlphaMax255	= HI_TRUE;
	stRgnOrignSurface.u32PhyAddr	= overlay-&gt;canvas-&gt;phy_addr;
	stRgnOrignSurface.u32Width		= stCanvasInfo.stSize.u32Width;
	stRgnOrignSurface.u32Height 	= stCanvasInfo.stSize.u32Height;
	stRgnOrignSurface.u32Stride 	= stCanvasInfo.u32Stride;

	/* 3.get the  display attribute of OSD attached to vpss*/
	stMppChn.enModId  = HI_ID_VENC;
	stMppChn.s32DevId = 0;
	stMppChn.s32ChnId = _hi3518_venc_ch_map[VpssChn];//1;
	s32Ret = HI_MPI_RGN_GetDisplayAttr(Handle, &amp;stMppChn, &amp;stOsdChnAttr);

	stReverseRgnInfo.pstRegion = (RECT_S *)astOsdRevRect;	

	HI_U32 interval_size;
	
	/* 4.get the sum of luma of a region specified by user*/
	s32Ret = HI_MPI_VPSS_GetRegionLuma(stOsdReverseInfo.VpssGrp, stOsdReverseInfo.VpssChn, &amp;(stOsdReverseInfo.stLumaRgnInfo), au32LumaData, -1);
	if (HI_SUCCESS != s32Ret)			
	{
		printf(&quot;[Func]:%s [Line]:%d [Info]:HI_MPI_VPSS_GetRegionLuma VpssGrp=%d failed, s32Ret: 0x%x,overlay name:%s.\n&quot;,
			   __FUNCTION__, __LINE__, stOsdReverseInfo.VpssGrp, s32Ret,_sdk_enc.attr.overlay[handle_num]-&gt;name);
	}
	/* 5.decide which region to be reverse color according to the sum of the region*/
	for (k = 0, j = 0; k &lt; stOsdReverseInfo.stLumaRgnInfo.u32RegionNum; ++k)
	{	

		if (au32LumaData[k] &gt; (stOsdReverseInfo.u8PerPixelLumaThrd * 
			stOsdReverseInfo.stLumaRgnInfo.pstRegion[k].u32Width * 
			stOsdReverseInfo.stLumaRgnInfo.pstRegion[k].u32Height))
		{
			/* 6.get the regions to be reverse color */
			
			if(1 == VpssChn){		
				SOC_CHECK(HI_MPI_RGN_GetAttr(Handle, &amp;stRgnAttrSet));
				stSize.u32Width  = stRgnAttrSet.unAttr.stOverlay.stSize.u32Width;
				stSize.u32Height = stRgnAttrSet.unAttr.stOverlay.stSize.u32Height;
				interval_size = stSize.u32Height;				

				stReverseRgnInfo.pstRegion[j].s32X = interval_size *k;
				stReverseRgnInfo.pstRegion[j].s32Y = 0;
				stReverseRgnInfo.pstRegion[j].u32Width = interval_size;		
				stReverseRgnInfo.pstRegion[j].u32Height = stSize.u32Height; 
	//			printf(&quot;main s32X=%d s32Y=%d u32Width=%d u32Height=%d\n&quot;,stReverseRgnInfo.pstRegion[j].s32X,
	//				stReverseRgnInfo.pstRegion[j].s32Y,stReverseRgnInfo.pstRegion[j].u32Width,
	//				stReverseRgnInfo.pstRegion[j].u32Height);
				++j;
			}else if (2 == VpssChn){
				stReverseRgnInfo.pstRegion[j].s32X = stOsdReverseInfo.stLumaRgnInfo.pstRegion[k].s32X 
					- stOsdChnAttr.unChnAttr.stOverlayChn.stPoint.s32X;
				stReverseRgnInfo.pstRegion[j].s32Y = stOsdReverseInfo.stLumaRgnInfo.pstRegion[k].s32Y 
					- stOsdChnAttr.unChnAttr.stOverlayChn.stPoint.s32Y;
				stReverseRgnInfo.pstRegion[j].u32Width = stOsdReverseInfo.stLumaRgnInfo.pstRegion[k].u32Width;
				stReverseRgnInfo.pstRegion[j].u32Height = stOsdReverseInfo.stLumaRgnInfo.pstRegion[k].u32Height;	
	//			printf(&quot;sub s32X=%d s32Y=%d u32Width=%d u32Height=%d\n&quot;,stReverseRgnInfo.pstRegion[j].s32X,
	//				stReverseRgnInfo.pstRegion[j].s32Y,stReverseRgnInfo.pstRegion[j].u32Width,
	//				stReverseRgnInfo.pstRegion[j].u32Height);
				++j;
			}

		}
	}

	stReverseRgnInfo.u32RegionNum = j;
	if(NULL == overlay || (NULL != overlay)&amp;&amp;(NULL == overlay-&gt;canvas)){
		SOC_CHECK(HI_MPI_RGN_UpdateCanvas(Handle));		
		pthread_mutex_unlock(&amp;_sdk_enc.attr.overlayex_mutex);
		return -1 ;

	}else{
		/* 8.reverse color */
#if 0 
		enc_rgn_reverse_osd_color_tde(&amp;stRgnOrignSurface, &amp;stRgnSurface, &amp;stReverseRgnInfo);		
#endif
	}
	// 9.update OSD 
	SOC_CHECK(HI_MPI_RGN_UpdateCanvas(Handle));
	pthread_mutex_unlock(&amp;_sdk_enc.attr.overlayex_mutex);

	return 0;
}


static int enc_create_overlay(int vin, int stream, const char* overlay_name,
		float x, float y, LP_SDK_ENC_VIDEO_OVERLAY_CANVAS const canvas)
{
	int i = 0;	
	static pthread_t stOsdReverseThread = NULL;
	
	if(NULL != canvas
		&amp;&amp; vin &lt; HI_VENC_CH_BACKLOG_REF
		&amp;&amp; stream &lt; HI_VENC_STREAM_BACKLOG_REF ){
		int canvas_x = 0, canvas_y = 0;
		size_t canvas_width = 0, canvas_height = 0;
		LP_SDK_ENC_STREAM_H264_ATTR const streamH264Attr = &amp;_sdk_enc.attr.h264_attr[vin][stream];
		lpSDK_ENC_VIDEO_OVERLAY_ATTR_SET const overlay_set = &amp;_sdk_enc.attr.video_overlay_set[vin][stream];
		
		// check name override
		if(NULL != enc_lookup_overlay_byname(vin, stream, overlay_name)){
			SOC_DEBUG(&quot;Overlay name %s override&quot;, overlay_name);
			return -1;
		}
		//printf(&quot;rect: %f/%f %d/%d\n&quot;, x, y, streamH264Attr-&gt;width, streamH264Attr-&gt;height);

		
		VPSS_CHN_MODE_S stVpssMode;
		VPSS_CROP_INFO_S stCropInfo;	
		HI_S32 VpssChn = _hi3518_vpss_ch_map[__HI_VENC_CH(vin, stream)];
		
		SOC_CHECK(HI_MPI_VPSS_GetChnCrop(0,VpssChn,&amp;stCropInfo));
		SOC_CHECK(HI_MPI_VPSS_GetChnMode(vin,VpssChn,&amp;stVpssMode));

		canvas_width = canvas-&gt;width;
		canvas_height = canvas-&gt;height;
		
		// width /height	
		if(stCropInfo.bEnable == 1){
			canvas_x = (typeof(canvas_x))(x * (float)(streamH264Attr-&gt;width) * stCropInfo.stCropRect.u32Width / stVpssMode.u32Width);			
			canvas_y = (typeof(canvas_y))(y * (float)(streamH264Attr-&gt;height) * stCropInfo.stCropRect.u32Height / stVpssMode.u32Height);

			if((canvas_x + canvas-&gt;width) &gt; streamH264Attr-&gt;width){
				canvas_x = streamH264Attr-&gt;width - canvas-&gt;width;
			}			
			if((canvas_y + canvas_height) &gt; streamH264Attr-&gt;height){
				canvas_y = streamH264Attr-&gt;height - canvas-&gt;height;
			}
		}else {
			canvas_x = (typeof(canvas_x))(x * (float)(streamH264Attr-&gt;width));			
			canvas_y = (typeof(canvas_y))(y * (float)(streamH264Attr-&gt;height));
			if((canvas_x + canvas-&gt;width) &gt; streamH264Attr-&gt;width){
				if(stream == 0){
					canvas_x = canvas_x - 100;
				}else if(stream == 1){
					canvas_x = canvas_x - 60;
				}										 
			}
			if((canvas_y + canvas_height) &gt; streamH264Attr-&gt;height){
				canvas_y = streamH264Attr-&gt;height - canvas-&gt;height;
			}
		}

		// alignment
		canvas_x = SDK_ALIGNED_BIG_ENDIAN(canvas_x, 4);
		canvas_y = SDK_ALIGNED_BIG_ENDIAN(canvas_y, 4);
		canvas_width = SDK_ALIGNED_BIG_ENDIAN(canvas_width, 2);
		canvas_height = SDK_ALIGNED_BIG_ENDIAN(canvas_height, 2);

		if(stCropInfo.bEnable == 1){
			if((canvas_x + canvas_width &gt; stCropInfo.stCropRect.u32Width) &amp;&amp; (canvas_x &gt; 4)){
				canvas_x = canvas_x -4;
			}
			if((canvas_y + canvas_height &gt; stCropInfo.stCropRect.u32Height) &amp;&amp; (canvas_y &gt; 4)){
				canvas_y = canvas_y - 4;
			}
		}else{			
			if((canvas_x + canvas_width &gt; stVpssMode.u32Width) &amp;&amp; (canvas_x &gt; 4)){
				canvas_x = canvas_x -4;
			}
			if((canvas_y + canvas_height &gt; stVpssMode.u32Height) &amp;&amp; (canvas_y &gt; 4)){
				canvas_y = canvas_y - 4;
			}
		}

		if(canvas_x &lt; 0){
			canvas_x = 0;	
		}
		if(canvas_y &lt; 0){
			canvas_y = 0;
		}
		
		for(i = 0; i &lt; HI_VENC_OVERLAY_BACKLOG_REF; ++i){
			lpSDK_ENC_VIDEO_OVERLAY_ATTR const overlay = &amp;overlay_set-&gt;attr[i];
			if(!overlay-&gt;canvas){
				overlay-&gt;canvas = canvas;
				snprintf(overlay-&gt;name, sizeof(overlay-&gt;name), &quot;%s&quot;, overlay_name);
				overlay-&gt;x = canvas_x;
				overlay-&gt;y = canvas_y;
				overlay-&gt;width = canvas_width;
				overlay-&gt;height = canvas_height;
				//printf(&quot;rect: %d/%d %d/%d\n&quot;, overlay-&gt;x, overlay-&gt;y, overlay-&gt;width, overlay-&gt;height);
				if(1){//if(overlay-&gt;region_handle &gt;= 0){
					RGN_HANDLE const region_vpss_handle = overlay-&gt;region_handle;
					
					RGN_ATTR_S region_attr;
					RGN_CHN_ATTR_S region_ch_attr;
					MPP_CHN_S mppChannelVENC;

					///Attach To venc chn
					MPP_CHN_S stVpssChn;
					HI_S32 VpssChn;				
					int handle_num;
					VpssChn = _hi3518_vpss_ch_map[__HI_VENC_CH(vin, stream)];
			
					memset(&amp;region_attr, 0, sizeof(region_attr));
					region_attr.enType = OVERLAY_RGN;
					region_attr.unAttr.stOverlay.enPixelFmt = PIXEL_FORMAT_RGB_4444;
					region_attr.unAttr.stOverlay.stSize.u32Width = overlay-&gt;width;
					region_attr.unAttr.stOverlay.stSize.u32Height = overlay-&gt;height;
					region_attr.unAttr.stOverlay.u32BgColor = 0;
					SOC_CHECK(HI_MPI_RGN_Create(region_vpss_handle, &amp;region_attr));
					
					memset(&amp;mppChannelVENC, 0, sizeof(mppChannelVENC));
					mppChannelVENC.enModId  = HI_ID_VENC;
					mppChannelVENC.s32DevId = 0;
					mppChannelVENC.s32ChnId = _hi3518_venc_ch_map[VpssChn];//VpssChn;  
					memset(&amp;region_ch_attr,0,sizeof(region_ch_attr));
						
					region_ch_attr.bShow = HI_TRUE;
					region_ch_attr.enType = OVERLAY_RGN;
					
					region_ch_attr.unChnAttr.stOverlayChn.stPoint.s32X = overlay-&gt;x;   //0
					region_ch_attr.unChnAttr.stOverlayChn.stPoint.s32Y = overlay-&gt;y;   //680
					region_ch_attr.unChnAttr.stOverlayChn.u32BgAlpha = 0;
					region_ch_attr.unChnAttr.stOverlayChn.u32FgAlpha = 64;
					region_ch_attr.unChnAttr.stOverlayChn.u32Layer = 0;	
					

			        region_ch_attr.unChnAttr.stOverlayChn.stQpInfo.bAbsQp = HI_FALSE;
			        region_ch_attr.unChnAttr.stOverlayChn.stQpInfo.s32Qp  = 0;					
				//	region_ch_attr.unChnAttr.stOverlayChn.stQpInfo.bQpDisable  = HI_FALSE;
					region_ch_attr.unChnAttr.stOverlayChn.stInvertColor.bInvColEn = HI_FALSE;

					SOC_CHECK(HI_MPI_RGN_AttachToChn(region_vpss_handle, &amp;mppChannelVENC, &amp;region_ch_attr));


				}
								return 0;
			}
		}
	}
	return -1;
}

static int enc_release_overlay(int vin, int stream, const char* overlay_name)
{
	if(vin &lt; HI_VENC_CH_BACKLOG_REF
		&amp;&amp; stream &lt; HI_VENC_STREAM_BACKLOG_REF ){
		lpSDK_ENC_VIDEO_OVERLAY_ATTR const overlay = enc_lookup_overlay_byname(vin, stream, overlay_name);
		if(NULL != overlay){			
			overlay-&gt;canvas = NULL;
		
		//	SOC_CHECK(HI_MPI_RGN_DetachFrmChn(overlay-&gt;region_handle, &amp;mppChannelVPSS));			
			SOC_CHECK(HI_MPI_RGN_Destroy(overlay-&gt;region_handle));
			return 0;
		}
	}
	return -1;
}

static LP_SDK_ENC_VIDEO_OVERLAY_CANVAS enc_get_overlay_canvas(int vin, int stream, const char* overlay_name)
{
	lpSDK_ENC_VIDEO_OVERLAY_ATTR overlay = enc_lookup_overlay_byname(vin, stream, overlay_name);
	if(overlay){
		return overlay-&gt;canvas;
	}
	return NULL;
}

static int enc_show_overlay(int vin, int stream, const char* overlayName, bool showFlag)
{
	if(vin &lt; HI_VENC_CH_BACKLOG_REF
		&amp;&amp; stream &lt; HI_VENC_STREAM_BACKLOG_REF){
		lpSDK_ENC_VIDEO_OVERLAY_ATTR const overlay = enc_lookup_overlay_byname(vin, stream, overlayName);
		if(NULL != overlay){
			RGN_HANDLE const regionHandle = overlay-&gt;region_handle;
			MPP_CHN_S mppChannel;
			RGN_CHN_ATTR_S regionChannelAttr;
	/*		
			mppChannel.enModId =  HI_ID_VPSS;
		    mppChannel.s32DevId = 0;
		    mppChannel.s32ChnId =  _hi3518_vpss_ch_map[__HI_VENC_CH(vin, stream)];
	*/		
			mppChannel.enModId =  HI_ID_VENC;
		    mppChannel.s32DevId = 0;
		    mppChannel.s32ChnId =  __HI_VENC_CH(vin, stream);
			SOC_CHECK(HI_MPI_RGN_GetDisplayAttr(regionHandle, &amp;mppChannel, &amp;regionChannelAttr));
			if(0 != showFlag){
				regionChannelAttr.bShow = HI_TRUE;
			}else{
				regionChannelAttr.bShow = HI_FALSE;
			}
			//SOC_NOTICE(&quot;region_ch_attr.bShow = %x/%x&quot;, showFlag, regionChannelAttr.bShow);
		    SOC_CHECK(HI_MPI_RGN_SetDisplayAttr(regionHandle, &amp;mppChannel, &amp;regionChannelAttr));			
			return 0;
		}
	}
	return -1;
}

static int enc_update_overlay(int vin, int stream, const char* overlay_name)
{
	if(vin &lt; HI_VENC_CH_BACKLOG_REF
		&amp;&amp; stream &lt; HI_VENC_STREAM_BACKLOG_REF){
		lpSDK_ENC_VIDEO_OVERLAY_ATTR const overlay = enc_lookup_overlay_byname(vin, stream, overlay_name);
		if(NULL != overlay){
			RGN_HANDLE const region_handle = overlay-&gt;region_handle;
			BITMAP_S overlay_bitmap;
			overlay_bitmap.enPixelFormat = PIXEL_FORMAT_RGB_4444;
			overlay_bitmap.u32Width = overlay-&gt;canvas-&gt;width;
			overlay_bitmap.u32Height = overlay-&gt;canvas-&gt;height;
			overlay_bitmap.pData = overlay-&gt;canvas-&gt;pixels;
			SOC_CHECK(HI_MPI_RGN_SetBitMap(region_handle, &amp;overlay_bitmap));
			return 0;
		}
	}
	return -1;
}

static int hi3518e_enc_eptz_ctrl(int vin, int stream, int cmd, int param)
{
	return 0;
}

static int hi3518e_enc_usr_mode(int vin, int stream, int fix_mode, int show_mode)
{
	return 0;
}

static int hi3518_mpi_init()
{
    HI_S32 s32Ret;
    VB_CONF_S struVbConf;
    MPP_SYS_CONF_S struSysConf;

    HI_MPI_SYS_Exit();
    HI_MPI_VB_Exit();

    memset(&amp;struVbConf, 0, sizeof(VB_CONF_S));
    s32Ret = HI_MPI_VB_SetConf(&amp;struVbConf);
    if (HI_SUCCESS != s32Ret)
    {
        printf(&quot;HI_MPI_VB_SetConf fail,Error(%#x)\n&quot;, s32Ret);
        return s32Ret;
    }
    s32Ret = HI_MPI_VB_Init();
    if (HI_SUCCESS != s32Ret)
    {
        printf(&quot;HI_MPI_VB_Init fail,Error(%#x)\n&quot;, s32Ret);
        return s32Ret;
    }

    s32Ret = HI_MPI_SYS_Init();
    if (HI_SUCCESS != s32Ret)
    {
        printf(&quot;HI_MPI_SYS_Init fail,Error(%#x)\n&quot;, s32Ret);
        (HI_VOID)HI_MPI_VB_Exit();
        return s32Ret;
    }

    return HI_SUCCESS;
}

/**************************************************************************************
**描述:内存映射，根据长度在mmz映射相同长度的内存给用户空间
**返回:虚拟地址
***************************************************************************************/
static void  *hi3518e_enc_sdk_mmap(void *param)
{
	umount2(&quot;/media/custom&quot;, MNT_DETACH);// like 'umount -l'
	VB_BLK VbBlk;
	HI_U8* pVirAddr;
	HI_U32 u32PhyAddr;
	VB_POOL VbPool;
	//APP_OVERLAY_destroy();
	SDK_ENC_destroy();
/*	
	SDK_ISP_destroy();
	SDK_destroy_vin();
	sdk_audio-&gt;release_ain_ch(0);
	sdk_audio-&gt;destroy_ain();
	sdk_audio-&gt;release_ain_ch(0);
	sdk_audio-&gt;destroy_ain();
	SDK_destroy_audio();
	SDK_destroy_sys();
*/
	//OVERLAY_destroy();
	ssize_t length = *((ssize_t *)param);

	if(HI_SUCCESS != hi3518_mpi_init())
	{
		printf(&quot;MPI_Init err\n&quot;);
		return -1;
	}

	/* create a video buffer pool*/
	VbPool = HI_MPI_VB_CreatePool(length,1,&quot;anonymous&quot;);

	if ( VB_INVALID_POOLID == VbPool )
	{
		printf(&quot;create vb err\n&quot;);
		return NULL;
	}

	VbBlk = HI_MPI_VB_GetBlock(VbPool, length, &quot;anonymous&quot;);
	if (VB_INVALID_HANDLE == VbBlk)
	{
	    printf(&quot;HI_MPI_VB_GetBlock err! size:%d\n&quot;, length);
	    return NULL;
	}
	u32PhyAddr = HI_MPI_VB_Handle2PhysAddr(VbBlk);
	if (0 == u32PhyAddr)
	{
	    printf(&quot;HI_MPI_VB_Handle2PhysAddr error\n&quot;);
	    return NULL;
	}
	pVirAddr = HI_MPI_SYS_Mmap(u32PhyAddr, length);
	if(0 == pVirAddr)
	{
		return NULL;
		printf(&quot;HI_MPI_SYS_Mmap error\n&quot;);
	}

	//返回地址
	return pVirAddr;
}
		
int  SDK_unmmap(void *virmem, int length)
{
	return HI_MPI_SYS_Munmap(virmem, length);
}

static int hi3518e_update_overlay_by_text(int vin, int stream, const char* text)
{
	return -1;
}

static void *enc_resolution_reboot(void *arg)
{
	pthread_detach(pthread_self());		
	sleep(3);
	SOC_INFO(&quot;MAIN_RESOLUTION changed,restart!&quot;);
#ifdef F5

#else
	exit(0);
#endif
}

static int hi3518e_enc_resolution(int width, int height)//main resolution
{	

	uint32_t sensor_width_max,sensor_height_max;

	HI_SDK_ISP_get_sensor_resolution(&amp;sensor_width_max, &amp;sensor_height_max);

	if(width &gt;= 720 &amp;&amp; width &lt;= sensor_width_max &amp;&amp;
		height &gt;= 576 &amp;&amp; height &lt;= sensor_height_max){

		FILE *fid0 = fopen(MAIN_RESOLUTION, &quot;rb&quot;);
		char buf[16] = &quot;&quot;;
		char tmp[5] = &quot;&quot;;
		int width_old ,height_old;
		pthread_t pid = NULL;
		bool flag_restart;
		
		if(NULL != fid0){
			fread(buf,sizeof(buf),1,fid0);
			fclose(fid0);
			fid0 = NULL;
			sscanf(buf,&quot;%d %s %d&quot;,&amp;width_old,tmp,&amp;height_old);
		}else{
			SOC_INFO(&quot;Open %s failed&quot;, MAIN_RESOLUTION);
			return -1;	
		}


		if(width_old * height_old &gt;= 1920*1080 || width * height &gt;= 1920*1080){
			flag_restart = true;
		}else{
			flag_restart = false;
		}
				
		FILE *fid = fopen(MAIN_RESOLUTION, &quot;w+b&quot;);
		
		memset(buf,0,sizeof(buf));		
		sprintf(buf,&quot;%d x %d&quot;,width,height);
		if(NULL != fid){
			fwrite(buf,1,strlen(buf),fid);
			fclose(fid);
			fid = NULL;			
			SOC_INFO(&quot;cur resolution: %dx%d ; new resolution: %dx%d \n&quot;,width_old,height_old,width,height);
			if(flag_restart){
				pthread_create(&amp;pid,NULL,enc_resolution_reboot,NULL);				
			}
			return 0;		
		}else{
			SOC_INFO(&quot;Open %s failed&quot;, MAIN_RESOLUTION);
		}
		return -1;	
	}else{
		SOC_INFO(&quot;Resolution size exceeds limit!!&quot;);
		return -1;
	}

}

static stSDK_ENC_HI3521 _sdk_enc =
{
	// init the interfaces
	.api = {
		// h264 stream
		.create_stream_h264 = enc_create_stream_h264,
		.release_stream_h264 = enc_release_stream_h264,
		.enable_stream_h264 = enc_enable_stream_h264,
		.set_stream_h264 = enc_set_stream_h264,
		.get_stream_h264 = enc_get_stream_h264,
		.request_stream_h264_keyframe = enc_request_stream_h264_keyframe,

		//h265 stream
		.create_stream_h265 = enc_create_stream_h265,
		.release_stream_h265 = enc_release_stream_h265,
		.enable_stream_h265 = enc_enable_stream_h265,
		.set_stream_h265 = enc_set_stream_h265,
		.get_stream_h265 = enc_get_stream_h265,
		.request_stream_h265_keyframe = enc_request_stream_h265_keyframe,
		
		.create_stream_g711a = enc_create_stream_g711a,
		.create_audio_stream = enc_create_audio_stream,
		.release_stream_g711a = enc_release_stream_g711a,

		// snapshot a picture
		.creat_snapshot_chn = enc_creat_snapshot_chn,
		.release_snapshot_chn = enc_release_snapshot_chn,
		.snapshot = enc_snapshot,
		// overlay
		.create_overlay_canvas = enc_create_overlay_canvas,
		.load_overlay_canvas = enc_load_overlay_canvas,
		.release_overlay_canvas = enc_release_overlay_canvas,
		.create_overlay = enc_create_overlay,
		.release_overlay = enc_release_overlay,
		.get_overlay_canvas = enc_get_overlay_canvas,
		.show_overlay = enc_show_overlay,
		.update_overlay = enc_update_overlay,

		// encode start / stop
		.start = enc_start,
		.stop = enc_stop,

		//fish eye
		.eptz_ctrl = hi3518e_enc_eptz_ctrl,
		.enc_mode = hi3518e_enc_usr_mode,

		//upgrade
		.upgrade_env_prepare = 	hi3518e_enc_sdk_mmap,	
		.update_overlay_bytext = hi3518e_update_overlay_by_text,

		.enc_resolution = hi3518e_enc_resolution,
		},
};


int SDK_ENC_init()
{
	int i = 0, ii = 0, iii = 0;
	// only 'sdk_enc' pointer is NULL could be init
	if(NULL == sdk_enc){
		// set handler pointer
		sdk_enc = (lpSDK_ENC_API)(&amp;_sdk_enc);
		
		// clear the buffering callback
		sdk_enc-&gt;do_buffer_request = NULL;
		sdk_enc-&gt;do_buffer_append = NULL;
		sdk_enc-&gt;do_buffer_commit = NULL;

		

		// init the internal attribute value
		// clear the stream attrubutes
		// clear the frame counter
		for(i = 0; i &lt; HI_VENC_CH_BACKLOG_REF; ++i){
			for(ii = 0; ii &lt; HI_VENC_STREAM_BACKLOG_REF; ++ii){
				LP_SDK_ENC_STREAM_H264_ATTR const streamH264Attr = &amp;_sdk_enc.attr.h264_attr[i][ii];				
				LP_SDK_ENC_STREAM_H265_ATTR const streamH265Attr = &amp;_sdk_enc.attr.h265_attr[i][ii];
				
				uint8_t *const frame_ref_counter = &amp;_sdk_enc.attr.frame_ref_counter[i][ii];

				STREAM_H264_CLEAR(streamH264Attr);
				STREAM_H264_CLEAR(streamH265Attr);
				*frame_ref_counter = 0;
			}
		}
		// init the overlay set handl
		for(i = 0; i &lt; HI_VENC_CH_BACKLOG_REF; ++i){
			for(ii = 0; ii &lt; HI_VENC_STREAM_BACKLOG_REF; ++ii){
				lpSDK_ENC_VIDEO_OVERLAY_ATTR_SET const overlay_set = &amp;_sdk_enc.attr.video_overlay_set[i][ii];
				for(iii = 0; iii &lt; HI_VENC_OVERLAY_BACKLOG_REF; ++iii){
					lpSDK_ENC_VIDEO_OVERLAY_ATTR const overlay = &amp;overlay_set-&gt;attr[iii];

					overlay-&gt;canvas = NULL;
					memset(overlay-&gt;name, 0, sizeof(overlay-&gt;name));
					overlay-&gt;x = 0;
					overlay-&gt;y = 0;
					overlay-&gt;width = 0;
					overlay-&gt;height = 0;
					// very important, pre-alloc the handle number
					overlay-&gt;region_handle = HI_VENC_OVERLAY_HANDLE_OFFSET;
					overlay-&gt;region_handle += i * HI_VENC_STREAM_BACKLOG_REF * HI_VENC_OVERLAY_BACKLOG_REF;
					overlay-&gt;region_handle += ii * HI_VENC_OVERLAY_BACKLOG_REF;
					overlay-&gt;region_handle += iii;
				}
			}

		}
//		_sdk_enc.attr.overlay_handle_num = 0;
		
		// init the snapshot mutex
		pthread_mutex_init(&amp;_sdk_enc.attr.snapshot_mutex, NULL);

		
		sdk_enc-&gt;creat_snapshot_chn(0,VENC_MAX_CHN_NUM - 2,-1,-1);
		sdk_enc-&gt;creat_snapshot_chn(0,VENC_MAX_CHN_NUM - 1,640,360);
		// start
		//sdk_enc-&gt;start();
		// success to init
		return 0;
	}
	return -1;
}


int SDK_ENC_wdr_destroy()
{	
	if(sdk_enc){
		int i = 0, ii = 0;
	   // release the video encode
		for(i = 0; i &lt; HI_VENC_CH_BACKLOG_REF; ++i){
			for(ii = 0; ii &lt; HI_VENC_STREAM_BACKLOG_REF; ++ii){	// destroy sub stream firstly
				switch(_sdk_enc.attr.enType[i][ii]){
				default:
				case kSDK_ENC_BUF_DATA_H264:					
					sdk_enc-&gt;release_stream_h264(i, ii);
					break;
				case kSDK_ENC_BUF_DATA_H265:
					sdk_enc-&gt;release_stream_h265(i, ii);
					break;	
			    }				
		    }
		}
		return 0;
	}
	return -1;

}

int SDK_ENC_vpss_destroy()
{  
	MPP_CHN_S stSrcChn;
    MPP_CHN_S stDestChn;
	HI_U32 VpssGrp = 0;
	HI_U32 VpssChn;

	// vpss chn 0,1,2,3
	for(VpssChn = 0; VpssChn &lt;=3; VpssChn++){
		HI_MPI_VPSS_DisableChn(VpssGrp,VpssChn);
		usleep(500);
	}

	stSrcChn.enModId = HI_ID_VIU;
	stSrcChn.s32DevId = 0;
	stSrcChn.s32ChnId = 0;

	stDestChn.enModId = HI_ID_VPSS;
	stDestChn.s32DevId = VpssGrp;
	stDestChn.s32ChnId = 0;
	
	HI_MPI_SYS_UnBind(&amp;stSrcChn, &amp;stDestChn);
	HI_MPI_VPSS_StopGrp(VpssGrp);
	HI_MPI_VPSS_DestroyGrp(VpssGrp);
	return 0;
}


int SDK_ENC_destroy()
{	
	SDK_destroy_vin();
	if(sdk_enc){
		int i = 0, ii = 0;
//		bExitOverlayLoop = HI_TRUE;
		
		// destroy the snapshot mutex
		pthread_mutex_destroy(&amp;_sdk_enc.attr.snapshot_mutex);	
		// stop encode firstly
		sdk_enc-&gt;stop();
		
		//release the sanapshot chn
		sdk_enc-&gt;release_snapshot_chn(0,VENC_MAX_CHN_NUM - 2);	//main JPEG
		sdk_enc-&gt;release_snapshot_chn(0,VENC_MAX_CHN_NUM - 1);  //sub JPEG
				
		// release the canvas stock
		for(i = 0; i &lt; HI_VENC_OVERLAY_CANVAS_STOCK_REF; ++i){
			sdk_enc-&gt;release_overlay_canvas(_sdk_enc.attr.canvas_stock + i);
		}
		
		// release the audio encode
		for(i = 0; i &lt; HI_AENC_CH_BACKLOG_REF; ++i){
			sdk_enc-&gt;release_stream_g711a(i);
		}
		// release the video encode
		for(i = 0; i &lt; HI_VENC_CH_BACKLOG_REF; ++i){
			for(ii = 0; ii &lt; HI_VENC_STREAM_BACKLOG_REF; ++ii){
				switch(_sdk_enc.attr.enType[i][ii]){
					default:
					case kSDK_ENC_BUF_DATA_H264:					
						sdk_enc-&gt;release_stream_h264(i, ii);
						break;
					case kSDK_ENC_BUF_DATA_H265:
						sdk_enc-&gt;release_stream_h265(i, ii);
						break;	
				}	
			}
		}		
		// clear handler pointer
		sdk_enc = NULL;		
		// success to destroy
	}
	//destroy vpss	
	SDK_ENC_vpss_destroy();
//	SDK_destroy_vin();
	if(sdk_audio){
		sdk_audio-&gt;release_ain_ch(0);
	}
	SDK_destroy_audio();
	SENSOR_destroy();
	usleep(1000);
	SDK_destroy_sys();

	return 0;
}


int SDK_ENC_create_stream(int vin, int stream, LP_SDK_ENC_STREAM_ATTR stream_attr)
{
	if(sdk_enc){
		int ret;
		_sdk_enc.attr.enType[vin][stream] = stream_attr-&gt;enType;

		switch(stream_attr-&gt;enType){
			default:
			case kSDK_ENC_BUF_DATA_H264:
				ret = sdk_enc-&gt;create_stream_h264(vin, stream,&amp;stream_attr-&gt;H264_attr);
				break;
			case kSDK_ENC_BUF_DATA_H265:
				ret = sdk_enc-&gt;create_stream_h265(vin, stream,&amp;stream_attr-&gt;H265_attr);
				break;	
		}
		return ret;
	}else{
		return -1;

	}

}



int SDK_ENC_release_stream(int vin, int stream)
{
	if(sdk_enc){
		int ret;
		switch(_sdk_enc.attr.enType[vin][stream]){
			default:
			case kSDK_ENC_BUF_DATA_H264:
				ret = sdk_enc-&gt;release_stream_h264(vin,stream);
				break;
			case kSDK_ENC_BUF_DATA_H265:
				ret = sdk_enc-&gt;release_stream_h265(vin,stream);
				break;	
		}
		return ret;
	}else{
		return -1;
	}


}



int SDK_ENC_set_stream(int vin, int stream,LP_SDK_ENC_STREAM_ATTR stream_attr)
{	
	if(sdk_enc){
		int ret;
		switch(stream_attr-&gt;enType){
			default:
			case kSDK_ENC_BUF_DATA_H264:
				ret = sdk_enc-&gt;set_stream_h264(vin, stream,&amp;stream_attr-&gt;H264_attr);
				break;
			case kSDK_ENC_BUF_DATA_H265:
				ret = sdk_enc-&gt;set_stream_h265(vin, stream,&amp;stream_attr-&gt;H265_attr);
				break;	
		}	
		return ret;
	}else{
		return -1;
	}

}


int SDK_ENC_get_stream(int vin, int stream, LP_SDK_ENC_STREAM_ATTR stream_attr)
{
	if(sdk_enc){
		int ret;
		switch(_sdk_enc.attr.enType[vin][stream]){
			default:
			case kSDK_ENC_BUF_DATA_H264:
				ret = sdk_enc-&gt;get_stream_h264(vin, stream,&amp;stream_attr-&gt;H264_attr);
				stream_attr-&gt;enType = kSDK_ENC_BUF_DATA_H264;		
				break;
			case kSDK_ENC_BUF_DATA_H265:
				ret = sdk_enc-&gt;get_stream_h265(vin, stream,&amp;stream_attr-&gt;H265_attr);			
				stream_attr-&gt;enType = kSDK_ENC_BUF_DATA_H265;
				break;	
		}	
		return ret;
	}else{
		return -1;
	}

}

int SDK_ENC_enable_stream(int vin, int stream, bool flag)
{
	if(sdk_enc){
		int ret;
		switch(_sdk_enc.attr.enType[vin][stream]){
			default:
			case kSDK_ENC_BUF_DATA_H264:
				ret = sdk_enc-&gt;enable_stream_h264(vin, stream, flag);
				break;
			case kSDK_ENC_BUF_DATA_H265:
				ret = sdk_enc-&gt;enable_stream_h265(vin, stream, flag);
				break;	
		}
		return ret;
	}else{
		return -1;
	}

}

int	SDK_ENC_request_stream_keyframe(int vin, int stream)
{
	if(sdk_enc){
		switch(_sdk_enc.attr.enType[vin][stream]){
			default:
			case kSDK_ENC_BUF_DATA_H264:
				sdk_enc-&gt;request_stream_h264_keyframe(vin, stream);
				break;
			case kSDK_ENC_BUF_DATA_H265:
				sdk_enc-&gt;request_stream_h265_keyframe(vin, stream);
				break;	
		}
		return 0;
	}else{
		return -1;
	}	

}

PAYLOAD_TYPE_E  SDK_ENC_request_venc_type(int vin, int stream)
{
	VENC_CHN_ATTR_S venc_ch_attr;
	enSDK_ENC_BUF_DATA_TYPE enc_type;
	int const venc_ch = __HI_VENC_CH(vin, stream);
	SOC_CHECK(HI_MPI_VENC_GetChnAttr(venc_ch, &amp;venc_ch_attr));
	switch(venc_ch_attr.stVeAttr.enType){
		default:
		case PT_H264:
			enc_type = kSDK_ENC_BUF_DATA_H264;
			break;
		case PT_H265:
			enc_type = kSDK_ENC_BUF_DATA_H265;
			break;	
	}
	return enc_type;
}

int SDK_ENC_get_enc_pts(int vin, int stream, unsigned long long *encPts)
{
	if(encPts){
		*encPts = _sdk_enc.attr.u64encPTS[vin][stream];
		return 0;
	}
	return -1;
}


</code></pre></div><div class=clear></div></div></div></article><div class=clear></div><p class=post-tags><span class="fa fa-tags">Tags:</span>
<a rel=tag href=../../../../tags/mpp>mpp</a><div id=related-posts><div class=related-inner></div></div><section id=comments class=themeform></section><section id=comments class=themeform></section></div></div><div class="sidebar s1 collapsed" data-position=left data-layout=col-3cm data-sb-id=s1><a class=sidebar-toggle title="Expand Sidebar"><i class="fas icon-sidebar-toggle"></i></a><div class=sidebar-content><div class="sidebar-top group"><p>Follow:<ul class=social-links><li><a class=social-tooltip href=mailto: title=Email><i class="fa fa-envelope"></i></a><li><a class=social-tooltip href=//github.com/ title=GitHub><i class="fa fa-github"></i></a><li><a class=social-tooltip title="RSS Feed" aria-label="RSS Feed" href=../../../../feed target=_blank style=color:#ffffffb2><i class="fa fa-rss"></i></a></ul></div><ul class="post-nav group"><li class=previous><a href=../../../../hardware/kernel/linux-kernel-uvc-usb-camera/ rel=prev><i class="fa fa-chevron-left"></i><strong>Previous Post</strong>
<span>启用linux内核对usb摄像头的支持</span></a></ul><div id=categories-2 class="widget widget_categories"><h3>分类</h3><ul><li class="cat-item cat-item-1"><a href=../../../../categories/ai/>Ai</a>
<small>(7)</small><li class="cat-item cat-item-1"><a href=../../../../categories/algorithm/>Algorithm</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../../categories/android/>Android</a>
<small>(17)</small><li class="cat-item cat-item-1"><a href=../../../../categories/ansible/>Ansible</a>
<small>(2)</small><li class="cat-item cat-item-1"><a href=../../../../categories/beats/>Beats</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../../categories/busybox/>Busybox</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../../categories/caffe/>Caffe</a>
<small>(21)</small><li class="cat-item cat-item-1"><a href=../../../../categories/cgo/>Cgo</a>
<small>(10)</small><li class="cat-item cat-item-1"><a href=../../../../categories/clang/>Clang</a>
<small>(40)</small><li class="cat-item cat-item-1"><a href=../../../../categories/cmd/>Cmd</a>
<small>(2)</small><li class="cat-item cat-item-1"><a href=../../../../categories/cpp/>Cpp</a>
<small>(7)</small><li class="cat-item cat-item-1"><a href=../../../../categories/cross_compile/>Cross_compile</a>
<small>(9)</small><li class="cat-item cat-item-1"><a href=../../../../categories/css/>Css</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../../categories/dart/>Dart</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../../categories/database/>Database</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../../categories/dataset/>Dataset</a>
<small>(2)</small><li class="cat-item cat-item-1"><a href=../../../../categories/deeplearning/>Deeplearning</a>
<small>(2)</small><li class="cat-item cat-item-1"><a href=../../../../categories/devops/>Devops</a>
<small>(70)</small><li class="cat-item cat-item-1"><a href=../../../../categories/docker/>Docker</a>
<small>(18)</small><li class="cat-item cat-item-1"><a href=../../../../categories/dts/>Dts</a>
<small>(5)</small><li class="cat-item cat-item-1"><a href=../../../../categories/elasticsearch/>Elasticsearch</a>
<small>(9)</small><li class="cat-item cat-item-1"><a href=../../../../categories/english/>English</a>
<small>(3)</small><li class="cat-item cat-item-1"><a href=../../../../categories/freertos/>Freertos</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../../categories/front-end/>Front-End</a>
<small>(20)</small><li class="cat-item cat-item-1"><a href=../../../../categories/golang/>Golang</a>
<small>(136)</small><li class="cat-item cat-item-1"><a href=../../../../categories/hacker/>Hacker</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../../categories/hardware/>Hardware</a>
<small>(22)</small><li class="cat-item cat-item-1"><a href=../../../../categories/hi3519a/>Hi3519a</a>
<small>(4)</small><li class="cat-item cat-item-1"><a href=../../../../categories/hi3559/>Hi3559</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../../categories/hisi/>Hisi</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../../categories/hisilicon/>Hisilicon</a>
<small>(57)</small><li class="cat-item cat-item-1"><a href=../../../../categories/jetson/>Jetson</a>
<small>(3)</small><li class="cat-item cat-item-1"><a href=../../../../categories/js/>Js</a>
<small>(9)</small><li class="cat-item cat-item-1"><a href=../../../../categories/jumpserver/>Jumpserver</a>
<small>(2)</small><li class="cat-item cat-item-1"><a href=../../../../categories/kernel/>Kernel</a>
<small>(15)</small><li class="cat-item cat-item-1"><a href=../../../../categories/libev/>Libev</a>
<small>(2)</small><li class="cat-item cat-item-1"><a href=../../../../categories/linux/>Linux</a>
<small>(94)</small><li class="cat-item cat-item-1"><a href=../../../../categories/linux-system/>Linux-System</a>
<small>(8)</small><li class="cat-item cat-item-1"><a href=../../../../categories/linux-%E5%91%BD%E4%BB%A4/>Linux-命令</a>
<small>(120)</small><li class="cat-item cat-item-1"><a href=../../../../categories/mac/>Mac</a>
<small>(2)</small><li class="cat-item cat-item-1"><a href=../../../../categories/machinelearn/>Machinelearn</a>
<small>(3)</small><li class="cat-item cat-item-1"><a href=../../../../categories/machinelearning/>Machinelearning</a>
<small>(11)</small><li class="cat-item cat-item-1"><a href=../../../../categories/macos/>Macos</a>
<small>(12)</small><li class="cat-item cat-item-1"><a href=../../../../categories/math/>Math</a>
<small>(7)</small><li class="cat-item cat-item-1"><a href=../../../../categories/matplotlib/>Matplotlib</a>
<small>(3)</small><li class="cat-item cat-item-1"><a href=../../../../categories/mpp/>Mpp</a>
<small>(12)</small><li class="cat-item cat-item-1"><a href=../../../../categories/mysql/>Mysql</a>
<small>(10)</small><li class="cat-item cat-item-1"><a href=../../../../categories/ncnn/>Ncnn</a>
<small>(3)</small><li class="cat-item cat-item-1"><a href=../../../../categories/network/>Network</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../../categories/nginx/>Nginx</a>
<small>(2)</small><li class="cat-item cat-item-1"><a href=../../../../categories/nnie/>Nnie</a>
<small>(13)</small><li class="cat-item cat-item-1"><a href=../../../../categories/node/>Node</a>
<small>(3)</small><li class="cat-item cat-item-1"><a href=../../../../categories/numpy/>Numpy</a>
<small>(4)</small><li class="cat-item cat-item-1"><a href=../../../../categories/opencpu/>Opencpu</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../../categories/opencv/>Opencv</a>
<small>(10)</small><li class="cat-item cat-item-1"><a href=../../../../categories/pandas/>Pandas</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../../categories/platform/>Platform</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../../categories/post/>Post</a>
<small>(3)</small><li class="cat-item cat-item-1"><a href=../../../../categories/pyqt/>Pyqt</a>
<small>(8)</small><li class="cat-item cat-item-1"><a href=../../../../categories/python/>Python</a>
<small>(31)</small><li class="cat-item cat-item-1"><a href=../../../../categories/pytorch/>Pytorch</a>
<small>(6)</small><li class="cat-item cat-item-1"><a href=../../../../categories/raspi/>Raspi</a>
<small>(4)</small><li class="cat-item cat-item-1"><a href=../../../../categories/rk3288/>Rk3288</a>
<small>(23)</small><li class="cat-item cat-item-1"><a href=../../../../categories/rk3399/>Rk3399</a>
<small>(9)</small><li class="cat-item cat-item-1"><a href=../../../../categories/rtmp/>Rtmp</a>
<small>(2)</small><li class="cat-item cat-item-1"><a href=../../../../categories/scikit/>Scikit</a>
<small>(3)</small><li class="cat-item cat-item-1"><a href=../../../../categories/shell/>Shell</a>
<small>(3)</small><li class="cat-item cat-item-1"><a href=../../../../categories/socket/>Socket</a>
<small>(5)</small><li class="cat-item cat-item-1"><a href=../../../../categories/stm32/>Stm32</a>
<small>(6)</small><li class="cat-item cat-item-1"><a href=../../../../categories/stm8/>Stm8</a>
<small>(9)</small><li class="cat-item cat-item-1"><a href=../../../../categories/weixin/>Weixin</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../../categories/windows/>Windows</a>
<small>(22)</small><li class="cat-item cat-item-1"><a href=../../../../categories/work/>Work</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../../categories/yolo/>Yolo</a>
<small>(16)</small><li class="cat-item cat-item-1"><a href=../../../../categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/>前端技术</a>
<small>(3)</small><li class="cat-item cat-item-1"><a href=../../../../categories/%E5%8D%8F%E8%AE%AE/>协议</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../../categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/>嵌入式</a>
<small>(23)</small><li class="cat-item cat-item-1"><a href=../../../../categories/%E5%B7%A5%E5%85%B7/>工具</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../../categories/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/>常用算法</a>
<small>(2)</small><li class="cat-item cat-item-1"><a href=../../../../categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/>微服务</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../../categories/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/>排列组合</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../../categories/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a>
<small>(37)</small><li class="cat-item cat-item-1"><a href=../../../../categories/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/>文本编辑</a>
<small>(30)</small><li class="cat-item cat-item-1"><a href=../../../../categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/>正则表达式</a>
<small>(3)</small><li class="cat-item cat-item-1"><a href=../../../../categories/%E7%94%9F%E6%B4%BB%E6%8A%80%E5%B7%A7/>生活技巧</a>
<small>(4)</small><li class="cat-item cat-item-1"><a href=../../../../categories/%E7%A8%8B%E5%BA%8F%E5%91%98/>程序员</a>
<small>(1)</small><li class="cat-item cat-item-1"><a href=../../../../categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/>网络安全</a>
<small>(40)</small><li class="cat-item cat-item-1"><a href=../../../../categories/%E9%9B%86%E7%BE%A4%E7%9B%91%E6%8E%A7/>集群监控</a>
<small>(7)</small><li class="cat-item cat-item-1"><a href=../../../../categories/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/>静态博客</a>
<small>(15)</small><li class="cat-item cat-item-1"><a href=../../../../categories/%E9%AB%98%E6%95%B0/>高数</a>
<small>(2)</small></ul></div></div></div><div class="sidebar s2 collapsed" data-position=right data-layout=col-3cm data-sb-id=s2><a class=sidebar-toggle title="Expand Sidebar"><i class="fas icon-sidebar-toggle"></i></a><div class=sidebar-content><div class="sidebar-top group"><p>More</div><ul class="post-nav group"><li class=next><a href=../../../../hardware/stm32/stm32-can/ rel=next><i class="fa fa-chevron-right"></i><strong>Next post</strong>
<span>stm32 can</span></a></ul><div id=tag_cloud-2 class="widget widget_tag_cloud"><h3>标签云</h3><div class="tagcloud post-tags"><a rel=tag href=../../../../tags/ai/ class=tag-link-7 title="1 Posts">ai<small>(7)</small></a>
<a rel=tag href=../../../../tags/ansible/ class=tag-link-19 title="1 Posts">ansible<small>(19)</small></a>
<a rel=tag href=../../../../tags/awesome/ class=tag-link-3 title="1 Posts">awesome<small>(3)</small></a>
<a rel=tag href=../../../../tags/bfc/ class=tag-link-2 title="1 Posts">bfc<small>(2)</small></a>
<a rel=tag href=../../../../tags/c/ class=tag-link-5 title="1 Posts">c<small>(5)</small></a>
<a rel=tag href=../../../../tags/caffe/ class=tag-link-21 title="1 Posts">caffe<small>(21)</small></a>
<a rel=tag href=../../../../tags/centos7/ class=tag-link-2 title="1 Posts">centos7<small>(2)</small></a>
<a rel=tag href=../../../../tags/cgo/ class=tag-link-10 title="1 Posts">cgo<small>(10)</small></a>
<a rel=tag href=../../../../tags/clang/ class=tag-link-40 title="1 Posts">clang<small>(40)</small></a>
<a rel=tag href=../../../../tags/cmd/ class=tag-link-2 title="1 Posts">cmd<small>(2)</small></a>
<a rel=tag href=../../../../tags/cpp/ class=tag-link-7 title="1 Posts">cpp<small>(7)</small></a>
<a rel=tag href=../../../../tags/cross_compile/ class=tag-link-9 title="1 Posts">cross_compile<small>(9)</small></a>
<a rel=tag href=../../../../tags/css/ class=tag-link-20 title="1 Posts">css<small>(20)</small></a>
<a rel=tag href=../../../../tags/css3/ class=tag-link-2 title="1 Posts">css3<small>(2)</small></a>
<a rel=tag href=../../../../tags/curd/ class=tag-link-3 title="1 Posts">curd<small>(3)</small></a>
<a rel=tag href=../../../../tags/curl/ class=tag-link-2 title="1 Posts">curl<small>(2)</small></a>
<a rel=tag href=../../../../tags/dataset/ class=tag-link-2 title="1 Posts">dataset<small>(2)</small></a>
<a rel=tag href=../../../../tags/devops/ class=tag-link-3 title="1 Posts">devops<small>(3)</small></a>
<a rel=tag href=../../../../tags/docker/ class=tag-link-21 title="1 Posts">docker<small>(21)</small></a>
<a rel=tag href=../../../../tags/drone/ class=tag-link-22 title="1 Posts">drone<small>(22)</small></a>
<a rel=tag href=../../../../tags/dts/ class=tag-link-6 title="1 Posts">dts<small>(6)</small></a>
<a rel=tag href=../../../../tags/elasticsearch/ class=tag-link-9 title="1 Posts">elasticsearch<small>(9)</small></a>
<a rel=tag href=../../../../tags/emacs/ class=tag-link-12 title="1 Posts">emacs<small>(12)</small></a>
<a rel=tag href=../../../../tags/encode/ class=tag-link-3 title="1 Posts">encode<small>(3)</small></a>
<a rel=tag href=../../../../tags/english/ class=tag-link-8 title="1 Posts">english<small>(8)</small></a>
<a rel=tag href=../../../../tags/es6/ class=tag-link-2 title="1 Posts">es6<small>(2)</small></a>
<a rel=tag href=../../../../tags/etcd/ class=tag-link-4 title="1 Posts">etcd<small>(4)</small></a>
<a rel=tag href=../../../../tags/flannel/ class=tag-link-2 title="1 Posts">flannel<small>(2)</small></a>
<a rel=tag href=../../../../tags/git/ class=tag-link-6 title="1 Posts">git<small>(6)</small></a>
<a rel=tag href=../../../../tags/github/ class=tag-link-2 title="1 Posts">github<small>(2)</small></a>
<a rel=tag href=../../../../tags/golang/ class=tag-link-150 title="1 Posts">golang<small>(150)</small></a>
<a rel=tag href=../../../../tags/gradle/ class=tag-link-3 title="1 Posts">gradle<small>(3)</small></a>
<a rel=tag href=../../../../tags/haproxy/ class=tag-link-5 title="1 Posts">haproxy<small>(5)</small></a>
<a rel=tag href=../../../../tags/hardware/ class=tag-link-22 title="1 Posts">hardware<small>(22)</small></a>
<a rel=tag href=../../../../tags/hexo/ class=tag-link-3 title="1 Posts">hexo<small>(3)</small></a>
<a rel=tag href=../../../../tags/hi3519a/ class=tag-link-4 title="1 Posts">hi3519a<small>(4)</small></a>
<a rel=tag href=../../../../tags/hisilicon/ class=tag-link-57 title="1 Posts">hisilicon<small>(57)</small></a>
<a rel=tag href=../../../../tags/html/ class=tag-link-2 title="1 Posts">html<small>(2)</small></a>
<a rel=tag href=../../../../tags/http/ class=tag-link-6 title="1 Posts">http<small>(6)</small></a>
<a rel=tag href=../../../../tags/hugo/ class=tag-link-14 title="1 Posts">hugo<small>(14)</small></a>
<a rel=tag href=../../../../tags/imagemagick/ class=tag-link-2 title="1 Posts">imagemagick<small>(2)</small></a>
<a rel=tag href=../../../../tags/ip/ class=tag-link-3 title="1 Posts">ip<small>(3)</small></a>
<a rel=tag href=../../../../tags/iproute2/ class=tag-link-5 title="1 Posts">iproute2<small>(5)</small></a>
<a rel=tag href=../../../../tags/iptables/ class=tag-link-17 title="1 Posts">iptables<small>(17)</small></a>
<a rel=tag href=../../../../tags/javascript/ class=tag-link-19 title="1 Posts">javascript<small>(19)</small></a>
<a rel=tag href=../../../../tags/jetson/ class=tag-link-3 title="1 Posts">jetson<small>(3)</small></a>
<a rel=tag href=../../../../tags/jquery/ class=tag-link-12 title="1 Posts">jquery<small>(12)</small></a>
<a rel=tag href=../../../../tags/js/ class=tag-link-10 title="1 Posts">js<small>(10)</small></a>
<a rel=tag href=../../../../tags/jumpserver/ class=tag-link-2 title="1 Posts">jumpserver<small>(2)</small></a>
<a rel=tag href=../../../../tags/jwt/ class=tag-link-3 title="1 Posts">jwt<small>(3)</small></a>
<a rel=tag href=../../../../tags/kernel/ class=tag-link-15 title="1 Posts">kernel<small>(15)</small></a>
<a rel=tag href=../../../../tags/kubernetes/ class=tag-link-11 title="1 Posts">kubernetes<small>(11)</small></a>
<a rel=tag href=../../../../tags/libev/ class=tag-link-2 title="1 Posts">libev<small>(2)</small></a>
<a rel=tag href=../../../../tags/linux/ class=tag-link-22 title="1 Posts">linux<small>(22)</small></a>
<a rel=tag href=../../../../tags/linux-system/ class=tag-link-8 title="1 Posts">linux-system<small>(8)</small></a>
<a rel=tag href=../../../../tags/lvs/ class=tag-link-8 title="1 Posts">lvs<small>(8)</small></a>
<a rel=tag href=../../../../tags/machinelearn/ class=tag-link-3 title="1 Posts">machinelearn<small>(3)</small></a>
<a rel=tag href=../../../../tags/machinelearning/ class=tag-link-11 title="1 Posts">machinelearning<small>(11)</small></a>
<a rel=tag href=../../../../tags/macos/ class=tag-link-14 title="1 Posts">macos<small>(14)</small></a>
<a rel=tag href=../../../../tags/makefile/ class=tag-link-2 title="1 Posts">makefile<small>(2)</small></a>
<a rel=tag href=../../../../tags/mariadb/ class=tag-link-9 title="1 Posts">mariadb<small>(9)</small></a>
<a rel=tag href=../../../../tags/math/ class=tag-link-7 title="1 Posts">math<small>(7)</small></a>
<a rel=tag href=../../../../tags/matplotlib/ class=tag-link-3 title="1 Posts">matplotlib<small>(3)</small></a>
<a rel=tag href=../../../../tags/maven/ class=tag-link-2 title="1 Posts">maven<small>(2)</small></a>
<a rel=tag href=../../../../tags/meteor/ class=tag-link-7 title="1 Posts">meteor<small>(7)</small></a>
<a rel=tag href=../../../../tags/ml/ class=tag-link-3 title="1 Posts">ml<small>(3)</small></a>
<a rel=tag href=../../../../tags/mpp/ class=tag-link-12 title="1 Posts">mpp<small>(12)</small></a>
<a rel=tag href=../../../../tags/mysql/ class=tag-link-61 title="1 Posts">mysql<small>(61)</small></a>
<a rel=tag href=../../../../tags/ncnn/ class=tag-link-3 title="1 Posts">ncnn<small>(3)</small></a>
<a rel=tag href=../../../../tags/netns/ class=tag-link-2 title="1 Posts">netns<small>(2)</small></a>
<a rel=tag href=../../../../tags/network/ class=tag-link-2 title="1 Posts">network<small>(2)</small></a>
<a rel=tag href=../../../../tags/nginx/ class=tag-link-28 title="1 Posts">nginx<small>(28)</small></a>
<a rel=tag href=../../../../tags/nmap/ class=tag-link-2 title="1 Posts">nmap<small>(2)</small></a>
<a rel=tag href=../../../../tags/nnie/ class=tag-link-13 title="1 Posts">nnie<small>(13)</small></a>
<a rel=tag href=../../../../tags/node/ class=tag-link-4 title="1 Posts">node<small>(4)</small></a>
<a rel=tag href=../../../../tags/nosql/ class=tag-link-8 title="1 Posts">nosql<small>(8)</small></a>
<a rel=tag href=../../../../tags/npm/ class=tag-link-3 title="1 Posts">npm<small>(3)</small></a>
<a rel=tag href=../../../../tags/numpy/ class=tag-link-4 title="1 Posts">numpy<small>(4)</small></a>
<a rel=tag href=../../../../tags/oauth2/ class=tag-link-2 title="1 Posts">oauth2<small>(2)</small></a>
<a rel=tag href=../../../../tags/opencv/ class=tag-link-10 title="1 Posts">opencv<small>(10)</small></a>
<a rel=tag href=../../../../tags/openssl/ class=tag-link-3 title="1 Posts">openssl<small>(3)</small></a>
<a rel=tag href=../../../../tags/pandoc/ class=tag-link-2 title="1 Posts">pandoc<small>(2)</small></a>
<a rel=tag href=../../../../tags/php/ class=tag-link-4 title="1 Posts">php<small>(4)</small></a>
<a rel=tag href=../../../../tags/post/ class=tag-link-4 title="1 Posts">post<small>(4)</small></a>
<a rel=tag href=../../../../tags/powershell/ class=tag-link-2 title="1 Posts">powershell<small>(2)</small></a>
<a rel=tag href=../../../../tags/prometheus/ class=tag-link-8 title="1 Posts">prometheus<small>(8)</small></a>
<a rel=tag href=../../../../tags/pyqt/ class=tag-link-8 title="1 Posts">pyqt<small>(8)</small></a>
<a rel=tag href=../../../../tags/python/ class=tag-link-33 title="1 Posts">python<small>(33)</small></a>
<a rel=tag href=../../../../tags/pytorch/ class=tag-link-6 title="1 Posts">pytorch<small>(6)</small></a>
<a rel=tag href=../../../../tags/raspi/ class=tag-link-4 title="1 Posts">raspi<small>(4)</small></a>
<a rel=tag href=../../../../tags/redis/ class=tag-link-2 title="1 Posts">redis<small>(2)</small></a>
<a rel=tag href=../../../../tags/reflect/ class=tag-link-3 title="1 Posts">reflect<small>(3)</small></a>
<a rel=tag href=../../../../tags/responsive/ class=tag-link-2 title="1 Posts">responsive<small>(2)</small></a>
<a rel=tag href=../../../../tags/restful/ class=tag-link-6 title="1 Posts">restful<small>(6)</small></a>
<a rel=tag href=../../../../tags/rk3288/ class=tag-link-22 title="1 Posts">rk3288<small>(22)</small></a>
<a rel=tag href=../../../../tags/rk3399/ class=tag-link-9 title="1 Posts">rk3399<small>(9)</small></a>
<a rel=tag href=../../../../tags/route/ class=tag-link-2 title="1 Posts">route<small>(2)</small></a>
<a rel=tag href=../../../../tags/rsync/ class=tag-link-2 title="1 Posts">rsync<small>(2)</small></a>
<a rel=tag href=../../../../tags/rtmp/ class=tag-link-2 title="1 Posts">rtmp<small>(2)</small></a>
<a rel=tag href=../../../../tags/scikit/ class=tag-link-3 title="1 Posts">scikit<small>(3)</small></a>
<a rel=tag href=../../../../tags/scrapy/ class=tag-link-8 title="1 Posts">scrapy<small>(8)</small></a>
<a rel=tag href=../../../../tags/scss/ class=tag-link-2 title="1 Posts">scss<small>(2)</small></a>
<a rel=tag href=../../../../tags/sed/ class=tag-link-3 title="1 Posts">sed<small>(3)</small></a>
<a rel=tag href=../../../../tags/seo/ class=tag-link-5 title="1 Posts">seo<small>(5)</small></a>
<a rel=tag href=../../../../tags/shell/ class=tag-link-11 title="1 Posts">shell<small>(11)</small></a>
<a rel=tag href=../../../../tags/socket/ class=tag-link-5 title="1 Posts">socket<small>(5)</small></a>
<a rel=tag href=../../../../tags/sqlite/ class=tag-link-2 title="1 Posts">sqlite<small>(2)</small></a>
<a rel=tag href=../../../../tags/ssh/ class=tag-link-3 title="1 Posts">ssh<small>(3)</small></a>
<a rel=tag href=../../../../tags/stm32/ class=tag-link-11 title="1 Posts">stm32<small>(11)</small></a>
<a rel=tag href=../../../../tags/stm8/ class=tag-link-9 title="1 Posts">stm8<small>(9)</small></a>
<a rel=tag href=../../../../tags/swagger/ class=tag-link-2 title="1 Posts">swagger<small>(2)</small></a>
<a rel=tag href=../../../../tags/swarm/ class=tag-link-2 title="1 Posts">swarm<small>(2)</small></a>
<a rel=tag href=../../../../tags/sysbench/ class=tag-link-2 title="1 Posts">sysbench<small>(2)</small></a>
<a rel=tag href=../../../../tags/sysctl/ class=tag-link-2 title="1 Posts">sysctl<small>(2)</small></a>
<a rel=tag href=../../../../tags/systemctl/ class=tag-link-2 title="1 Posts">systemctl<small>(2)</small></a>
<a rel=tag href=../../../../tags/tc/ class=tag-link-2 title="1 Posts">tc<small>(2)</small></a>
<a rel=tag href=../../../../tags/tcpdump/ class=tag-link-2 title="1 Posts">tcpdump<small>(2)</small></a>
<a rel=tag href=../../../../tags/timezone/ class=tag-link-2 title="1 Posts">timezone<small>(2)</small></a>
<a rel=tag href=../../../../tags/tshark/ class=tag-link-2 title="1 Posts">tshark<small>(2)</small></a>
<a rel=tag href=../../../../tags/ubuntu/ class=tag-link-2 title="1 Posts">ubuntu<small>(2)</small></a>
<a rel=tag href=../../../../tags/ulimit/ class=tag-link-2 title="1 Posts">ulimit<small>(2)</small></a>
<a rel=tag href=../../../../tags/vim/ class=tag-link-14 title="1 Posts">vim<small>(14)</small></a>
<a rel=tag href=../../../../tags/webpack3/ class=tag-link-2 title="1 Posts">webpack3<small>(2)</small></a>
<a rel=tag href=../../../../tags/windows/ class=tag-link-18 title="1 Posts">windows<small>(18)</small></a>
<a rel=tag href=../../../../tags/wireshark/ class=tag-link-2 title="1 Posts">wireshark<small>(2)</small></a>
<a rel=tag href=../../../../tags/xidel/ class=tag-link-2 title="1 Posts">xidel<small>(2)</small></a>
<a rel=tag href=../../../../tags/xml/ class=tag-link-2 title="1 Posts">xml<small>(2)</small></a>
<a rel=tag href=../../../../tags/yaml/ class=tag-link-2 title="1 Posts">yaml<small>(2)</small></a>
<a rel=tag href=../../../../tags/yolo/ class=tag-link-16 title="1 Posts">yolo<small>(16)</small></a>
<a rel=tag href=../../../../tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/ class=tag-link-2 title="1 Posts">微服务<small>(2)</small></a></div></div></div></div>`</div></div></div></div></div><script>var HUParams={"_disabled":[],"SmoothScroll":{"Enabled":true,"Options":{"touchpadSupport":false}},"centerAllImg":"1","timerOnScrollAllBrowsers":"1","extLinksStyle":"1","extLinksTargetExt":"1","extLinksSkipSelectors":{"classes":["btn","button"],"ids":[]},"imgSmartLoadEnabled":"1","imgSmartLoadOpts":{"parentSelectors":[".container .content",".container .sidebar","#footer","#header-widgets"],"opts":{"excludeImg":[".tc-holder-img"],"fadeIn_options":100}},"goldenRatio":"1.618","gridGoldenRatioLimit":"350","sbStickyUserSettings":{"desktop":true,"mobile":true},"isWPMobile":"","menuStickyUserSettings":{"desktop":"stick_up","mobile":"stick_up"},"isDevMode":"","ajaxUrl":"https:\/\/demo-hueman.presscustomizr.com\/?huajax=1","frontNonce":{"id":"HuFrontNonce","handle":"798e5956c0"},"userStarted":{"with":"before|1.0.4","on":{"date":"2017-05-22 16:30:22.000000","timezone_type":3,"timezone":"UTC"}},"isWelcomeNoteOn":"","welcomeContent":""};</script><script src=https://cdn.bootcss.com/lodash-compat/3.10.2/lodash.min.js></script><script src=https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js></script><script src=../../../../front/js/scripts.js></script><footer id=footer><section class=container id=footer-bottom><div class=container-inner><a id=back-to-top href=#><i class="fa fa-angle-up"></i></a><div class="pad group"><div class="grid one-half"><div id=copyright><p>Copyright (c) 2017. All rights reserved. (版权所有) <a href=http://www.miitbeian.gov.cn/>鲁ICP备17074587号-1</a></div></div><div class="grid one-half last"><ul class=social-links><li><a class=social-tooltip title="On WeiBo" href=http://weibo.com/rinetd target=_blank><i class="fa fa-weibo"></i></a><li><a class=social-tooltip title="On Twitter" href=https://twitter.com/rinetd target=_blank><i class="fa fa-twitter"></i></a><li><a class=social-tooltip title="On GitHub" href=https://github.com/rinetd target=_blank><i class="fa fa-github"></i></a></ul></div></div></div></section></footer><div class=back-to-top id=back-to-top><i class="fa fa-angle-double-up"></i></div><script>$(".topbar-toggle-down").click(function(){$("#nav-topbar").css("overflow","visible");});</script><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5HM5XM2" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-5HM5XM2');</script>